///// Old demo 3 stuff:

#include "demo_2.c"
#define deinit_texture(t) glDeleteTextures(1, &t)

DemoVars demo_3_init(void) {
	DemoVars dv;

	const char* const vertex_shader =
		"#version 330 core\n"
		"layout(location = 0) in vec3 vertexPosition_modelspace\n"
		"layout(location = 1) in vec2 vertexUV\n"
		"out vec2 UV;\n"
		"uniform mat4 MVP;\n"
		"void main() {\n"
			"gl_Position =  MVP * vec4(vertexPosition_modelspace, 1);\n"
			"UV = vertexUV;\n"
		"}\n",

	*const fragment_shader =
		"#version 330 core\n"
		"in vec2 UV;\n"
		"out vec3 color;\n"
		"uniform sampler2D myTextureSampler;\n"
		"void main() {\n"
    		"color = texture(myTextureSampler, UV).rgb;\n"
		"}\n";
	
	dv.shader_program = init_shader_program(vertex_shader, fragment_shader);

	const GLfloat uv_buffer_data[] = {
    	0.000059f, 1.0f-0.000004f,
    	0.000103f, 1.0f-0.336048f,
    	0.335973f, 1.0f-0.335903f,
    	1.000023f, 1.0f-0.000013f,
    	0.667979f, 1.0f-0.335851f,
    	0.999958f, 1.0f-0.336064f,
    	0.667979f, 1.0f-0.335851f,
    	0.336024f, 1.0f-0.671877f,
    	0.667969f, 1.0f-0.671889f,
    	1.000023f, 1.0f-0.000013f,
    	0.668104f, 1.0f-0.000013f,
    	0.667979f, 1.0f-0.335851f,
    	0.000059f, 1.0f-0.000004f,
    	0.335973f, 1.0f-0.335903f,
    	0.336098f, 1.0f-0.000071f,
    	0.667979f, 1.0f-0.335851f,
    	0.335973f, 1.0f-0.335903f,
    	0.336024f, 1.0f-0.671877f,
    	1.000004f, 1.0f-0.671847f,
    	0.999958f, 1.0f-0.336064f,
    	0.667979f, 1.0f-0.335851f,
    	0.668104f, 1.0f-0.000013f,
    	0.335973f, 1.0f-0.335903f,
    	0.667979f, 1.0f-0.335851f,
    	0.335973f, 1.0f-0.335903f,
    	0.668104f, 1.0f-0.000013f,
    	0.336098f, 1.0f-0.000071f,
    	0.000103f, 1.0f-0.336048f,
    	0.000004f, 1.0f-0.671870f,
    	0.336024f, 1.0f-0.671877f,
    	0.000103f, 1.0f-0.336048f,
    	0.336024f, 1.0f-0.671877f,
    	0.335973f, 1.0f-0.335903f,
    	0.667969f, 1.0f-0.671889f,
    	1.000004f, 1.0f-0.671847f,
    	0.667979f, 1.0f-0.335851f
	};

	(void) uv_buffer_data;

	return dv;
}

GLuint init_texture(const char* const path) {
	SDL_Surface* const image = SDL_LoadBMP(path);
	if (image == NULL) fail("open image file", OpenImageFile);
	SDL_LockSurface(image);

	GLuint texture;

	glGenTextures(1, &texture);
	glBindTexture(GL_TEXTURE_2D, texture);

	glTexImage2D(GL_TEXTURE_2D, 0, GL_RGB, image -> w, image -> h, 0, GL_BGR, GL_UNSIGNED_BYTE, image -> pixels);

	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_LINEAR);
	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
	glGenerateMipmap(GL_TEXTURE_2D);

	SDL_UnlockSurface(image);
	SDL_FreeSurface(image);
	return texture;
}

void demo_3_drawer(const DemoVars dv) {
	/*
	GLuint foo = init_texture("assets/walls/mesa.bmp");
	deinit_texture(foo);
	*/

	demo_2_drawer(dv);
}

int main(void) {
	// load_texture("assets/walls/mesa.bmp");
	make_application(demo_3_drawer, demo_2_init, demo_1_deinit);
}

///// Lots of vertex testing:


	GLfloat texcoords[][2] = { {0.0,0.0},    {1.0,0.0}, {1.0,1.0}, {0.0,1.0},
                               {0.0,0.0}, {1.0,0.0}, {1.0,1.0}, {0.0,1.0},
                               {0.0,0.0}, {1.0,0.0}, {1.0,1.0}, {0.0,1.0},
                               {0.0,0.0}, {1.0,0.0}, {1.0,1.0}, {0.0,1.0}
                             };

	GLubyte indices[24] = {0,1,2,3, 4,5,6,7, 3,2,5,4, 7,6,1,0,
                                  8,9,10,11, 12,13,14,15};

	/*
	for (int i = 0; i < 24; i++) {
		GLfloat* uv = texcoords[indices[i]];
		printf("%lff, %lff,\n", uv[0], uv[1]);
	}

	GLfloat uv_data[num_uv_floats] = {
		0.0, 0.0,
		1.0, 0.0,
		1.0, 1.0,
		0.0, 1.0,
		
		0.0, 0.0,
		1.0, 0.0,
		1.0, 1.0,
		0.0, 1.0,

		0.0, 1.0,
	};
	*/

GLfloat uv_data[] = {
	0.000000f, 0.000000f,
1.000000f, 0.000000f,
1.000000f, 1.000000f,
0.000000f, 1.000000f,
0.000000f, 0.000000f,
1.000000f, 0.000000f,
1.000000f, 1.000000f,
0.000000f, 1.000000f,
0.000000f, 1.000000f,
1.000000f, 1.000000f,
1.000000f, 0.000000f,
0.000000f, 0.000000f,
0.000000f, 1.000000f,
1.000000f, 1.000000f,
1.000000f, 0.000000f,
0.000000f, 0.000000f,
0.000000f, 0.000000f,
1.000000f, 0.000000f,
1.000000f, 1.000000f,
0.000000f, 1.000000f,
0.000000f, 0.000000f,
1.000000f, 0.000000f,
1.000000f, 1.000000f,
0.000000f, 1.000000f,
};



	/*
	#define TOP_LEFT 0.0f, 0.0f
	#define BOTTOM_LEFT 1.0f, 0.0f
	#define TOP_RIGHT 0.0f, 1.0f

	#define TRI_SET TOP_RIGHT, BOTTOM_LEFT, TOP_LEFT
	#define REV_TRI_SET TOP_LEFT, BOTTOM_LEFT, TOP_RIGHT

	static const GLfloat uv_data[num_uv_floats] = {
		TRI_SET,
		REV_TRI_SET,
		TRI_SET,
		REV_TRI_SET,
		TRI_SET,
		REV_TRI_SET,
		TRI_SET,
		REV_TRI_SET,
		TRI_SET,
		REV_TRI_SET,
		TRI_SET,
		REV_TRI_SET
	};
	*/

	/*
	static const GLfloat uv_data[num_uv_floats] = {
		0.000059f, 1.0f-0.000004f,
		0.000103f, 1.0f-0.336048f,
		0.335973f, 1.0f-0.335903f,
		1.000023f, 1.0f-0.000013f,
		0.667979f, 1.0f-0.335851f,
		0.999958f, 1.0f-0.336064f,
		0.667979f, 1.0f-0.335851f,
		0.336024f, 1.0f-0.671877f,
		0.667969f, 1.0f-0.671889f,
		1.000023f, 1.0f-0.000013f,
		0.668104f, 1.0f-0.000013f,
		0.667979f, 1.0f-0.335851f,
		0.000059f, 1.0f-0.000004f,
		0.335973f, 1.0f-0.335903f,
		0.336098f, 1.0f-0.000071f,
		0.667979f, 1.0f-0.335851f,
		0.335973f, 1.0f-0.335903f,
		0.336024f, 1.0f-0.671877f,
		1.000004f, 1.0f-0.671847f,
		0.999958f, 1.0f-0.336064f,
		0.667979f, 1.0f-0.335851f,
		0.668104f, 1.0f-0.000013f,
		0.335973f, 1.0f-0.335903f,
		0.667979f, 1.0f-0.335851f,
		0.335973f, 1.0f-0.335903f,
		0.668104f, 1.0f-0.000013f,
		0.336098f, 1.0f-0.000071f,
		0.000103f, 1.0f-0.336048f,
		0.000004f, 1.0f-0.671870f,
		0.336024f, 1.0f-0.671877f,
		0.000103f, 1.0f-0.336048f,
		0.336024f, 1.0f-0.671877f,
		0.335973f, 1.0f-0.335903f,
		0.667969f, 1.0f-0.671889f,
		1.000004f, 1.0f-0.671847f,
		0.667979f, 1.0f-0.335851f
	};
	*/

///// Even more tries:


	static const GLfloat uv_data[num_uv_floats] = {
		/* Sorta worked:
		0.0f, 0.0f,
		1.0f, 0.0f,
		1.0f, 1.0f
		*/

		/* Flipped 90 degrees:
		0.0f, 1.0f,
		0.0f, 0.0f,
		1.0f, 0.0f,
		*/


		/* Almost:
		0.0f, 1.0f,
		0.0f, 0.0f,
		1.0f, 0.0f
		*/

		/*
		0.0f, 0.0f,
		0.5f, 0.5f,
		1.0f, 1.0f
		*/

  0.0f, 0.0f, 1.0f, 0.0f, 1.0f, 1.0f,
  0.0f, 0.0f, 1.0f, 1.0f, 0.0f, 1.0f,

  0.0f, 0.0f, 1.0f, 0.0f, 1.0f, 1.0f,
  0.0f, 0.0f, 1.0f, 1.0f, 0.0f, 1.0f,

  0.0f, 0.0f, 1.0f, 0.0f, 1.0f, 1.0f,
  0.0f, 0.0f, 1.0f, 1.0f, 0.0f, 1.0f,

  0.0f, 0.0f, 1.0f, 0.0f, 1.0f, 1.0f,
  0.0f, 0.0f, 1.0f, 1.0f, 0.0f, 1.0f,

  0.0f, 0.0f, 1.0f, 0.0f, 1.0f, 1.0f,
  0.0f, 0.0f, 1.0f, 1.0f, 0.0f, 1.0f,

  0.0f, 0.0f, 1.0f, 0.0f, 1.0f, 1.0f,
  0.0f, 0.0f, 1.0f, 1.0f, 0.0f, 1.0f
	};

///// A note on UV reversals:

	// rev
	#define FIRST_UV 0.0f, 1.0f, 1.0f, 1.0f, 1.0f, 0.0f,
	#define SECOND_UV 0.0f, 0.0f, 1.0f, 1.0f, 1.0f, 0.0f,

	// rev
	#define THIRD_UV 0.0f, 0.0f, 0.0f, 1.0f, 1.0f, 1.0f,
	#define FOURTH_UV 0.0f, 1.0f, 1.0f, 0.0f, 0.0f, 0.0f,

	// fifth and sixth are reversed
	#define FIFTH_UV 1.0f, 1.0f, 0.0f, 0.0f, 0.0f, 1.0f,
	#define SIXTH_UV 1.0f, 0.0f, 0.0f, 0.0f, 1.0f, 1.0f,

	// 1 2 2 3 4 3 3 2 5 1 4 6

///// An indexing test

// Possibilities
#define P1 1.0f, 1.0f, 1.0f,
#define P2 -1.0f, -1.0f, -1.0f,

#define P3 -1.0f, 1.0f, 1.0f,
#define P4 1.0f, -1.0f, 1.0f,
#define P5 1.0f, 1.0f, -1.0f,

#define P6 -1.0f, -1.0f, 1.0f,
#define P7 1.0f, -1.0f, -1.0f,

#define P8 -1.0f, 1.0f, -1.0f

/*
	P2 P6 P3

	P5 P2 P8
*/

///// Stuff with automatic index generation:


	int index_buf_len = 0;
	int index_buffer[cube_num_points];

	for (int i = 0; i < cube_num_points; i += 3) {
		const float x = demo_3_vertex_data[i], y = demo_3_vertex_data[i + 1], z = demo_3_vertex_data[i + 2];

		byte found_match = 0;
		for (int j = 0; j < i; j += 3) {
			const float cx = demo_3_vertex_data[j], cy = demo_3_vertex_data[j + 1], cz = demo_3_vertex_data[j + 2];
			if (x == cx && y == cy && z == cz) {
				index_buffer[index_buf_len++] = j / 3;
				found_match = 1;
				break;
			}
		}

		if (!found_match) {
			printf("%lf, %lf, %lf\n", (double) x, (double) y, (double) z);
			index_buffer[index_buf_len] = index_buf_len;
			index_buf_len++;
		}
	}

	for (int i = 0; i < index_buf_len + 1; i++) {
		printf("%d%s", index_buffer[i], (i == index_buf_len - 1) ? "" : ", ");
	}
	putchar('\n');

///// And more of that:

#define A -1.000000, -1.000000, -1.000000
#define B -1.000000, -1.000000, 1.000000
#define C -1.000000, 1.000000, 1.000000
#define D 1.000000, 1.000000, -1.000000
#define E -1.000000, 1.000000, -1.000000
#define F 1.000000, -1.000000, 1.000000
#define G 1.000000, -1.000000, -1.000000
#define H 1.000000, 1.000000, 1.000000
/* 0, 1, 2, 3, 0,
5, 6, 0, 8, 3, 8,
0, 0, 2, 5, 6, 1, 0, 2, 1, 6, 21, 8, 3, 8, 21, 6, 21, 3, 5, 21, 5, 2, 21, 2, 6
*/

const GLfloat demo_3_vertex_data[cube_num_points] = {
	// A B C D A

///// Old vertex data:

	/*
	-1.0f, -1.0f, -1.0f, // triangle 1: begin
	-1.0f, -1.0f, 1.0f,
	-1.0f, 1.0f, 1.0f, // triangle 1: end

	1.0f, 1.0f, -1.0f, // triangle 2: begin
	-1.0f, -1.0f, -1.0f,
	-1.0f, 1.0f, -1.0f, // triangle 2: end

	1.0f, -1.0f, 1.0f,
	-1.0f, -1.0f, -1.0f,
	1.0f, -1.0f, -1.0f,

	1.0f, 1.0f, -1.0f,
	1.0f, -1.0f, -1.0f,
	-1.0f, -1.0f, -1.0f,

	-1.0f, -1.0f, -1.0f,
	-1.0f, 1.0f, 1.0f,
	-1.0f, 1.0f, -1.0f,

	1.0f, -1.0f, 1.0f,
	-1.0f, -1.0f, 1.0f,
	-1.0f, -1.0f, -1.0f,

	-1.0f, 1.0f, 1.0f,
	-1.0f, -1.0f, 1.0f,
	1.0f, -1.0f, 1.0f,

	1.0f, 1.0f, 1.0f,
	1.0f, -1.0f, -1.0f,
	1.0f, 1.0f, -1.0f,

	1.0f, -1.0f, -1.0f,
	1.0f, 1.0f, 1.0f,
	1.0f, -1.0f, 1.0f,

	1.0f, 1.0f, 1.0f,
	1.0f, 1.0f, -1.0f,
	-1.0f, 1.0f, -1.0f,

	1.0f, 1.0f, 1.0f,
	-1.0f, 1.0f, -1.0f,
	-1.0f, 1.0f, 1.0f,

	1.0f, 1.0f, 1.0f,
	-1.0f, 1.0f, 1.0f,
	1.0f, -1.0f, 1.0f
	*/

/////


		/*
		top_left_x, 0.0f, z,
		top_left_x + width, 0.0f, z,
		top_left_x, -height, z,

		top_left_x, -height, z,
		top_left_x + width, -height, z,
		top_left_x + width, 0.0f, z
		*/

		/*
		0.0f, 0.0f, z,
		width, 0.0f, z,
		0.0f, -height, z,

		0.0f, -height, z,
		width, -height, z,
		width, 0.0f, z
		*/

		/*
		-s, s, 0.0f,
		s, s, 0.0f,
		-s, -s, 0.0f,

		-s, -s, 0.0f,
		s, -s, 0.0f,
		s, s, 0.0f
		*/

/////

		/*
		top_left_x, top_left_y, z,
		top_left_x + width, top_left_y, z,
		top_left_x, top_left_y - height, z,

		top_left_x, top_left_y - height, z,
		top_left_x + width, top_left_y - height, z,
		top_left_x + width, top_left_y, z
		*/
	
/////

	(void) top_left_corner;
	// const float half_width = width / 2.0f, half_height = height / 2.0f;

	/*
	1____0
	|  . |
	2____|


	0___1
	|   /
	|  /
	| /
	2/
	*/

	/*
	Top left corner at {0, 0}
	*/

/////

		/*
		0.0f, 0.0f, far,
		1.0f, 0.0f, far,
		0.0f, 0.0f, near
		*/

		/*
		-s, s, 0.0f,
		s, s, 0.0f,
		-s, -s, 0.0f,
		*/

		/*
		-1.0f, -1.0f, 0.0f,
		1.0f, -1.0f, 0.0f,
		0.0f, 1.0f, 0.0f
		*/

		/*
		0.0f, height, far,
		0.0f, height, near,
		1.0f, height, far
		*/

/////

	/*
	GLfloat
		*const plane_vertices = create_vert_plane(top_left_corner, size_hori, size_vert),
		*const uv_data = create_uv_for_plane(size_hori, size_vert);

	sgl.num_vertex_buffers = 2;
	sgl.vertex_buffers = init_vbos(sgl.num_vertex_buffers,
		plane_vertices, plane_vertex_bytes,
		uv_data, plane_uv_bytes);

	free(plane_vertices);
	free(uv_data);
	*/

/////

Functions to make:
- void create_cuboid(const vec3 origin, const vec3 size);
actually, instead of create_cuboid, make a make_planes fn (since sector meshes will not exactly be rectangles)
- GLfloat* join_plane_vertices(const GLfloat* const plane_1, const GLfloat* const plane_2);

/////

void draw_triangles(const int num_triangles) {
	glDrawArrays(GL_TRIANGLE_STRIP, 0, 4); // num_triangles * 3
	// glDrawArraysInstanced(GL_TRIANGLES, 0, num_triangles * 3, 1);
	// glDrawElements(GL_TRIANGLES, num_triangles * 3, GL_UNSIGNED_INT, NULL);
	// GL_ERR_CHECK;
}

/////

	/////
	glGenBuffers(sgl.num_vertex_buffers, &sgl.vertex_buffers);
	glBindBuffer(GL_ARRAY_BUFFER, sgl.vertex_buffers);
	glBufferData(GL_ARRAY_BUFFER, interleaved_plane_bytes, plane_data, GL_STATIC_DRAW);
	/////

/////

	/*
	.A B C
	C B D
	C D D - deg
	D D E - deg
	D E E - deg
	E E F - deg
	E F G
	G F H

	in as {A, B, C, D,
		D, E,
		E, F, G, H} to gpu

	plane_1 = {A, B, C, D}, plane_2 = {E, F, G, H};

	B--D    F--H
	|\ |    |\ |
	| \|    | \|
	A--C    E--G

	Whoops, theirs were like that
	Retrying
	*/

	/*
	New order:
	0 1 2
	1 2 3

	2 3 4
	3 4 5

	3 4 5
	4 5 6
	*/

/////

/*
Only join if next to each other:


0__1
|  /
| /
2/

    2
   /|
  / |
1/__3

2__4
|  /
| /
3/
*/

///// A programmatic plane creator (didn't work, but only discarding b/c hard to maintain):

	void (*const plane_creators[3])(PLANE_CREATOR_SIGNATURE) = {
		PLANE_CREATOR_NAME(vert_2), PLANE_CREATOR_NAME(hori), PLANE_CREATOR_NAME(vert_1)
	};

	int i = 0;
	for (byte varied_axis = 0; varied_axis < 3; varied_axis++) {
		const byte size_axis_x = (varied_axis == 0) * 2, size_axis_y = (varied_axis == 1) + 1;
		void (*const plane_creator)(PLANE_CREATOR_SIGNATURE) = plane_creators[varied_axis];

		plane_creator(origin, size[size_axis_x], size[size_axis_y], sector_mesh + i);
		i++;
		origin[varied_axis] += size[varied_axis];
		plane_creator(origin, size[size_axis_x], size[size_axis_y], sector_mesh + i);
		origin[varied_axis] -= size[varied_axis];
		i++;
	}

///// Old hori plane creation:

	PLANE_CREATOR_NAME(hori)(origin, size[0], size[2], sector_mesh + vars_per_plane * 2);
	origin[1] -= size[1];
	PLANE_CREATOR_NAME(hori)(origin, size[0], size[2], sector_mesh + vars_per_plane * 3);
	origin[1] += size[1];

/////

		/*
		0____1
		\   |
		 \  |
           2

		tri is

		0_1
		| /
		2/

		from other side

		b4: {0.0f, 0.0f}, {size_z, 0.0f}, {0.0f, size_y}
		after: {size_z, 0.0f}, {0.0f, 0.0f}, {0.0f, size_y}
		no
		*/

		/* orig flipped:
		far_x, top_y, near_z, 0.0f, 0.0f,
		far_x, top_y, far_z, size_z, 0.0f,
		far_x, bottom_y, near_z, 0.0f, size_y,
		*/

///// Vertices ordered by triangle pairs:

	const plane_type_t vertices[vars_per_mesh] = {
		// Top triangles aligned along Z axis (each pair in opposite winding order from each other)
		near_x, bottom_y, near_z, 0, size_y,
		near_x, top_y, far_z, size_z, 0,
		near_x, top_y, near_z, 0, 0,
		// gotten

		far_x, top_y, near_z, size_z, 0,
		far_x, top_y, far_z, 0, 0,
		far_x, bottom_y, near_z, size_z, size_y,

		// Bottom triangles aligned along Z axis
		near_x, bottom_y, near_z, 0, size_y,
		near_x, bottom_y, far_z, size_z, size_y,
		near_x, top_y, far_z, size_z, 0,
		// gotten

		far_x, top_y, far_z, 0, 0,
		far_x, bottom_y, far_z, 0, size_y,
		far_x, bottom_y, near_z, size_z, size_y,

		// Top triangles aligned along X axis
		near_x, top_y, near_z, size_x, 0,
		far_x, top_y, near_z, 0, 0,
		near_x, bottom_y, near_z, size_x, size_y,

		near_x, bottom_y, far_z, 0, size_y,
		far_x, top_y, far_z, size_x, 0,
		near_x, top_y, far_z, 0, 0,

		// Bottom triangles aligned along X axis
		far_x, top_y, near_z, 0, 0,
		far_x, bottom_y, near_z, 0, size_y,
		near_x, bottom_y, near_z, size_x, size_y,

		near_x, bottom_y, far_z, 0, size_y,
		far_x, bottom_y, far_z, size_x, size_y,
		far_x, top_y, far_z, size_x, 0,

		// Top triangle aligned along Y axis (flat)
		near_x, top_y, far_z, size_z, size_x,
		far_x, top_y, near_z, 0, 0,
		near_x, top_y, near_z, 0, size_x,

		// Bottom triangle aligned along Y axis (flat)
		near_x, top_y, far_z, size_z, size_x,
		far_x, top_y, far_z, size_z, 0,
		far_x, top_y, near_z, 0, 0

		// No matching degenerate bottom triangle under block here since not needed for sake of culling
	};

/////

void attempt_sector_fill_at(byte* const heightmap, const byte map_width,
	const byte map_height, const byte x, const byte y) {

	(void) heightmap;
	(void) map_width;
	(void) map_height;
	(void) x;
	(void) y;

	const byte height = *map_point(heightmap, x, y, map_width);
	// If the point is a potential corner
	const int top_left_corner_vals[3][2] = {
		{x - 1, y}, {x - 1, y - 1}, {x, y - 1}
	};

	byte corner_heights_not_eq_sum = 0;
	for (byte i = 0; i < 3; i++) {
		const int* const top_left_corner = top_left_corner_vals[i];
		const int x = top_left_corner[0], y = top_left_corner[1];

		if (x < 0 || x >= map_width || y < 0 || y >= map_height || *map_point(heightmap, x, y, map_width) != height)
		corner_heights_not_eq_sum++;
	}

	/*
	byte* const height_ref = map_point(heightmap, x, y, map_width);
	const byte height = *height_ref;
	if (height > 0) {
		SectorArea area = {.height = height};
	}
	*/
}

/////

	if (x < 0 || y < 0 || x >= map_width || y >= map_height) return;

/////

	// Not correct at the moment

	// Attempting expansions

	/*
	while (bottom_right[1] < map_height) {
		while (bottom_right[0] < map_width) {
			if (area_is_valid(&area, map, map_width)) bottom_right[0]++;
			else break;
		}
		if (area_is_valid(&area, map, map_width)) bottom_right[1]++;
	}

	for (byte y = area.origin[1]; y < bottom_right[1]; y++) {
		for (byte x = area.origin[0]; x < bottom_right[0]; x++)
			*map_point(map, x, y, map_width) = 0;
	}

	area.size[0] = bottom_right[0] - area.origin[0];
	area.size[1] = bottom_right[1] - area.origin[1];
	return area;
	*/

/////

// byte bottom_right[2] = {area.origin[0] + area.size[0], area.origin[1] + area.size[1]}; // Stored as {x, y}

///// Old sector code:

byte area_is_valid(const SectorArea* const area, byte* const map, const byte map_width) {
	const byte start_x = area -> origin[0], start_y = area -> origin[1];
	const byte end_x = start_x + area -> size[0], end_y = area -> size[1];

	for (byte y = start_y; y < end_y; y++) {
		for (byte x = start_x; x < end_x; x++) {
			if (*map_point(map, x, y, map_width) != area -> height) return 0;
		}
	}
	return 1;
}

// Corner is top left
SectorArea attempt_area_fill(SectorArea area, byte* const map, const byte map_width, const byte map_height) {
	// Not working correctly yet
	for (byte y = area.origin[1]; y < map_height; y++) {
		for (byte x = area.origin[0]; x < map_width; x++) {
			if (area_is_valid(&area, map, map_width)) area.size[0]++;
			else break;
		}
		if (area_is_valid(&area, map, map_width)) area.size[1]++;
		else break;
	}

	for (byte y = area.origin[1]; y < area.origin[1] + area.size[1]; y++) {
		for (byte x = area.origin[0]; x < area.origin[0] + area.size[0]; x++)
			*map_point(map, x, y, map_width) = 0;
	}

	return area;
}

///// Some 6-vertex vertices for a flat vert tomato:

	const plane_type_t triangle_vertices[30] = {
		near_x, bottom_y, near_z, 0, size_y,
		near_x, top_y, far_z, size_z, 0,
		near_x, top_y, near_z, 0, 0,

		near_x, bottom_y, near_z, 0, size_y,
		near_x, bottom_y, far_z, size_z, size_y,
		near_x, top_y, far_z, size_z, 0
	};

///// Stuff:

	const plane_type_t origin[3] = {0, 2, 0}, size[3] = {2, 1, 4};
	const plane_type_t near_x = origin[0], top_y = origin[1], near_z = origin[2], size_x = size[0], size_y = size[1], size_z = size[2];
	const plane_type_t far_x = near_x + size_x, bottom_y = top_y - size_y, far_z = near_z + size_z;

	// const plane_type_t width = 3, height = 2;
	// const plane_type_t width = size_y, height = size[0];
	// const plane_type_t width = size_z, height = size_y;

	const plane_type_t triangle_vertices[] = {
		

		/*
		near_x, top_y, near_z, 0, 0,
		far_x, top_y, near_z, 0, size_x,
		near_x, bottom_y, near_z, size_y, 0
		*/

		/*
		near_x, bottom_y, near_z, 0, size_y,
		near_x, top_y, far_z, size_z, 0,
		near_x, top_y, near_z, 0, 0,
		near_x, bottom_y, far_z, size_z, size_y
		*/

		/*
		near_x, top_y, far_z, 0.0f, 0.0f,
		near_x, top_y, near_z, width, 0.0f,

		near_x, bottom_y, far_z, 0.0f, height,
		near_x, bottom_y, near_z, width, height
		*/


		/*
		near_x, bottom_y, near_z, 0, size_y,
		near_x, top_y, far_z, size_z, 0,
		near_x, top_y, near_z, 0, 0,

		near_x, bottom_y, near_z, 0, size_y,
		near_x, bottom_y, far_z, size_z, size_y,
		near_x, top_y, far_z, size_z, 0
		*/
	};

////// The old vertices for the billboard:

	const billboard_type_t top_left_corner[3] = {2, 3, 1}, size[3] = {1, 2, 1};

	const billboard_type_t
		near_x = top_left_corner[0], top_y = top_left_corner[1], near_z = top_left_corner[2],
		size_y = size[1], size_z = size[2];

	const billboard_type_t bottom_y = top_y - size_y, far_z = near_z + size_z;

	const billboard_type_t vertices[20] = {
		near_x, top_y, near_z, 0, 0,
		near_x, top_y, far_z, size_z, 0,

		near_x, bottom_y, near_z, 0, size_y,
		near_x, bottom_y, far_z, size_z, size_y
	};

/////

	/*
	const billboard_type_t top_left_corner[3] = {0.5, 0.5, 0.0}, size[3] = {0.5, 0.5, 0.5};

	const billboard_type_t
		near_x = top_left_corner[0], top_y = top_left_corner[1], near_z = top_left_corner[2],
		size_y = size[1], size_z = size[2];

	const billboard_type_t bottom_y = top_y - size_y, far_z = near_z + size_z;

	const billboard_type_t vertices[] = {
		near_x, top_y, near_z,
		near_x, top_y, far_z,

		near_x, bottom_y, near_z,
		near_x, bottom_y, far_z
	};

	for (int i = 0; i < 12; i++) {
		printf("%f ", (double) vertices[i]);
		if (i == 2 || i == 5 || i == 8 || i == 11) printf("\n");
	}
	*/

/////

	#define PRINT_MAT(m)\
		for (int y = 0; y < 4; y++) {\
			for (int x = 0; x < 4; x++)\
				printf("%lf ", (double) m[y][x]);\
			putchar('\n');\
		} putchar('\n');

/////

/*
- Billboards
- Next step: set uniform vars
- http://www.opengl-tutorial.org/intermediate-tutorials/billboards-particles/billboards/#solution-3--the-fixed-size-3d-way
- https://github.com/opengl-tutorials/ogl/tree/master/tutorial18_billboards_and_particles
*/

/*
- Have 4 corners of sprite
- Can get right vec and up vec in shader

E = player vector
P = billboard vector
F = player-billboard-delta vector = P - E
R = right vector = global up vector crossed with F
U = up vector = F crossed with R

Top right corner = U + R
Top left corner = U - R
Bottom left corner = -U - R
Bottom right corner = R - U
*/

/////

		center[0] - half_size[0], center[1] - half_size[1],
		center[0] + half_size[0], center[1] - half_size[1],

		center[0] - half_size[0], center[1] + half_size[1],
		center[0] + half_size[0], center[1] + half_size[1]
		/*

///// Some manual frustum stuff:

	/*
	glm_vec3s_add((vec3) {1, 0, 0}, b, c);
	glm_vec3s_add(c, glms_vec3_cross(a, b, c), c);
	*/

	/*
	near.normal = pos + dir * near_clip
	far.normal = pos + dir * far_clip
	(left, right, top, bottom).normal = pos
	near.dist = 
	*/

	/*
	const GLfloat
		*const pos = camera -> pos, *const dir = camera -> dir,
		near_clip = camera -> clip_dists.near, far_clip = camera -> clip_dists.far;

	const GLfloat
		dir_times_far_clip[3] = {dir[0] * far_clip, dir[1] * far_clip, dir[2] * far_clip},
		half_far_clip_rect_height = far_clip * tanf(camera -> vert_fov * 0.5f);

	const GLfloat half_far_clip_rect_width = half_far_clip_rect_height * camera -> aspect_ratio;


	Frustum frustum = {
		.near = {{pos[0] + dir[0] * near_clip, pos[1] + dir[1] * near_clip, pos[2] + dir[2] * near_clip}, -1.0f},
		.far = {{pos[0] + dir_times_far_clip[0], pos[1] + dir_times_far_clip[1], pos[2] + dir_times_far_clip[2]}, -1.0f},

		.left = {{pos[0], pos[1], pos[2]}, -1.0f},
	};

/////

typedef struct {
	const GLfloat normal[3], dist; // Dist from origin to nearest point on plane
} Plane;

typedef struct {
	// const Plane near, far, left, right, top, bottom;

} Frustum;

///// An attempt at something branchless for movement:

	// const GLfloat* move_dir, speed;
	// const GLfloat* move_dirs[2] = {dir, camera -> right}, speeds[2] = {actual_speed, -actual_speed};


	const GLfloat* const move_dir =
		(keys[constants.movement_keys.forward] || keys[constants.movement_keys.backward]) ? dir : camera -> right,

	speed = (keys[constants.movement_keys.])


	// const GLfloat* const move_dir = ((GLfloat*[2]) {dir, camera -> right})[0];


	/*
	if (keys[constants.movement_keys.forward]) {
		move_dir =
	}

/////

	/* The vertex shader needs a dummy input here - the vertex ID
	could be gotten through gl_VertexID, but this only ranges from 0 to 3,
	which fits within the domain needed to access vertices_model_space */
	"layout(location = 0) in int vertex_id;"

/////

		/* Swizzle arrangements:
		flat: xz for demo 14, but actually something else not found
		vert 1:
		vert 2:

		tried: yz, xy, zy, yz */

/////

const char* const demo_15_vertex_shader =
    "#version 330 core\n"

    "layout(location = 0) in vec3 vertex_pos_model_space;\n"
    "out vec3 UV_3D;\n"
    "uniform mat4 M, MVP;\n" // model, model-view-projection

    "void main() {\n"
        "vec4 pos = MVP * vec4(vertex_pos_model_space, 1.0);\n"
        "gl_Position = pos.xyww;\n"

        // Perhaps just vertex_pos_model_space
        "UV_3D = vec3(model * vec4(vertex_pos_model_space, 1.0));\n"
    "}\n",

*const demo_15_fragment_shader =
    "#version 330 core\n"

    "in vec3 UV_3D;\n"
    "out vec4 color;\n"
    "uniform samplerCube skybox;\n"

    "void main() {\n"
        "color = texture(skybox, UV_3D);\n"
    "}\n";

/////

	/*
	for (int y = 0; y < 4; y++) {
		for (int x = 0; x < 4; x++) {
			printf("%lf ", (double) camera.view_projection[y][x]);
		}
		puts("|");
	}
	puts("---");

/////

// Skybox is a cubemap
GLuint init_skybox_texture(const char* const path) {
	// Start with same 6 faces

	/*
	const char* const paths[6] = {
		"assets/right.bmp",
		"assets/left.bmp",
		"assets/top.bmp",
		"assets/bottom.bmp",
		"assets/front.bmp",
		"assets/back.bmp"
	};
	*/

	GLuint skybox;
	glGenTextures(1, &skybox);
	glBindTexture(GL_TEXTURE_CUBE_MAP, skybox);

	glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_MAG_FILTER, OPENGL_TEX_MAG_FILTER);
	glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_MIN_FILTER, OPENGL_SKYBOX_TEX_MIN_FILTER);
	glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_WRAP_S, tex_nonrepeating);
	glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_WRAP_T, tex_nonrepeating);
	glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_WRAP_R, tex_nonrepeating);

	SDL_Surface* const surface = init_surface(path);
	const void* const pixels = surface -> pixels;
	const GLint surface_size[2] = {64, 64}; // surface -> w, surface -> h};
	GL_ERR_CHECK;

	// right, left, top, bottom, back, front

	const GLsizei cube_size = surface_size[0] >> 2;

	/*
	const GLint origin_1[2] = {0, cube_size};

	glTexImage2D(GL_TEXTURE_CUBE_MAP,
		0, OPENGL_INTERNAL_PIXEL_FORMAT, surface_size[0],
		surface_size[1], 0, OPENGL_INPUT_PIXEL_FORMAT,
		OPENGL_COLOR_CHANNEL_TYPE, pixels);
	*/
	
	for (byte i = 0; i < 6; i++) { // "../../../assets/walls/hieroglyph.bmp"
		/*
		glTexSubImage2D(GL_TEXTURE_CUBE_MAP_POSITIVE_X + i,
			0, origin_1[0], origin_1[1], cube_size, cube_size,

			OPENGL_INPUT_PIXEL_FORMAT, OPENGL_COLOR_CHANNEL_TYPE, pixels
		);
		*/

		glTexImage2D(GL_TEXTURE_CUBE_MAP_POSITIVE_X + i,
			0, OPENGL_INTERNAL_PIXEL_FORMAT,
			surface_size[0], surface_size[1], 0, OPENGL_INPUT_PIXEL_FORMAT,
			OPENGL_COLOR_CHANNEL_TYPE, surface -> pixels);
		
		GL_ERR_CHECK;
	}
	deinit_surface(surface);

	glGenerateMipmap(GL_TEXTURE_CUBE_MAP);

	return skybox;
}

/////

	/*
	const char* const paths[6] = {
		"assets/right.bmp",
		"assets/left.bmp",
		"assets/top.bmp",
		"assets/bottom.bmp",
		"assets/front.bmp",
		"assets/back.bmp"
	};

	(void) path;
	GLuint skybox;
	glGenTextures(1, &skybox);
	glBindTexture(GL_TEXTURE_CUBE_MAP, skybox);

	glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_MAG_FILTER, OPENGL_TEX_MAG_FILTER);
	glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_MIN_FILTER, OPENGL_SKYBOX_TEX_MIN_FILTER);
	glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_WRAP_S, tex_nonrepeating);
	glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_WRAP_T, tex_nonrepeating);
	glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_WRAP_R, tex_nonrepeating);

	for (byte i = 0; i < 6; i++) {
		SDL_Surface* const surface = init_surface(paths[i]);

		glTexImage2D(GL_TEXTURE_CUBE_MAP_POSITIVE_X + i,
			0, OPENGL_INTERNAL_PIXEL_FORMAT,
			surface -> w, surface -> h, 0, OPENGL_INPUT_PIXEL_FORMAT,
			OPENGL_COLOR_CHANNEL_TYPE, surface -> pixels);

		deinit_surface(surface);
	}

	glGenerateMipmap(GL_TEXTURE_CUBE_MAP);

	return skybox;
	*/

/////

			/*
			memset(face_pixels + y * pitch, 0xF0F8FF / (y + 1), row_bytes); // works
			memset(face_pixels + y * pitch, 0xF0F8FF, row_bytes); // works
			*/

			/*
			const void* dest = face_pixels + y * row_bytes;

			int src_start = y + cube_size;
			const void* src = skybox_pixels + src_start * row_bytes;

			memcpy(dest, src, row_bytes);
			*/

/////

		for (int y = 0; y < cube_size; y++) {
			// pitch = width * 4
			const int pitch = cube_size * 4;

			Uint32* dest = read_texture_row(face_pixels, pitch, y);
			Uint32* src = read_texture_row(skybox_pixels, pitch, y);		

			memcpy(dest + 1, src, row_bytes);

			/*
			Uint32* dest = read_texture_row(face_pixels, pitch, y);
			Uint32* src = read_texture_row(face_pixels, pitch, y + cube_size);
			*/

			/*
			void* const ndest = face_pixels + y * pitch, *nsrc = skybox_pixels + (y) * pitch;
			memcpy(ndest, nsrc, row_bytes);
			*/
		}

/////

/* right = GL_TEXTURE_CUBE_MAP_POSITIVE_X
left = GL_TEXTURE_CUBE_MAP_NEGATIVE_X

top = GL_TEXTURE_CUBE_MAP_POSITIVE_Y
bottom = GL_TEXTURE_CUBE_MAP_NEGATIVE_Y

back = GL_TEXTURE_CUBE_MAP_POSITIVE_Z
front = GL_TEXTURE_CUBE_MAP_NEGATIVE_Z */

/////

// This demo asserts that batching + culling work

#include "demo_11.c"
#include "../sector.c"
#include "../batch.c"
#include "../camera.c"

StateGL demo_17_init(void) {
	StateGL sgl = {.vertex_array = init_vao()};



	/*
	const plane_type_t origin[3] = {1, 2, 2}, size[3] = {1, 2, 3};
	plane_type_t* const cuboid_mesh = create_sector_mesh(origin, size);

	sgl.num_vertex_buffers = 1;
	sgl.vertex_buffers = init_vbos(sgl.num_vertex_buffers, cuboid_mesh, bytes_per_mesh);
	bind_interleaved_planes_to_vao();

	free(cuboid_mesh);

	sgl.shader_program = init_shader_program(demo_4_vertex_shader, demo_4_fragment_shader);
	sgl.num_textures = 1;
	sgl.textures = init_textures(sgl.num_textures, "../../../assets/walls/pyramid_bricks_3.bmp", tex_repeating);
	select_texture_for_use(sgl.textures[0], sgl.shader_program);

	enable_all_culling();
	*/

	return sgl;
}

void demo_17_drawer(const StateGL* const sgl) {
	(void) sgl;
	static Camera camera;
	static Camera camera;
	static Batch batch;
	static GLint model_view_projection_id;
	static byte first_call = 1;

	/*
	static Camera camera;
	static Batch batch;
	static GLint model_view_projection_id;
	static byte first_call = 1;

	if (first_call) {
		init_camera(&camera, (vec3) {0.0f, 0.0f, 0.0f});
		model_view_projection_id = glGetUniformLocation(sgl -> shader_program, "model_view_projection");
		first_call = 0;
	}
	update_camera(&camera);
	glUniformMatrix4fv(model_view_projection_id, 1, GL_FALSE, &camera.model_view_projection[0][0]);

	glClearColor(0.2f, 0.4f, 0.6f, 0.0f);
	draw_triangles(triangles_per_mesh);
	*/
}

#ifdef DEMO_17
int main(void) {
	make_application(demo_17_drawer, demo_17_init, deinit_demo_vars);
}
#endif

/////

#include "../utils.c"
#include "../sector.c"
#include "../batch.c"
#include "../camera.c"

/*
typedef struct {
	GLsizei num_textures;
	GLuint vao, *const textures, shader;
	Batch batch;
} StateDemo17;

void demo_17_drawer(const StateDemo17* const s) {
	static byte first_call = 1;
	static Camera camera;

	if (first_call) {
		init_camera(&camera, (vec3) {0.0f, 0.0f, 0.0f});
		first_call = 0;
	}

	glClearColor(0.8f, 0.8f, 0.5f, 0.0f);

	(void) s;
}

StateDemo17 init_state_demo_17(void) {
	StateDemo17 s;

	glGenVertexArrays(1, &s.vao);
	glBindVertexArray(s.vao);

	return s;
}

void deinit_state_demo_17(const StateDemo17* const s) {
	glDeleteTextures(s -> num_textures, rs -> textures);
	deinit_batch(&s -> batch);
	glDeleteVertexArrays(1, &s -> vao);
}

// #ifdef DEMO_17
int main(void) {
	Screen screen = init_screen("Culling Demo");

	const int max_delay = 1000 / constants.fps;
	(void) max_delay;

	SDL_Event event;
	keys = SDL_GetKeyboardState(NULL);
	byte running = 1;

	StateDemo17 s = init_state_demo_17();

	while (running) {
		const Uint32 before = SDL_GetTicks();

		while (SDL_PollEvent(&event)) {
			if (event.type == SDL_QUIT) running = 0;
		}

		glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
		demo_17_drawer(&s);
		SDL_GL_SwapWindow(screen.window);
		const int wait = max_delay - (SDL_GetTicks() - before);
		if (wait > 0) SDL_Delay(wait);
	}

	deinit_state_demo_17(&s);
	deinit_screen(&screen);
}
// #endif
*/

/////

	/*
	sgl.num_vertex_buffers = sectors.length;
	sgl.vertex_buffers = malloc(sgl.num_vertex_buffers * sizeof(GLuint));
	glGenBuffers(sgl.num_vertex_buffers, sgl.vertex_buffers);
	*/

	/*
	sgl.num_vertex_buffers = 0;

	for (int i = 0; i < sector_list.length; i++) {
		Sector* const sector = sector_list.sectors + i;

		// glGenBuffers(1, &sector -> vbo);
		// sector -> vbo = sgl.vertex_buffers[i];
		const plane_type_t origin[3] = {area.origin[0], area.height, area.origin[1]};

		plane_type_t* mesh;
		byte mesh_bytes;

		if (area.height == 0) { // Flat sector
			mesh = create_height_zero_mesh(origin, area.size);
			mesh_bytes = bytes_per_height_zero_mesh;
		}
		else {
			const plane_type_t size[3] = {area.size[0], area.height, area.size[1]};
			mesh = create_sector_mesh(origin, size);
			mesh_bytes = bytes_per_mesh;
		}

		glBindBuffer(GL_ARRAY_BUFFER, sector -> vbo);
		glBufferData(GL_ARRAY_BUFFER, mesh_bytes, mesh, GL_STATIC_DRAW);

		// free(mesh);
	}
	*/

/////

// printf("%d, %d, %d\n", (intO 0.89f / 1 * 255, 0.854f / 1 * 255, 0.788f / 1 * 255);

/////
		/*
		"float depth = gl_FragCoord.z / gl_FragCoord.w;\n"
		"float l = 1.0f / gl_ClipDistance;\n"
		"light_intensity;\n"
		*/

/////

		/*
		if (height_diff != 0) {
			Face face;

			if (height_diff > 0) {
				printf("Sector is over other sector by %d\n", height_diff);
			}
			else if (height_diff < 0) {
				printf("Sector is under other sector by %d; no face column\n", -height_diff);
			}
		}
		last_height_diff = height_diff;
		*/

/////

/*
void generic_init_vert_ew_faces(const Sector sector, byte* const heightmap, const byte map_width,
	const byte map_height, const byte is_bottom_side) {

	const byte start_x = sector.origin[0];
	byte start_y = sector.origin[1];

	if (is_bottom_side) {
		start_y += sector.size[1] - 1;

		DEBUG(sector.origin[1], d);
		DEBUG(sector.size[1], d);
		DEBUG(start_y, d);
		if (start_y == map_height - 1) return;
	}
	else if (start_y == 0) return;

	//////////

	const byte adjacent_y = start_y + (is_bottom_side ? 1 : -1);
	byte face_skippable = 0;

	int16_t last_height_diff = 0;
	Face curr_face = {Vert_EW, {start_x, start_y}, {1, 0}};

	for (byte x = start_x; x < start_x + sector.size[0]; x++) {
		const byte height = *map_point(heightmap, x, adjacent_y, map_width);
		const int16_t height_diff = sector.height - height;

		const byte not_skippable_before = !face_skippable;
		face_skippable = height_diff <= 0;

		if (not_skippable_before && face_skippable) {
			puts("Continuity error");
		}

		if (!face_skippable) {
			if (height_diff == last_height_diff) curr_face.size[0]++;
			else {
				if (last_height_diff != 0) {
					print_face(curr_face, "Face: ");
					curr_face.origin[0] = x;
					curr_face.size[0] = 1;
				}
				curr_face.size[1] = height_diff;
			}
		}
		last_height_diff = height_diff;
	}
	if (!face_skippable) print_face(curr_face, "End face: ");
}
*/

// Assumes that the faces are vertical
/*
void init_vert_ew_faces(const Sector sector, byte* const heightmap, const byte map_width) {
	// == edge
	if (sector.origin[1] == 0) return;

	// Side decr
	const byte y_above = sector.origin[1] - 1;

	byte face_skippable = 1;

	int16_t last_height_diff = 0;
	Face curr_face = {Vert_EW, {sector.origin[0], sector.origin[1]}, {1, 0}};

	for (byte x = sector.origin[0]; x < sector.origin[0] + sector.size[0]; x++) {
		const byte height = *map_point(heightmap, x, y_above, map_width);
		const int16_t height_diff = sector.height - height;

		const byte had_face_before = !face_skippable;
		face_skippable = height_diff <= 0;

		if (face_skippable && had_face_before) {
			puts("Catch it");
			print_face(curr_face, "Face: ");
			curr_face.origin[0] = x;
			curr_face.size[0] = 1; // top-down x
		}

		else if (!face_skippable) {
			if (height_diff == last_height_diff) curr_face.size[0]++;
			else {
				if (last_height_diff != 0) { // Add face to list here
					print_face(curr_face, "Face: ");
					curr_face.origin[0] = x;
					curr_face.size[0] = 1; // top-down x
				}
				curr_face.size[1] = height_diff; // top-down y
			}
		}
		last_height_diff = height_diff;
	}

	if (!face_skippable) print_face(curr_face, "End face: ");
}
*/

/////

	/*
	if (!is_top) next_face.origin[1] += sector.size[1];

	byte adjacent_y = next_face.origin[1];

	DEBUG(is_top, d);

	if (is_top && adjacent_y-- == 0) return;
	else if (adjacent_y == map_height) {
		// DEBUG(is_top, d);
		return;
	}
	*/

/////

/*
void create_flat_mesh(const mesh_type_t origin[2], const mesh_type_t size[2], mesh_type_t* const dest) {
	(void) origin;
	(void) size;
	(void) dest;
}

void create_vert_ns_mesh(const mesh_type_t origin[2], const mesh_type_t size[2], mesh_type_t* const dest) {
	(void) origin;
	(void) size;
	(void) dest;
}

void create_vert_ew_mesh(const mesh_type_t origin[2], const mesh_type_t size[2], mesh_type_t* const dest) {
	(void) origin;
	(void) size;
	(void) dest;
}
*/

/////

				/*
				1, 2, 3, 4, 5,
				6, 7, 8, 9, 10,
				11, 12, 13, 14, 15,

				16, 17, 18, 19, 20,
				21, 22, 23, 24, 25,
				26, 27, 28, 29, 30
				*/

/////

			/*
			For flat, origin[0] = x, sector.height = y, origin[1] = z
			_______
			|     |
			|     |
			|_____|

			origin size[0] top down, and size[1] depth
			*/

/////

			/*
			For flat, origin[0] = x, sector.height = y, origin[1] = z
			_____
			|   |
			|___|
			*/


			/*
			Note: x across top-down is also x across in 3D
			origin
			|

			For vert ns,
				origin[0] = x,
				sector.height = top_y,
				sector.height - size[1] = bottom_y,
				origin[1] = near_z (which is top z),
				origin[1] - size[0] = far_z
			*/

			/*
			origin -

			For vert ew,
				origin[0] = near_x,
				sector.height = top_y,
				sector.height - size[1] = bottom_y
				origin[1] = near_x (which is left x),
				origin[1] - size[0] = far_x (which is right_x)
			*/

///// Some UV stuff:

			/*
				near_x, sector_height, far_z, 1, 0,
				far_x, sector_height, near_z, 0, 1,
				near_x, sector_height, near_z, 1, 1,

				near_x, sector_height, far_z, 1, 0,
				far_x, sector_height, far_z, 0, 0,
				far_x, sector_height, near_z, 0, 1
				*/

				/*
				near_x, sector_height, far_z, size_z, size_x,
				far_x, sector_height, near_z, 0, 0,
				near_x, sector_height, near_z, 0, size_x,

				near_x, sector_height, far_z, size_z, size_x,
				far_x, sector_height, far_z, size_z, 0,
				far_x, sector_height, near_z, 0, 0
				*/

/////

	/*
	Visible face sides:

	Bottom = invisible
	Top = visible
	Right = invisible
	Left = visible

	Find alternate face orientations, and switch between, or programatically swizzle vars in it

	With normal vert NS: bottom = invisible, and top UV is correct.
	With alternative vert NS: bottom = visible + correct UVs, and top is invisible.
	*/

///// Heightmap modification based on perlin noise from the main project:

	for (int y = 0; y < terrain_height - 1; y++) {
		printf("\t{");
		for (int x = 0; x < terrain_width - 1; x++) {

			byte* val = map_point((byte*) terrain_map, x, y, terrain_width);
			int smaller = *val - 40;
			if (smaller < 0) smaller = 0;

			int v = fabs(tan(*val / 16.0) / 3.0) * *val;
			if (v > 255) v = 255;
			*val = v;

			printf("%d%s", *val, (x == terrain_width - 2) ? "" : ", ");
		}
		puts("},");
	}

/////

	/*
	const GLsizeiptr total_index_bytes = num_faces * indices_per_face * sizeof(index_type_t);
	GLuint* const cpu_index_buffer = malloc(total_index_bytes);
	for (size_t i = 0; i < num_faces; i++) {
		const int s = i * 4;

		const GLuint index_set_1[6] =
			// {s, s + 1, s + 2, s + 1, s + 3, s + 2};
			{s, s + 1, s + 2, s, s + 3, s + 1};

		for (int j = 0; j < 6; j++) printf("%d ", index_set_1[j]);
		putchar('\n');
	
		memcpy(cpu_index_buffer + i * 6, index_set_1, sizeof(index_set_1));
	}

	glGenBuffers(1, &sector_list -> ibo);
	glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, sector_list -> ibo);
	glBufferData(GL_ELEMENT_ARRAY_BUFFER, total_index_bytes, cpu_index_buffer, GL_STATIC_DRAW);

	free(cpu_index_buffer);
	*/

	/*
	const GLuint num_indices = 6 * face_mesh_list.length;
	// DEBUG(face_mesh_list.length, d);
	for (int i = 0; i < 3; i++) {
		GLuint index_set_1[6] = {i, i + 1, i + 2, i, i + 3, i + 1};

		for (int i = 0; i < 6; i++) {
			printf("%d ", index_set_1[i]);
		}
		putchar('\n');
	}
	*/

/////

	/*
	for (int i = 0; i < 6; i++) printf("%d, ", index_set[i]);
	putchar('\n');
	*/

	/*
	TODO: add to index list here

	const GLuint index_set_1[6] =
		// {s, s + 1, s + 2, s + 1, s + 3, s + 2};
		{s, s + 1, s + 2, s, s + 3, s + 1};

	flat || vert ns first || vert ew second -> 0, 1, 2, 0, 3, 1
	vert ns second || vert ew first -> 0, 1, 2, 1, 3, 2

	- If second variant, add 1 to entry[3] and entry[5]
	- How to find start of ibo indices here?
	*/

/////

	/*
	ibo entries:
		flat:
			0, 1, 2, 0, 3, 1
		vert ns, first side:
			0, 1, 2, 0, 3, 1
		vert ns, second side:
			0, 1, 2, 1, 3, 2
		vert ew, first side:
			0, 1, 2, 1, 3, 2
		vert ew, second side:
			0, 1, 2, 0, 3, 1
	*/

/////


	/*
	DEBUG(total_index_bytes, zu);
	DEBUG(index_list -> length, zu);
	DEBUG(index_list -> length * sizeof(index_type_t[indices_per_face]), zu);
	DEBUG(index_list -> max_alloc * index_list -> item_size, zu);

	puts("Looking in index list");

	index_type_t* data = index_list -> data;
	const GLsizeiptr num_elems = index_list -> length * indices_per_face;
	for (GLsizeiptr i = 0; i < num_elems; i++) {
		printf("i = %td, and other = %d\n", i, data[i]);
	}
	// exit(0);
	*/

///// An attempt at chunk copying of unculled sectors:

	/*
	size_t sector_index = 0, base_index = 0;

	while (sector_index < sectors.length) {
		const Sector* sector = ((Sector*) sectors.data) + sector_index;

		index_type_t start_ibo_index = sector -> ibo_range.start, range_ibo_index = 0;

		while (sector_index < sectors.length && sector_in_view_frustum(*sector, frustum_planes)) {
			range_ibo_index += sector -> ibo_range.length;
			base_index += sector -> ibo_range.length;

			sector_index++;
			sector++;
		}

		printf("%d -> %d\n", start_ibo_index, range_ibo_index);
		DEBUG(base_index, d);

		if (range_ibo_index != 0) {
			memcpy(ibo_ptr + base_index, indices + start_ibo_index,
				range_ibo_index * sizeof(index_type_t));
		}
		else sector_index++;
	}
	*/

///// Non-chunked copying:

		/*
		const Sector sector = ((Sector*) sectors.data)[i];
		if (sector_in_view_frustum(sector, frustum_planes)) {
			// printf("see from %d -> %d\n", sector.ibo_range.start, sector.ibo_range.length);
			secs++;

			memcpy(ibo_ptr + num_visible_indices, indices + sector.ibo_range.start,
				sector.ibo_range.length * sizeof(index_type_t));

			num_visible_indices += sector.ibo_range.length;
		}
		*/

///// Ptr increment copying - a bit too messy:

	const Sector* sector = (Sector*) sectors.data;
	const Sector* const final_sector = sector + sectors.length - 1;

	while (sector != final_sector) {
		index_type_t num_indices = 0;
		const index_type_t start_index_index = sector -> ibo_range.start;

		/*
		while (sector != final_sector && sector_in_view_frustum(*sector, frustum_planes)) {
			num_indices += sector++ -> ibo_range.length;
		}
		*/

		while (sector_in_view_frustum(*sector, frustum_planes)) {
			num_indices += sector -> ibo_range.length;
			if (++sector == final_sector) goto bob;
		}


		if (num_indices != 0) {
			memcpy(ibo_ptr + num_visible_indices, indices + start_index_index, num_indices * sizeof(index_type_t));
			num_visible_indices += num_indices;
		}

///// UV shit:

		// "if (face_info_bits == 5u) UV = vec2(0.0f);\n"
		// 4u -> nothing
		// 3u -> nothing
		// 2u -> bottom
		// 6u -> top
		// 1u -> right
		// 5u -> left
		// 0u -> flat

		/* no 5u:
		left rev, right good, top good, bottom rev
		5u:
		left good, right good, top good, bottom rev
		6u:
		// left rev, right _, top _, bottom _
		*/

		"if (face_info_bits == 5u || face_info_bits == 2u) {UV.x = 1.0f - UV.x;}\n"

		// top good, bottom bad, right good, left bad - with no side logic
		// `side` indicates top or left. current bad UVs: bottom and left.
		// num for left: Vert_EW and side = 0b110 = 6. num for bottom: Vert_NS and !side = 0b001 = 1.
		// Vert_NS == 1, and Vert_EW == 2.

		// "bool side = bool(face_info_bits & 4u);\n" // side = left or top

		// "if (side && ) UV = vec2(0.0f);\n"

		// "if (side || (!side && face_type == )) {\n"
			// "UV.x = 1.0f - UV.x;\n"
			// "UV = vec2(0, 0);\n"
		// "}\n"

		// "UV = rev_pos.xz;\n" // Bueno for flat face ([0], [2])
		// "UV = rev_pos.zy;\n" // Bueno for right vert NS face ([2], [1])
		// "UV = vec2(1.0f - rev_pos.z, rev_pos.y);\n"// Bueno for left vert NS face (1 - [2], [1])
		// "UV = rev_pos.xy;\n" // Bueno for top vert EW face ([0] [1])
		// "UV = vec2(1.0f - pos_reversed.x, pos_reversed.y);\n" // Bueno for bottom vert EW face (1 - [0], [1])

		// "UV = vec2(pos_reversed.x, pos_reversed.y);\n" // Bueno for bottom vert EW face (1 - [0], [1])
		// "UV.x = 1.0f - UV.x;\n"

/////

- Sectors contain their meshes
- To begin with, don't clip sector heights based on adjacent heights
- Sectors are rectangular

- Not perfect, but sectors + their meshes for clipping and rendering, and texmaps + heightmaps for game logic
- Ideal: BSPs, but not worth time
- To start, one vbo + texture ptr per sector

/////

	/*
	if (sector.height == 4)

	printf("bottom_left = {%d, %d, %d}, top_right = {%d, %d, %d}\n",
		(int) aabb_corners[0][0],
		(int) aabb_corners[0][1],
		(int) aabb_corners[0][2],
		(int) aabb_corners[1][0],
		(int) aabb_corners[1][1],
		(int) aabb_corners[1][2]
	);
	*/

///// A shared-vertex cube didn't work

	const GLbyte
		near_x = origin[0], bottom_y = origin[1], near_z = origin[2],
		size_x = size[0], size_y = size[1], size_z = size[2];

	const GLbyte far_x = near_x + size_x, top_y = bottom_y + size_y, far_z = near_z + size_z;

	// First face first

	const GLbyte vertices[members] = {
		near_x, bottom_y, near_z, // right of front face
		far_x, bottom_y, near_z,
		near_x, top_y, near_z,

		far_x, bottom_y, far_z,

		/*
		near_x, bottom_y, near_z, // Front face
		far_x, bottom_y, near_z,
		near_x, top_y, near_z,
		far_x, top_y, near_z,

		near_x, top_y, far_z, // Top face
		far_x, top_y, far_z,

		near_x, bottom_y, far_z, // Back face
		far_x, bottom_y, far_z,

		near_x, bottom_y, near_z, // Bottom face
		far_x, bottom_y, near_z,

		far_x, top_y, far_z,
		*/
	};

/////

	GLbyte* const cuboid = malloc(members * sizeof(GLbyte));

	const GLbyte top_x = top[0], top_y = top[1], top_z = top[2];
	const GLbyte bottom_x = top_x - size, bottom_y = top_y - size, bottom_z = top_z - size;

	const GLbyte vertices[members] = {
		0, 0, 0,
		1,1,1, -1,1,-1, 1,-1,-1,  -1,-1,1

		/*
		top_x, top_y, top_z,

		top_x, bottom_y, bottom_z,
		bottom_x, top_y, bottom_z,
		bottom_x, bottom_y, top_z
		*/
	};

/////

	DEBUG(sizeof(Sector), zu);
	DEBUG(sizeof(index_type_t), zu);

	DEBUG(sizeof(byte[2]) + sizeof(byte[2]) + sizeof(byte) + sizeof(byte) + 4 + 4, zu);

/////

	/*
	static float s = 0.0f;
	s += 0.05f;
	if (s > (float) M_PI * 2.0f) s = 0.0f;

	Event e = {
		.movement_bits = 0,
		cosf(s) * 50, sinf(s) * 30
	};
	*/

///// Even terrain generation for a heightmap:

	/*
	for (byte y = 0; y < terrain_height; y++) {
		for (byte x = 0; x < terrain_width; x++) {
			// *map_point((byte*) terrain_heightmap, x, y, terrain_width) = fabsf((cosf(x / 5.0f) + sinf(y / 5.0f))) * 5.0f;
			*map_point((byte*) terrain_heightmap, x, y, terrain_width) *= ((x + y) >> 1) / 50.0f;
		}
	}
	*/


/////


	/*
	const size_t billboard_bytes = num_billboards * sizeof(Billboard);
	Billboard* const cpu_billboard_data = malloc(billboard_bytes);

	va_list args;
	va_start(args, num_billboards);
	for (size_t i = 0; i < num_billboards; i++) cpu_billboard_data[i] = va_arg(args, Billboard);
	va_end(args);

	///////////

	glGenBuffers(1, &billboard_list.dbo);
	glBindBuffer(GL_UNIFORM_BUFFER, billboard_list.dbo);
	glBufferData(GL_UNIFORM_BUFFER, billboard_bytes, cpu_billboard_data, GL_STATIC_DRAW);
	free(cpu_billboard_data);

	const GLuint block_index = glGetUniformBlockIndex(billboard_list.shader, "BillboardInfo");
	glBindBufferBase(GL_UNIFORM_BUFFER, 0, billboard_list.dbo);

	GL_ERR_CHECK;

	return billboard_list;
	*/

/////

*const batched_billboard_vertex_shader =
	"#version 330 core\n"

	// Share every 4

	"uniform in BillboardInfo {\n"
		"vec3 pos;\n"
		"int texture_id;\n"
	"} bb_info;\n"

	"out vec2 UV;\n"

	"const vec2 vertices_model_space[4] = vec2[4](\n"
		"vec2(-0.5f, -0.5f), vec2(0.5f, -0.5f),\n"
		"vec2(-0.5f, 0.5f), vec2(0.5f, 0.5f)\n"
	");\n"

	"const vec3 cam_up_world_space = vec3(0.0f, 1.0f, 0.0f);\n"

	"void main() {\n"
		"UV = vec2(0.0f, 0.0f);\n"
	"}\n",

/////

// "struct Billboard {uint texture_id; vec2 billboard_size_world_space; vec3 billboard_center_world_space;};\n"

/////

glClearColor(0.89f, 0.355f, 0.288f, 0.0f); // Light tomato

/////
	
"if (bool(equaling_check)) side = int((face_info & 4) == 0); else side = (face_info & 251) << 2;\n // side = face_info & 251;\n"

/////


		/*
		(face_info & 4 == 0)
		4 = 0b100 = 3rd bit set
		bool side = (3rd bit not set)
		251 = 0b11111011 = 3rd bit not set

		get something where the result is 1 if 3rd bit zero
		*/

		// Top = 1.0f, top or left = 0.8f, bottom or right = 0.6f. `& 4` gets 3rd bit.
		// "bool side = (face_info & 4) == 0, flat_face = first_three_bits == 0;\n" // `side` means flat, top or left

		// For 251, all bits are set except for the third one. If the 3rd bit is 0 in `face_info`, `side` will be 
		// "int side = face_info & 251, flat_face = int(first_three_bits == 0);\n"

		// "int side = face_info & 251;\n"
		// "int side = int((face_info & 4) == 0);\n"

		// Do based on camera facing

		/*
		Need fn that gives 1 if 3rd bit is 0, and 0 if 3rd bit is 1

		Fn for 1 if 3rd bit is 1, and 0 if 3rd bit is 0: (first_three_bits >> 2)

		xor: if only 1 input is true
		*/

/////

	// glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
	// glBlendFunc(GL_SRC_ALPHA, GL_SRC_ALPHA);
	// glBlendFunc(GL_ONE, GL_SRC_ALPHA);
	// glBlendFunc(GL_ONE_MINUS_SRC_ALPHA, GL_ONE);
	glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
	// glBlendFunc(GL_SRC_ALPHA, GL_ONE);
	// Take only color of closest object

/////

// glClearColor(0.29f, 0.555f, 0.588f, 0.0f); // Boring blue

/////

	if (window_resized) {
		int w, h;

		// if ()
	}

	/*
	static int last_w = 0, last_h = 0;
	if (last_w == 0 && last_h == 0) {
		*/

		// puts("here");
		/*
		static SDL_DisplayMode display_mode;
		SDL_GetDesktopDisplayMode(0, &display_mode);
		last_w = display_mode.w;
		last_h = display_mode.h;
		*/

	/*
	static struct {int w, h;} last_win_size = {0, 0};
	if (last_win_size.w == 0 && last_win_size.h == 0) {

	}
	*/

/////

/*
static enum {
	FullScreen, Windowed, TransitionBetween
} window_state = Windowed;
byte holding_key = 0;
*/

/////

static void clear_alpha_for_surface(SDL_Surface* const surface) {
	return;

	/*
	const int w = surface -> w, h = surface -> h;
	const int num_pixels = w * h;

	SDL_SetColorKey(surface, SDL_TRUE, 255);
	// const Uint32 red = SDL_MapRGBA(surface -> format, 255, 0, 0, 255);
	Uint32* const pixels = surface -> pixels;

	for (int i = 0; i < num_pixels; i++) {
		// pixels[i] = red;
		Uint32* const pixel_ref = pixels + i;
		const Uint32 pixel = *pixel_ref;

		if (pixel == 0) {
			// *pixel_ref = SDL_MapRGBA(surface -> format, 255, 255, 255, 255);
			*pixel_ref = 20;
		}
	}


	SDL_SaveBMP(surface, "color.bmp");
	*/
}

/////

	/*
	float magnitude = sqrt(camera -> dir[0] * camera -> dir[0] + camera -> dir[1] * camera -> dir[1] + camera -> dir[2] * camera -> dir[2]);
	DEBUG(magnitude, lf);
	*/

/////

		bad:
		flat = 0
		vert ns, !side (bottom) = 1
		vert ns, side (top) = 5
		vert ew, !side (right) = 2
		vert ew, side (left) = 6

/////

			/*
			"case 1: return vec3(0.0f, 0.0f, 1.0f);\n"
			"case 5: return vec3(0.0f, 0.0f, -1.0f);\n"
			"case 2: return vec3(1.0f, 0.0f, 0.0f);\n"
			"case 6: return vec3(-1.0f, 0.0f, 0.0f);\n"
			"default: return vec3(0.0f, 0.0f, 0.0f);\n"
			*/

/////


	/*
	const byte face_combos[5] = {
		Flat,
		(0 << 2) | Vert_NS,
		(1 << 2) | Vert_NS,
		(0 << 2) | Vert_EW,
		(1 << 2) | Vert_EW
	};

	for (byte i = 0; i < 5; i++) {
		printf("%d ", face_combos[i]);
	}
	putchar('\n');
	*/

/////

	/*
	DEBUG(face_info & 7, d);
	DEBUG((side << 2) | face.type, d);
	puts("-");
	*/

/////

		/*
		good:
		flat = 0
		vert ns, !side (right) = 1
		vert ns, side (left) = 5
		vert ew, !side (bottom) = 2
		vert ew, side (top) = 6

		Side = top or left side
		going down on 2D map increases Z, and going to the right increases X
		*/

///// The old face color determination from the face side and type, and if it's flat:

	// `(x & 4) == 0` checks if the 3rd bit in `x` is set // 4 = 0b100, so if 3rd bit is cleared, face side is flat, top or left.
	// "light = darkest_light + (int((face_info & 4) == 0) + int(first_three_bits == 0)) * light_step;\n"

/////

byte normal_hasher(const byte face_info) {
	// return ceilf(face_info * 0.5f);
	// return face_info * ~face_info;
	/*
	const byte first_three_mask = 7; // 0b111
	return ~face_info & first_three_mask;
	*/

	// if (face_info >= 5) face_info -= 2;
	return face_info - ((face_info >= 5) << 1);
}

/////

	static byte first_call = 1;

	if (first_call) {
		DEBUG(normal_hasher(0), d);
		DEBUG(normal_hasher(1), d);
		DEBUG(normal_hasher(2), d);
		DEBUG(normal_hasher(5), d);
		DEBUG(normal_hasher(6), d);
		first_call = 0;
	}

/////

"return bool(branchy_normal) ? get_normal(face_id_bits) : face_normals[normal_id];\n"

/////

	/*
	Mapping first 3 bits to face normal:

	flat, 0, 0b000: [1] = 1
	right, 1, 0b001: [0] = 1
	left, 5, 0b101: [0] = -1
	bottom, 2, 0b010: [2] = 1
	top, 6, 0b110: [2] = -1
	
	ordered in bit size:
		flat, 0, 0b000: [1] = 1
		right, 1, 0b001: [0] = 1
		bottom, 2, 0b010: [2] = 1
		left, 5, 0b101: [0] = -1
		top, 6, 0b110: [2] = -1

	If 5 or 6, negative mask
	- Find similarities betwen bit patterns and bits set
	- Zeroth bit set:
		Set 0th component to 1 if (last bit == 0), else -1
	- No bits set:
	*/

	"vec3 get_normal(int first_three_bits) {\n"
		"switch (first_three_bits) {\n"
			"case 0: return vec3(0.0f, 1.0f, 0.0f);\n"
			"case 1: return vec3(1.0f, 0.0f, 0.0f);\n"
			"case 2: return vec3(0.0f, 0.0f, 1.0f);\n"
			"case 5: return vec3(-1.0f, 0.0f, 0.0f);\n"
			"case 6: return vec3(0.0f, 0.0f, -1.0f);\n"
			"default: return vec3(0.0f, 0.0f, 0.0f);\n"
		"}\n"
	"}\n"

/////

	"#define darkest_light 0.6f\n"
	"#define light_step 0.2f\n" // From the darkest side, this is the step amount

/////

		// vertex = center + (right.xyz * pos.x * size.x + up.xyz * pos.y * size.y)
		// a = pos * size
		// b = 

		// a.x * b.x + a.y * b.y
		// c = a * b = {a.x * b.x, a.y * b.y}
		// d = c[0] * right + c[1] * size

		/*
		"vec3 bob[2] = vec3[2](vec3(1, 2, 3), vec3(4, 5, 6));\n"
		"vec3 foo[2] = bob;\n"
		"foo *= bob;\n"
		*/

		"vec2 corner_world_space = vertex_model_space * billboard_size_world_space;\n" // In world space
		"vec3 world_space_offset = corner_world_space.x * vec3(right_xz_world_space, 0.0f).xzy + corner_world_space.y * up_world_space;\n"
		"vec3 vertex_world_space = world_space_offset + billboard_center_world_space;\n"
		/*
		"vec3 vertex_world_space = billboard_center_world_space\n"
			"+ vec3(cam_right_xz_world_space, 0.0f).xzy * vertex_model_space.x * billboard_size_world_space.x\n"
			"+ cam_up_world_space * vertex_model_space.y * billboard_size_world_space.y;\n"
		*/

/////

/*
Show this on the info bar:
- Map name (store in EditorState, or in some Map struct)
- Editing height
- Editing texture id
- Editing mode (texture or height)
- Idle, draw, or erase
- The current tile pos index (maybe)

- Map size, keybindings, and corresponding texture ids in map file

- And some background texture
- Keep track of state through a LastEditorState struct
*/

/////

	// const char* const format_without_chars = " |  |,  | |";

	/*
	static char dest[50];
	dest[49] = '\0';

	const char* const format = "%s | %d, %d | %s %d | %s"
	sprintf(dest, format,
		map_name, )
	*/

/////

	// %d, %d -> 255 lim each
	// const char* const info_bar_format = "%s | %.3d, %.3d | %.6s %.3d | %.5s";

	/*
	printf("'%s | %d, %d | %s %d | %s'\n",
		map_name,
		12, 9,
		"height", 25,
		"e");
	*/

	/*
	size_t needed = snprintf(NULL, 0, "%s: %s (%d)", msg, strerror(errno), errno) + 1;
    char  *buffer = malloc(needed);
    sprintf(buffer, "%s: %s (%d)", msg, strerror(errno), errno);
    return buffer;
	*/

/////

- Some background texture
- Keep track of state through a LastEditorState struct, to determine if need to change ui

Format of info bar: name | tile pos | editing mode + editing val | idle, draw, or erase

Examples:
palace | pos 3, 15 | height 8 | idle
fleckenstein | 4, 20 | tex 19 | erase

- name = constant throughout
- tile pos = max 6 chars
- edit mode = max 5 chars
- edit mode val = max 3 chars
- edit state = max 5 chars

/////

byte get_padding_for_six_digits(int16_t n1, int16_t n2) {
	byte digits_set = 2;

	while (n1 /= 10) digits_set++;
	while (n2 /= 10) digits_set++;

	return digits_set;
}

/////

	"float attenuation(vec3 pos_delta) {\n"
		// 1.0/(c1 + c2*d + c3*d^2)

		"float dist_squared = dot(pos_delta, pos_delta);\n"

		"float c1 = 1.0f, c2 = 0.2f, c3 = 0.3f;\n"

		"return 1.0f / (c1 + c2 * sqrt(dist_squared) + c3 * dist_squared);\n"
	"}\n"

	"void main() {\n"
		"vec3 pos_delta = light_pos_world_space - fragment_pos_world_space;\n"
		"float light = /* diffuse(pos_delta) + */ attenuation(pos_delta);\n"
		"face_normal;\n"

		// "light *= 10.0f / length(pos_delta);\n"

		"color = texture(texture_sampler, UV).rgb * light;\n"

/////

		// "return 1.0f / (d2 * 0.1f);"

		// 1.0 / (1.0 + a*dist + b*dist*dist))
		/*
		"float a = 0.3f, b = 0.6f;\n"
		"float atten = 1.0f / (1.0f + a * sqrt(frag_dist_squared) + b * frag_dist_squared);\n"
		*/

		/*
		"float frag_dist_squared = dot(pos_delta_world_space, pos_delta_world_space);\n"
		"float a = 0.3f, b = 0.6f;\n"
		"float atten = 1.0f / (1.0f + a * sqrt(frag_dist_squared) + b * frag_dist_squared);\n"
		*/

		// "float atten = 1.0f / (sqrt(frag_dist_squared));\n"

		/*
		"float radius = 4;\n"
		"float frag_dist_squared = dot(pos_delta_world_space, pos_delta_world_space);\n"
		"float atten = clamp(1.0 -frag_dist_squared/(radius*radius), 0.2, 1.0);\n"
		"return atten;\n"
		*/

/////

- Figure out if diffuse should depend on where player is - or ambient occlusion + simple dynamic lights

///// So much code:

	// Since TexNonrepeating is necessary for billboards, billboards and walls will have to be stored in different places

	billboard_list.texture_set = init_multi_textures(2, 2, 64, 64,
		"../../../../assets/walls/cross_blue.bmp",
		"../../../../assets/walls/desert_snake.bmp",

		"../../../../assets/spritesheets/flying_carpet.bmp", 5, 10, 46,
		"../../../../assets/spritesheets/flying_carpet.bmp", 5, 10, 3
		);

	/*
	billboard_list.texture_set = init_multi_textures(4, 64, 64,
		"../../../../assets/spritesheets/flying_carpet.bmp", 1, 5, 10, 46,
		"../../../../assets/walls/cross_blue.bmp", 0,
		"../../../../assets/walls/desert_snake.bmp", 0,
		"../../../../assets/spritesheets/torch_2.bmp", 1, 2, 3, 5
	);


static GLsizei get_num_subtextures_for_multi_texture(va_list args,
	const GLsizei num_plain_subtextures, const GLsizei num_animated_subtextures) {

	GLsizei total_num_subtextures = num_plain_subtextures;

	va_list args_copy;
	va_copy(args_copy, args);
	for (GLsizei i = 0; i < num_plain_subtextures; i++, va_arg(args_copy, char*));

	// From here, can get 
	for (GLsizei i = 0; i < num_animated_subtextures; i++) {
		va_arg(args_copy, char*); // Discard path, frames across, frames down
		va_arg(args_copy, GLsizei);
		va_arg(args_copy, GLsizei);
		total_num_subtextures += va_arg(args_copy, GLsizei); // Adding arg total_frames
	}

	if (total_num_subtextures > GL_MAX_ARRAY_TEXTURE_LAYERS)
		fail("put textures in a texture set because it exceeds the max array texture layers",
			TextureSetIsTooLarge);

	va_end(args_copy);

	return total_num_subtextures;
}

// Path. If animated: frames across, frames down, total_frames
GLuint init_multi_textures(const GLsizei num_plain_subtextures,
	const GLsizei num_animated_sutextures, const GLsizei rescale_w, const GLsizei rescale_h, ...) {

	va_list args;
	va_start(args, rescale_h);

	const GLuint total_num_subtextures = get_num_subtextures_for_multi_texture(args, num_plain_subtextures, num_animated_sutextures);
	DEBUG(total_num_subtextures, d);

	const GLuint texture = preinit_texture(TexSet, TexRepeating);

	glTexImage3D(TexSet, 0, OPENGL_INTERNAL_PIXEL_FORMAT,
		rescale_w, rescale_h, num_subtextures_in_set, 0,
		OPENGL_INPUT_PIXEL_FORMAT, OPENGL_COLOR_CHANNEL_TYPE, NULL);


	va_end(args);

	//////////

	/*
	va_list args;
	va_start(args, rescale_h);

	const GLsizei num_subtextures_in_set = get_num_subtextures_for_multi_texture(args, num_multi_textures);
	const GLuint texture = preinit_texture(TexSet, TexNonRepeating);

	glTexImage3D(TexSet, 0, OPENGL_INTERNAL_PIXEL_FORMAT,
		rescale_w, rescale_h, num_subtextures_in_set, 0,
		OPENGL_INPUT_PIXEL_FORMAT, OPENGL_COLOR_CHANNEL_TYPE, NULL);

	SDL_Surface* const rescaled_surface = init_blank_surface(rescale_w, rescale_h);
	// If blending enabled, consecutive blits to `frame_surface` will mix with previous blits if alpha channel used
	SDL_SetSurfaceBlendMode(rescaled_surface, SDL_BLENDMODE_NONE);

	for (GLsizei frame_index = 0; frame_index < num_subtextures_in_set;) {
		SDL_Surface* const surface = init_surface(va_arg(args, char*));
		const byte is_animated = va_arg(args, unsigned);

		// This is a lot of code, but bear through it

		if (is_animated) { // TODO: animation part of init_multi_textures
			const GLsizei
				frames_across = va_arg(args, GLsizei),
				frames_down = va_arg(args, GLsizei),
				total_frames = va_arg(args, GLsizei);

			init_animation_from_surface(surface, rescaled_surface,
				frames_across, frames_down, frame_index, frame_index + total_frames);

			frame_index += total_frames;
		}
		else {
			SDL_Surface* cpu_src;

			if (surface -> w != rescale_w || surface -> h != rescale_h) {
				SDL_SoftStretchLinear(surface, NULL, rescaled_surface, NULL);
				cpu_src = rescaled_surface;
			}
			else cpu_src = surface;

			SDL_LockSurface(cpu_src);

			glTexSubImage3D(TexSet, 0, 0, 0, frame_index,
				rescale_w, rescale_h, 1, OPENGL_INPUT_PIXEL_FORMAT,
				OPENGL_COLOR_CHANNEL_TYPE, cpu_src -> pixels);
			
			SDL_UnlockSurface(cpu_src);

			frame_index++;
		}

		deinit_surface(surface);
	}

	glGenerateMipmap(TexSet);
	deinit_surface(rescaled_surface);
	va_end(args);

	return texture;
	*/
}

// TODO: inline
static void init_animation_from_surface(SDL_Surface* const spritesheet_surface, SDL_Surface* const rescaled_surface,
	const GLsizei frames_across, const GLsizei frames_down, const GLsizei start_index, const GLsizei end_index) {

	SDL_Rect spritesheet_copy_area = {.w = spritesheet_surface -> w / frames_across, .h = spritesheet_surface -> h / frames_down};

	for (GLsizei frame_index = start_index; frame_index < end_index; frame_index++) {
		const GLsizei spritesheet_frame_index = frame_index - start_index;
		// Frame index x = frame_index % frames_across, and y = frame_index / frames_across
		spritesheet_copy_area.x = (spritesheet_frame_index % frames_across) * spritesheet_copy_area.w;
		spritesheet_copy_area.y = (spritesheet_frame_index / frames_across) * spritesheet_copy_area.h;

		// Copying to rescaled surface, b/c that's the only good copying way
		SDL_SoftStretchLinear(spritesheet_surface, &spritesheet_copy_area, rescaled_surface, NULL);

		SDL_LockSurface(rescaled_surface); // For pixel access

		glTexSubImage3D(TexSet, 0, 0, 0, frame_index,
			spritesheet_copy_area.w, spritesheet_copy_area.h,
			1, OPENGL_INPUT_PIXEL_FORMAT, OPENGL_COLOR_CHANNEL_TYPE, rescaled_surface -> pixels);

		SDL_UnlockSurface(rescaled_surface);
	}
}

/////


// TODO: remove
GLuint init_animation(const char* const path, const GLsizei frames_across,
	const GLsizei frames_down, const GLsizei total_frames) {

	SDL_Surface* const spritesheet_surface = init_surface(path);
	SDL_SetSurfaceBlendMode(spritesheet_surface, SDL_BLENDMODE_NONE); // If blending, future blits will mix w prev ones

	SDL_Rect spritesheet_copy_area = {.w = spritesheet_surface -> w / frames_across, .h = spritesheet_surface -> h / frames_down};
	SDL_Rect frame_copy_area = {.x = 0, .y = 0, .w = spritesheet_copy_area.w, .h = spritesheet_copy_area.h};

	/* Needed b/c glTexSubImage3D can't copy pixels from the main surface; otherwise, layout
	of pixels in `spritesheet_surface` will result in other frames being partially copied */
	SDL_Surface* const frame_surface = init_blank_surface(spritesheet_copy_area.w, spritesheet_copy_area.h);
	Uint32* const frame_pixels = frame_surface -> pixels;

	const GLuint texture = preinit_texture(TexSet, TexNonRepeating);

	glTexImage3D(TexSet, 0, OPENGL_INTERNAL_PIXEL_FORMAT,
		spritesheet_copy_area.w, spritesheet_copy_area.h, total_frames,
		0, OPENGL_INPUT_PIXEL_FORMAT, OPENGL_COLOR_CHANNEL_TYPE, NULL);

	for (GLsizei frame_index = 0; frame_index < total_frames; frame_index++) {
		// Frame index x = frame_index % frames_across, and y = frame_index / frames_across
		spritesheet_copy_area.x = (frame_index % frames_across) * spritesheet_copy_area.w;
		spritesheet_copy_area.y = (frame_index / frames_across) * spritesheet_copy_area.h;

		SDL_LowerBlit(spritesheet_surface, &spritesheet_copy_area, frame_surface, &frame_copy_area);

		SDL_LockSurface(frame_surface);

		glTexSubImage3D(TexSet, 0, 0, 0, frame_index,
			spritesheet_copy_area.w, spritesheet_copy_area.h,
			1, OPENGL_INPUT_PIXEL_FORMAT, OPENGL_COLOR_CHANNEL_TYPE, frame_pixels);

		SDL_UnlockSurface(frame_surface);
	}

	deinit_surface(frame_surface);
	deinit_surface(spritesheet_surface);
	glGenerateMipmap(TexSet);
	return texture;
}

/////


/* Path, frames across, frames down, total_frames. Animations are not stored in the same
texture set as wall textures because wall textures need UV wrapping, but that's not the case for animations. TODO: remove. */
GLuint init_animation_set(const GLsizei num_animations, const GLsizei rescale_w, const GLsizei rescale_h, ...) {
	va_list args, args_copy;
	va_start(args, rescale_h);
	va_copy(args_copy, args);

	////////// This part computes how many frames will be needed in the animation set

	GLsizei num_animation_frames = 0;
	for (GLsizei i = 0; i < num_animations; i++) {
		va_arg(args_copy, char*); // Discarding path, frames across, and frames down args
		va_arg(args_copy, GLsizei);
		va_arg(args_copy, GLsizei);
		num_animation_frames += va_arg(args_copy, GLsizei); // Adding total_frames
	}

	////////// This part loads the frames of each animation into an OpenGL texture

	SDL_Surface* const rescaling_surface = init_blank_surface(rescale_w, rescale_h);
	Uint32* const rescaling_surface_pixels = rescaling_surface -> pixels;
	const GLuint texture = preinit_texture(TexSet, TexNonRepeating);

	glTexImage3D(TexSet, 0, OPENGL_INTERNAL_PIXEL_FORMAT,
		rescale_w, rescale_h, num_animation_frames,
		0, OPENGL_INPUT_PIXEL_FORMAT, OPENGL_COLOR_CHANNEL_TYPE, NULL);

	for (GLsizei set_frame_index = 0; set_frame_index < num_animation_frames;) {
		SDL_Surface* const spritesheet_surface = init_surface(va_arg(args, char*));
		SDL_SetSurfaceBlendMode(spritesheet_surface, SDL_BLENDMODE_NONE);

		const GLsizei
			frames_across = va_arg(args, GLsizei),
			frames_down = va_arg(args, GLsizei),
			total_frames = va_arg(args, GLsizei);

		SDL_Rect spritesheet_frame_area = {
			.w = spritesheet_surface -> w / frames_across,
			.h = spritesheet_surface -> h / frames_down
		};

		for (GLsizei frame_index = 0; frame_index < total_frames; frame_index++, set_frame_index++) {
			spritesheet_frame_area.x = (frame_index % frames_across) * spritesheet_frame_area.w;
			spritesheet_frame_area.y = (frame_index / frames_across) * spritesheet_frame_area.h;

			SDL_BlitScaled(spritesheet_surface, &spritesheet_frame_area, rescaling_surface, NULL);
			SDL_LockSurface(rescaling_surface); // For pixel access

			glTexSubImage3D(TexSet, 0, 0, 0, set_frame_index,
				rescale_w, rescale_h, 1, OPENGL_INPUT_PIXEL_FORMAT,
				OPENGL_COLOR_CHANNEL_TYPE, rescaling_surface_pixels);

			SDL_UnlockSurface(rescaling_surface);
		}
		deinit_surface(spritesheet_surface);
	}

	glGenerateMipmap(TexSet);
	deinit_surface(rescaling_surface);
	va_end(args);

	return texture;
}

/////


/*
// Param: Texture path. TODO: remove this fn
GLuint init_texture_set(const TextureWrapMode wrap_mode,
	const GLsizei subtex_width, const GLsizei subtex_height, const GLsizei num_textures, ...) {

	const GLuint ts = preinit_texture(TexSet, wrap_mode);

	glTexImage3D(TexSet, 0, OPENGL_INTERNAL_PIXEL_FORMAT,
		subtex_width, subtex_height, num_textures,
		0, OPENGL_INPUT_PIXEL_FORMAT, OPENGL_COLOR_CHANNEL_TYPE, NULL);
	
	SDL_Surface* const rescaled_surface = init_blank_surface(subtex_width, subtex_height);

	va_list args;
	va_start(args, num_textures);
	for (GLsizei i = 0; i < num_textures; i++) {
		const char* const path = va_arg(args, char*);
		SDL_Surface* const surface = init_surface(path);
		SDL_Surface* src_surface;

		if (surface -> w != subtex_width || surface -> h != subtex_height) {
			SDL_SoftStretchLinear(surface, NULL, rescaled_surface, NULL);
			src_surface = rescaled_surface;
		}
		else src_surface = surface;

		SDL_LockSurface(src_surface);

		glTexSubImage3D(TexSet, 0, 0, 0, i, subtex_width, subtex_height, 1,
			OPENGL_INPUT_PIXEL_FORMAT, OPENGL_COLOR_CHANNEL_TYPE, src_surface -> pixels);

		SDL_UnlockSurface(src_surface);

		deinit_surface(surface);
	}

	deinit_surface(rescaled_surface);
	glGenerateMipmap(TexSet);
	va_end(args);

	return ts;
}
*/

/////

	/* TODO: find a way to move billboards + change their animation indices
	And for billboards, associate a texture index with it that can dynamically change */

	/* Since TexNonrepeating is necessary for billboards, billboards and walls will have to be stored in different places.
	Damn - will have to store otherwise static billboards in same spritesheet - those are not walls But get the animation set
	thing working first. So don't worry about this: `First, arrange billboards in the beginning, and then non-billboards after`.
	Also, since animation frame indices will already have to account for some offset calculation,
	it should be okay with the textures at the beginning. */

/////

		/*
		"vec3 reflection_dir = reflect(-light_dir, face_normal);\n"
		// "float s = pow(max(dot(viewDir, reflectDir), 0.0), 32);\n"
		"float s = dot(normalize(1/view_dir), reflection_dir);\n"
		"s = max(s, 0.0f);\n"
		"s = pow(s, 256);\n"
		*/

///// Old shading stuff:


	"float specular(void) {\n" // Shininess
		"return 0.0f;\n"

		/*
		"vec3 view_dir = normalize(pos_delta_world_space);\n"
		"vec3 reflect_dir = reflect(-lightDir, norm);\b"
		"return 0.0f;\n"
		*/
	"}\n"

	"float attenuation(void) {\n" // Distance-based lighting
		"float dist_squared = dot(pos_delta_world_space, pos_delta_world_space);\n"
		// "float dist = sqrt(dist_squared);\n"
		"atten_vars;\n"
		"return 1.0f / (0.9f + 0.005000f * dist_squared);\n"

		// "float c1 = atten_vars[0], c2 = atten_vars[1], c3 = atten_vars[2];\n"
		// "return 1.0f / (c1 + c3 * dist_squared);\n"

		// "return 1.0f / (8.0f + 4.0f * dist_squared + 3.0f * sqrt(dist_squared));\n"
		// "return 150.0f / dist_squared;\n"
		// "return clamp(100.0f / dist_squared, 0.4f, 1.0f);\n"
	"}\n"

/////

	static GLfloat c1 = 1.0f, c2 = 0.01f, c3 = 0.02f;
	const GLfloat step = 0.001f;

	// vals = {0.909001, 0.022000, 0.005000}

	byte change = 0;

	if (keys[SDL_SCANCODE_Z]) c1 += step, change = 1;
	if (keys[SDL_SCANCODE_X]) c1 -= step, change = 1;
	if (keys[SDL_SCANCODE_C]) c2 += step, change = 1;
	if (keys[SDL_SCANCODE_V]) c2 -= step, change = 1;
	if (keys[SDL_SCANCODE_B]) c3 += step, change = 1;
	if (keys[SDL_SCANCODE_N]) c3 -= step, change = 1;

	if (change) printf("vals = {%lf, %lf, %lf}\n", (double) c1, (double) c2, (double) c3);

	// glUniform3f(atten_vars_id, c1, c2, c3);
	// glUniform3f(atten_vars_id, 0.909001f, 0.022000f, 0.005000f);
	// glUniform3f(atten_vars_id, 0.909001f, 0.022000f, 0.005000f);

/////

	/*
	static float a = 0.1f;
	glm_rotate_zr
	(view, a, view);
	a += 0.01f;
	*/

	/*
	for (byte y = 0; y < 4; y++) {
		for (byte x = 0; x < 4; x++) {
			printf("%lf ", (double) view[y][x]);
		}
		putchar('\n');
	}
	puts("---");
	*/

	/*
	static float a = 0.0f;
	a += 0.01f;
	glm_rotate(view, a, (vec3) {1.0f, 0.0f, 0.0f});
	*/

/////

	/*
	mat4 roll_matrix = GLM_MAT4_IDENTITY_INIT;
	glm_rotate(roll_matrix, tilt, dir);
	*/

	// vec3 looking_at = {dir[0] * cos(hori_angle_minus_half_pi)}
	// lookAtVector = Normalize3dVector(viewDir * cos(angle) + UpVector * sin(angle));
	// right[1] = 1.0f;

/////

	/*
	// right[2] += tanf(tilt);
	right[0] += tanf(tilt);
	// right[1] = tanf(tilt);
	print_vec(right);
	glm_vec3_normalize(right);
	*/

	// vec3 roll = {0.0f, tilt, 0.0f};
	// yaw = side to side, pitch = up and down

/////


	// glm_mul(roll, view, view);

	/*
	static GLfloat a = 0.0f;
	a += 0.01f;
	mat4 rot;
	glm_rotate_z((mat4) GLM_MAT4_IDENTITY_INIT, a, rot);
	glm_add
	*/

	/*
	static float d = 0.0f;
	DEBUG((int) d, d);
	DEBUG(d, lf);
	d += keys[SDL_SCANCODE_C] * 0.01f;
	if ((int) d == 16) d = 0;
	((float*) view)[(int) d] = 3.9f;
	*/

	//
	/*
	for (byte y = 0; y < 4; y++) {
		for (byte x = 0; x < 4; x++)
			printf("%lf ", (double) view[x][y]);
		putchar('\n');
	}
	puts("---");
	*/
	//

/////

	//////////
	/*
	mat4 roll = GLM_MAT4_IDENTITY_INIT;
	glm_rotate(roll, tilt, dir);
	*/

	// lookDir = glm::normalize( vec3(sinf(yaw) * cos(tilt), sin(tilt), cosf(yaw) * cos(tilt)) );
	// up *= mat3(roll);
	// The wrong angle turns the view up

	/*
	for (byte y = 0; y < 4; y++) {
		for (byte x = 0; x < 4; x++)
			printf("%lf ", (double) roll[x][y]);
		putchar('\n');
	}
	puts("---");
	*/

/////

	/*
	vec3 test = {0.0f, 1.0f, 0.0f};
	const GLfloat angle = 90.0f;
	const GLfloat rads = angle * (GLfloat) M_PI / 180.0f;

	DEBUG(rads, lf);
	print_vec(test);
	vec3_rot_z(test, rads);
	print_vec(test);
	puts("---");
	*/

	/*
	right[1] += tanf(tilt);
	right[0] += sinf(tilt);
	right[2] += sinf(tilt);

	glm_vec3_normalize(right);
	print_vec(right);
	*/

/////


void vec3_rot_z(vec3 v, const GLfloat angle) {
	const GLfloat cos_theta = cosf(angle), sin_theta = sinf(angle);

	const GLfloat x_prime = v[0] * cos_theta - v[1] * sin_theta;
	const GLfloat z_prime = v[0] * sin_theta + v[1] * cos_theta;

	v[0] = x_prime;
	v[1] = z_prime;

	/* This was around y
	const GLfloat cos_theta = cosf(angle), sin_theta = sinf(angle);

	const GLfloat x_prime = v[0] * cos_theta + v[2] * sin_theta;
	const GLfloat z_prime = -v[0] * sin_theta + v[2] * cos_theta;

	DEBUG(x_prime, d);

	v[0] = x_prime;
	v[2] = z_prime;
	*/
}

/////

- Finding if planes are intersecting:

Planes are infinite

Equation: Ax + By + Cz + D = 0

To define a plane, you need a point on the plane, and a surface normal

Two vectors: PQ and PR
PQ x PR = N = normal
A = normal.x, B = normal.y, C = normal.z
And can use P, Q, or R for the plane's point
Use P, since it's the shared point

With that, the equation is Ax + By + Cz + P (?)
And A(X - P.x) + B(Y - P.y) + C(Z - P.z) = 0
Then, plug in P values, and put something on the other side of the equation after that

cglm, plane 1 with plane 2:

p1 = plane 1, p2 = plane 2
cglm does not extract planes for an aabb

New idea:

n1 = plane 1 normal, n2 = plane 2 normal
Direction of line of intersection = n1 x n2

line1dir = n1  n3
line2dir = n2  n3
Whatever, this is very complicated
Bounding spheres!

///// Some not anymore used functions for sectors:

/*
static void print_sector_list(const SectorList* const sector_list) {
	const List sectors = sector_list -> sectors;

	puts("sector_list = [");
	for (size_t i = 0; i < sectors.length; i++) {
		const Sector sector = ((Sector*) sectors.data)[i];
		printf("\t.texture_id = %d, {.origin = {%d, %d}, .size = {%d, %d}, "
			".visible_heights = {.min = %d, .max = %d}, "
			"ibo_range = {.start = %u, .range = %u}}%s\n",

			sector.texture_id, sector.origin[0], sector.origin[1], sector.size[0],
			sector.size[1], sector.visible_heights.min, sector.visible_heights.max,
			sector.ibo_range.start, sector.ibo_range.length, (i == sectors.length - 1) ? "" : ", "
		);
	}
	puts("]");
}
*/

/*
static void print_map(const char* const name, const byte* const map, const byte map_width, const byte map_height) {
	printf("%s = {\n", name);

	for (byte y = 0; y < map_height; y++) {
		printf("\t{");
		const byte* const row = map + y * map_width;
		for (byte x = 0; x < map_width; x++) {

			const char* end;

			if (x == map_width - 1)
				end = (y == map_height - 1) ? "}\n" : "},\n";
			else end = ", ";

			printf("%d%s", row[x], end);
		}
	}
	puts("}");
}
*/

/////

	printf("aabb_corners = {{%lf, %lf, %lf}, {%lf, %lf, %lf}}\n",
		aabb_corners[0][0], aabb_corners[0][1], aabb_corners[0][2],
		aabb_corners[1][0], aabb_corners[1][1], aabb_corners[1][2]);

/////

	//////////

	/*
	const Billboard hot_dog = ((Billboard*) (scene_state -> billboard_draw_context.object_buffers.cpu.data))[0];
	vec4 frustum_planes[6];
	glm_frustum_planes((vec4*) camera.view_projection, frustum_planes);
	DEBUG(billboard_in_view_frustum(hot_dog, frustum_planes), d);
	*/

/////

		/*
		const GLfloat max_delay = 1000.0f / constants.fps;
		DEBUG(max_delay, lf);
		DEBUG(1.0f / (1000.0f / constants.fps), lf);
		// DEBUG(delta_time, lf);
		const GLfloat p = 1.0f / (1000.0f / constants.fps);
		*/

		/*
		GLfloat a = log2f(xz_speed_heuristic * 2.0f + 1.0f);
		// GLfloat a = xz_speed_heuristic / (xz_v_max * 0.0666666);
		// if (a > 1.0f) a = 1.0f;
		pos[1] += sinf(curr_time * THREE_PI) * 0.15f * a;
		*/

/////

		/*
		// const GLfloat avg_pos_xz = (pos[0] + pos[1]) * 0.5f;
		GLfloat avg_speed_xz = (fabsf(physics_obj -> speeds[0]) + fabsf(physics_obj -> speeds[2])) * 0.5f;
		DEBUG((double) sinf(avg_speed_xz), lf);
		pos[1] += sinf(avg_speed_xz);
		*/

		/*
		GLfloat avg_speed_xz = (fabsf(physics_obj -> speeds[0]) + fabsf(physics_obj -> speeds[2])) * 0.5f;
		// if (avg_speed_xz > 1.5f) avg_speed_xz = 2.0f;
		const GLfloat avg_speed_xz_per_sec = avg_speed_xz / delta_time;
		DEBUG((double) avg_speed_xz_per_sec, lf);
		*/

		// const GLfloat a = fabsf(physics_obj -> speeds[0] / delta_time);

		/*
		const GLfloat max_bob_height = 0.2f;
		static GLfloat x = 0.0f;
		const GLfloat dy = max_bob_height * 0.5f * sinf(PI * (x - 0.5f)) + max_bob_height;
		pos[1] += dy;

		const GLfloat forward_backward_speed = fabsf(physics_obj -> speeds[0]), strafe_speed = fabsf(physics_obj -> speeds[2]);
		const GLfloat greatest_speed = (forward_backward_speed > strafe_speed) ? forward_backward_speed : strafe_speed;
		x += greatest_speed;
		*/

/////

		/*
		const GLfloat avg_speed = (fabsf(physics_obj -> speeds[0]) + fabsf(physics_obj -> speeds[2])) * 0.5f;
		DEBUG(avg_speed, lf);
		const GLfloat avg_speed_per_second = avg_speed / delta_time;
		DEBUG(avg_speed_per_second, lf);
		*/

		/*
		const GLfloat max_bob_height = 0.2f;
		static GLfloat x = 0.0f;
		const GLfloat dy = max_bob_height * 0.5f * sinf(PI * (x - 0.5f)) + max_bob_height;
		pos[1] += dy;

		const GLfloat forward_backward_speed = fabsf(physics_obj -> speeds[0]), strafe_speed = fabsf(physics_obj -> speeds[2]);
		const GLfloat greatest_speed = (forward_backward_speed > strafe_speed) ? forward_backward_speed : strafe_speed;
		x += greatest_speed;
		*/

/////

	// bob_delta = speed_xz_percent * sinf(3.75f * PI * camera -> bob_bounce_input) * 0.1f + 0.1f * speed_xz_percent;

/////

	/*
	puts("{");
	for (int y = 0; y < terrain_height; y++) {
		printf("\t{");
		for (int x = 0; x < terrain_width; x++) {
			const int val = (x & 1) ^ (y & 1);
			printf("%d", val);
			if (x == terrain_width - 1) puts("},");
			else printf(", ");
			*map_point((byte*) texture_id_map, x, y, terrain_width) = val;
		}
	}
	puts("}");
	*/

/////

	SDL_GL_SetAttribute(SDL_GL_RED_SIZE, 8);
	SDL_GL_SetAttribute(SDL_GL_GREEN_SIZE, 8);
	SDL_GL_SetAttribute(SDL_GL_BLUE_SIZE, 8);

/////



	/*
	char curr_char = 1;

	do {
		curr_char = *file_contents;

		switch (curr_char) {
			case COMMENT_START:
				puts("Start of comment");
				while (*file_contents != '\0' && *file_contents != '\n') file_contents++;
				puts("Now at end of line");
				break;
			case SECTION_TAG_START:
				puts("Start of section");
				break;
		}

		file_contents++;
	} while (curr_char != '\0');
	*/

	/*
	char curr_char = *file_contents;

	while (curr_char != '\0') { // While not reached a null terminator
		// const char curr_char = *file_contents;
		printf("curr_char = '%c'\n", curr_char);
		switch (curr_char) {
			case '\n': break;

			case COMMENT_START:
				puts("Start of comment");
				while (*file_contents != '\0' && *file_contents != '\n') file_contents++;
				puts("Now at end of line");
				break;
			case SECTION_TAG_START:
				puts("Start of section");
				break;
		}

		// curr_char = *++file_contents;
		file_contents++;
		curr_char = *file_contents;
	}
	*/

/////

	// if (num_bytes == 0l) FAIL(OpenFile, "attemped to read file with the path of '%s', but it was empty.", filename);

/////

	/*
	for (long rel_char_index = *char_index + 1; rel_char_index < file_contents.num_bytes; rel_char_index++) {
		// const char curr_char = file_contents.data[rel_char_index];
		// DEBUG(curr_char, c);

		for (byte i = 0; i < num_section_tag_types; i++) {
			const SectionTag tag = section_tags[i];
			const size_t tag_length = strlen(tag.name);
			if (strncmp(tag.name, ))
		}
	}
	*/

/////

		// if (tag_ref -> flags & TAG_IS_ONE_LINE_BIT) puts("Check for space after tag name");

			// Each tag needs a whitespace character, whether that be a space, a newline character, or something else

			// const char after = *(tag_start + tag_length);
			const char after = tag_start[tag_length];
			// const byte needs_an_one_line_argument = tag_ref -> flags & (TAG_IS_ONE_LINE_BIT | TAG_HAS_ARGUMENT_BIT);
			// DEBUG(needs_an_one_line_argument, d);

			if (/* (needs_an_one_line_argument && after == '\0') */ isspace(after)) {
				matching_tag = tag_ref;
				break;
			}
			// printf("tag_name = '%s', and after = '%c', and is whitespace = %d\n", tag_name, after, isspace(after));

			/*
			if ((tag_ref -> flags & TAG_HAS_ARGUMENT_BIT)) {
				DEBUG(*tag_start, c);
				const char after = (*tag_start + tag_length + 1);
				DEBUG(after, c);
				if (!isspace(after)) puts("Need space after");
			}

			matching_tag = tag_ref;
			break;
			*/

/////

			// printf("Ladies and gentlemen, something should have parsed this character: '%c'\n", curr_char);

///// The old DDL parser, mixed with a bit of the new one:

#include "ddl_parser.h"

// The pointer in the file contents returned by this function should be freed by the caller
static FileContents read_file_contents(const char* const file_name) {
	FILE* const file = fopen(file_name, "r");
	if (file == NULL) FAIL(OpenFile, "could not open a file with the path of '%s'.", file_name);

	fseek(file, 0l, SEEK_END); // Set file position to end
	const long num_bytes = ftell(file);
	fseek(file, 0l, SEEK_SET); // Rewind file position

	char* const data = malloc(num_bytes + 1l);
	fread(data, num_bytes, 1, file); // Read file bytes
	data[num_bytes] = '\0';

	fclose(file);
	return (FileContents) {file_name, data, num_bytes};
}

static void progress_char_index_to_tag_argument(long* const char_index_ref,
	const SectionTag* const tag, const FileContents* const file_contents) {

	long char_index = *char_index_ref + strlen(tag -> name) + 1;
	const long orig_char_index = char_index;

	const char* const data = file_contents -> data;

	while ((char_index < file_contents -> num_bytes) && isspace(data[char_index])) char_index++;

	if ((char_index == orig_char_index) || (data[char_index] == SECTION_TAG_START))
		FAIL(ParseLevelFile, "a level tag in '%s' needs an argument.", file_contents -> file_name);

	*char_index_ref = char_index - 1;
}

static const SectionTag* get_section_tag(const long char_index, const FileContents* const file_contents) {
	/* While not reached space or newline, collect tag name
	Curr tag types: name, heightmap, texture_id_map, wall_textures 
	Also, a variant of one-line tags
	Goal is to get correct section tag out, by comparing the string up until a newline (do the multiline variant first)
	Need whitespace after a one-line tag */

	// No need to worry about overflow here since strncmp accounts for a possible null terminator
	const char* const tag_start = file_contents -> data + char_index + 1;
	const SectionTag* matching_tag = NULL;

	for (byte i = 0; i < num_section_tag_types; i++) {
		const SectionTag* const tag_ref = section_tags + i;
		const char* const tag_name = tag_ref -> name;

		const size_t tag_length = strlen(tag_name);

		// If the tag matches, and there's a whitespace character after it
		if (strncmp(tag_name, tag_start, tag_length) == 0 && isspace(tag_start[tag_length])) {
			matching_tag = tag_ref;
			break;
		}
	}

	if (matching_tag == NULL)
		FAIL(ParseLevelFile, "did not recognize a level tag for '%s'.", file_contents -> file_name);

	// else printf("Found a tag match: '%s'\n", matching_tag -> name);
	return matching_tag;
}

SECTION_PARSER_DEF(name) {
	(void) start_char_index;
	(void) end_char_index;
	(void) file_contents;
	(void) eds;
	puts("Name parser");

	// strtok?

	/*
	const size_t name_length = end_char_index - start_char_index + 1;
	DEBUG(name_length, zu);
	*/

	/*
	file_contents -> data[end_char_index + 1] = '\0';
	printf("Name: '%s'\n", file_contents -> data + start_char_index);
	*/
}

SECTION_PARSER_DEF(map_size) {
	(void) start_char_index;
	(void) end_char_index;
	(void) file_contents;
	(void) eds;
	puts("Map size parser");
}

SECTION_PARSER_DEF(heightmap) {
	(void) start_char_index;
	(void) end_char_index;
	(void) file_contents;
	(void) eds;
	puts("Heightmap parser");
}

SECTION_PARSER_DEF(texture_id_map) {
	(void) start_char_index;
	(void) end_char_index;
	(void) file_contents;
	(void) eds;
	puts("Texture id map parser");
}

SECTION_PARSER_DEF(wall_texture) {
	(void) start_char_index;
	(void) end_char_index;
	(void) file_contents;
	(void) eds;
	puts("Wall texture parser");
}

// The beginning of a section is marked by an ampersand an an identifier, and then an argument
static void parse_section(long* const char_index_ref, const FileContents* const file_contents,
	const SectionTag* const tag, const EditorState* const eds) {

	const char* const data = file_contents -> data;

	long char_index = *char_index_ref + 1;
	const long arg_start_index = char_index;

	// Find start of next argument, at its ampersand; and after that, backtrack, ignoring all whitespace characters
	while ((char_index < file_contents -> num_bytes) && (data[char_index] != SECTION_TAG_START)) char_index++;
	while (isspace(data[--char_index]));

	*char_index_ref = char_index; // Here, char_index equals arg_end_index
	tag -> section_parser(arg_start_index, char_index, file_contents, eds);
	
	// printf("Start char is '%c', and end char is '%c'\n|\n", data[arg_start_index], data[char_index]);
	/* data[char_index + 1] = '\0';
	printf("Arg: '%s'\n", data + arg_start_index); */
}

static void parse_ddl_file(EditorState* const eds, FileContents* const file_contents) {
	char* const data = file_contents -> data;
	const long num_bytes = file_contents -> num_bytes;

	// This erases all comments and replaces them with whitespace
	for (long i = 0; i < num_bytes; i++) {
		if (data[i] == COMMENT_START) {
			while (i < num_bytes && data[i] != '\n') data[i++] = ' ';
		}
	}

	/*
	const char* const delimiters = " \n\t\v\f\r";

	const char* token = strtok(data, delimiters);
	while (token != NULL) {
		if (token[0] == SECTION_TAG_START) {
			puts("Parse section");
			const char* const tag_name = token + 1;
			DEBUG(tag_name, s);

			const SectionTag* matching_tag = NULL;
			for (byte i = 0; i < num_section_tag_types; i++) {
				const SectionTag* const cmp_tag = section_tags + i;
				const char* const cmp_tag_name = cmp_tag -> name;
				if (strncmp(cmp_tag -> name, tag_name, strlen(cmp_tag_name)) == 0) {
					matching_tag = cmp_tag;
					break;
				}
			}
			if (matching_tag == NULL)
				FAIL(ParseLevelFile, "did not recognize a level tag for '%s'.", file_contents -> file_name);
			else puts("Found a tag!");
		}

		printf("token = '%s'\n", token);
		token = strtok(NULL, delimiters);
	}
	*/

	for (long i = 0; i < num_bytes; i++) {
		const char curr_char = data[i];
		if (curr_char == SECTION_TAG_START) {
			const SectionTag* const tag = get_section_tag(i, file_contents);
			progress_char_index_to_tag_argument(&i, tag, file_contents);
			parse_section(&i, file_contents, tag, eds);
		}
		else if (!isspace(curr_char))
			FAIL(ParseLevelFile, "Lone character '%c' for level '%s'.", curr_char, file_contents -> file_name);
	}
}

void init_editor_state_from_ddl_file(EditorState* const eds, const char* const filename) {
	FileContents file_contents = read_file_contents(filename);
	parse_ddl_file(eds, &file_contents);
	free(file_contents.data);
}

///// Variant 1:

	/*
	while (*data != '\0') {
		if (*data == COMMENT_START) { // If found a comment, add spaces until the end of the line or file
			while ((*data != '\0') && (*data != '\n')) *(data++) = ' ';
		}
		if (*data != '\0') data++;
	}
	*/

///// Variant 2:

	char c = *data;
	long char_index = 0;

	while (c != '\0') {
		if (c == COMMENT_START) {
			while ((c != '\0') && (c != '\n')) {
				data[char_index++] = ' ';
				c = data[char_index];
			}
		}
		c = data[char_index++];
	}

/////

void add_face_mesh_to_list(const Face face, const byte sector_max_visible_height,
	const byte side, const byte texture_id, List* const face_mesh_list) {

	/* Face info bits, layout:
		Bits 0-1, two bits -> face type
		Bit 2, one bit -> face side (top or left side of top-down sector)
		Bits 3-7, five bits -> texture id

	So, 00 -> flat, 01 -> vert NW, and 10 -> vert EW */

	const byte
		face_info = (texture_id << 3) | (side << 2) | face.type,
		near_x = face.origin[0], near_z = face.origin[1],
		top_y = sector_max_visible_height;

	const mesh_component_t* face_mesh;

	/*
	buffer_index_t index_set[indices_per_face] = {s, s + 1, s + 2, s, s + 3, s + 1};

	if ((face.type == Vert_NS && !side) || (face.type == Vert_EW && side)) {
		index_set[3]++;
		index_set[5]++;
	}
	*/

	// 0, 1, 2, 0, 3, 1; or 0, 1, 2, 1, 3, 2

	switch (face.type) {
		case Flat: {
			const byte size_x = face.size[0], size_z = face.size[1];
			const byte far_x = near_x + size_x, far_z = near_z + size_z;

			face_mesh = (mesh_component_t[vars_per_face]) {
				/*
				near_x, top_y, far_z, face_info,
				far_x, top_y, near_z, face_info,
				near_x, top_y, near_z, face_info,
				far_x, top_y, far_z, face_info
				*/

				near_x, top_y, far_z, face_info, // 0
				far_x, top_y, near_z, face_info, // 1
				near_x, top_y, near_z, face_info, // 2

				near_x, top_y, far_z, face_info, // 0
				far_x, top_y, far_z, face_info, // 3
				far_x, top_y, near_z, face_info // 1
			};
			break;
		}
		case Vert_NS: {
			const byte size_z = face.size[0], size_y = face.size[1];
			const byte far_z = near_z + size_z, bottom_y = top_y - size_y;

			face_mesh = side
				? (mesh_component_t[vars_per_face]) {
					/*
					near_x, bottom_y, near_z, face_info,
					near_x, top_y, far_z, face_info,
					near_x, top_y, near_z, face_info,
					near_x, bottom_y, far_z, face_info
					*/

					// Vert_NS && side -> 0, 1, 2, 0, 3, 1

					near_x, bottom_y, near_z, face_info, // 0
					near_x, top_y, far_z, face_info, // 1
					near_x, top_y, near_z, face_info, // 2

					near_x, bottom_y, near_z, face_info, // 0
					near_x, bottom_y, far_z, face_info, // 3
					near_x, top_y, far_z, face_info // 1
				}
				: (mesh_component_t[vars_per_face]) {
					/*
					near_x, top_y, near_z, face_info,
					near_x, top_y, far_z, face_info,
					near_x, bottom_y, near_z, face_info,
					near_x, bottom_y, far_z, face_info
					*/

					// Vert_NS && !side -> 0, 1, 2, 1, 3, 2

					near_x, top_y, near_z, face_info, // 0
					near_x, top_y, far_z, face_info, // 1
					near_x, bottom_y, near_z, face_info, // 2				

					near_x, top_y, far_z, face_info, // 1
					near_x, bottom_y, far_z, face_info, // 3
					near_x, bottom_y, near_z, face_info // 2
				};
			break;
		}
		case Vert_EW: {
			const byte size_x = face.size[0], size_y = face.size[1];
			const byte far_x = near_x + size_x, bottom_y = top_y - size_y;

			face_mesh = side
				? (mesh_component_t[vars_per_face]) {
					/*
					near_x, top_y, near_z, face_info,
					far_x, top_y, near_z, face_info,
					near_x, bottom_y, near_z, face_info,
					far_x, bottom_y, near_z, face_info
					*/

					// Vert_EW && side -> 0, 1, 2, 1, 3, 2

					near_x, top_y, near_z, face_info, // 0
					far_x, top_y, near_z, face_info, // 1
					near_x, bottom_y, near_z, face_info, // 2

					far_x, top_y, near_z, face_info, // 1
					far_x, bottom_y, near_z, face_info, // 3
					near_x, bottom_y, near_z, face_info // 2
				}
				: (mesh_component_t[vars_per_face]) {
					/*
					near_x, bottom_y, near_z, face_info,
					far_x, top_y, near_z, face_info,
					near_x, top_y, near_z, face_info,
					far_x, bottom_y, near_z, face_info
					*/

					// Vert_EW && !side -> 0, 1, 2, 0, 3, 1

					near_x, bottom_y, near_z, face_info, // 0
					far_x, top_y, near_z, face_info, // 1
					near_x, top_y, near_z, face_info, // 2

					near_x, bottom_y, near_z, face_info, // 0
					far_x, bottom_y, near_z, face_info, // 3
					far_x, top_y, near_z, face_info // 1

				};
			break;
		}
	}

	push_ptr_to_list(face_mesh_list, face_mesh);

	//////////

	/*
	const buffer_index_t s = index_list -> length * vertices_per_face; // s = index set start
	buffer_index_t index_set[indices_per_face] = {s, s + 1, s + 2, s, s + 3, s + 1};

	if ((face.type == Vert_NS && !side) || (face.type == Vert_EW && side)) {
		index_set[3]++;
		index_set[5]++;
	}

	push_ptr_to_list(index_list, index_set);
	*/
}

/////

	// TODO: don't keep track of `i`
	const size_t total_bytes = sector_face_meshes -> length * bytes_per_face;
	memset(face_meshes_gpu, 0, total_bytes);
	DEBUG(total_bytes, d);

/////

	/*
	DEBUG_BITS(last_chunk_upper_x_bits_set);
	byte first_chunk = 0b10101010;
	byte num_lower_bits_set_in_first_chunk = area_w % 8u;
	DEBUG(num_lower_bits_set_in_first_chunk, d);

	const byte a = (all_bits_set >> (area_x & area_w));
	DEBUG_BITS(a);

	const byte fully_set_chunks = (area_w >> 3u) - 1u;
	DEBUG(fully_set_chunks, d);

	const byte bits_for_lower_chunk = 
	*/

/////


// A 'chunk' is a byte, or a group of 8 bits
inlinable void set_statemap_area(const StateMap statemap, const SDL_Rect area) {
	puts("Area setting time");
	printf("Setting area {%d, %d, %d, %d}\n", area.x, area.y, area.w, area.h);

	const byte all_bits_set = 255u;

	const unsigned area_x = area.x, area_w = area.w;
	const unsigned start_chunk_index = area_x >> 3u;
	// const unsigned num_fully_settable_chunks = area_w >> 3u;

	/*
	const byte lower_cleared_bits_for_last_chunk = (area_w & 7u); // `x & 7 == x % 8`.
	// In the last chunk, a certain number of upper bits are set. `255 >> x` = upper `x` bits are cleared.
	const byte last_chunk = ~(all_bits_set >> lower_cleared_bits_for_last_chunk);
	*/

	//////////
	// Setting middle and last chunks at the moment; set first chunk too
	const byte num_fully_set_chunks = start_chunk_index - 1u;

	// DEBUG(num_fully_set_chunks, d);

	// const byte bits_for_first_chunk = 8 - (area_x & 7);
	const byte bits_cleared_for_first_chunk_start = area_x & 7;
	// DEBUG(bits_for_first_chunk, d);
	// const byte first_chunk = ~(all_bits_set >> (8 - bits_cleared_for_first_chunk)) >> bits_cleared_for_first_chunk;
	// DEBUG(bits_cleared_for_first_chunk, d);
	const byte first_chunk = all_bits_set >> bits_cleared_for_first_chunk_start;

	const byte bits_cleared_for_first_chunk_end = 3; // ???

	DEBUG_BITS(first_chunk);

	// first needs 6

	// const unsigned bit_sum = bits_for_first_chunk + (8 - lower_cleared_bits_for_last_chunk) + num_fully_set_chunks * 8;
	// DEBUG(bit_sum, d);

	//////////

	DEBUG(num_fully_set_chunks, d);
	void print_statemap(const StateMap statemap);
	puts("Before:");
	print_statemap(statemap);

	for (unsigned y = (unsigned) area.y; y < (unsigned) (area.y + area.h); y++) {
		byte* const chunk_start = statemap_byte(statemap, start_chunk_index, y);

		*chunk_start |= first_chunk;

		// for (unsigned x = 1u; x < num_fully_settable_chunks; x++) chunk_start[x] = all_bits_set;

		// memset(chunk_start + 1, all_bits_set, num_fully_set_chunks);
		// chunk_start[num_fully_set_chunks] |= last_chunk;
	}
	puts("After:");
	print_statemap(statemap);
	puts("---");
}

///// God damn this is so hard

inlinable byte bits_set_in_domain(const byte start, const byte end) {
	const byte x_bits_set = ~(255u << (end - start));
	return x_bits_set << start;
}

// A 'chunk' is a byte, or a group of 8 bits
inlinable void set_statemap_area(const StateMap statemap, const SDL_Rect area) {
	puts("Area setting time");
	printf("Setting area {%d, %d, %d, %d}\nBefore:\n", area.x, area.y, area.w, area.h);

	const byte test = bits_set_in_domain(2, 7);
	DEBUG_BITS(test);

	const unsigned area_x = area.x, area_w = area.w;

	typedef struct {
		byte left, right;
	} BitRange;

	BitRange start_chunk = {.left = 8u - (area_x & 7u)};
	DEBUG(start_chunk.left, d);
	start_chunk.right = (area.w >= start_chunk.left ? 0 : (8u - start_chunk.left));

	// byte num_start_chunk_bits = 8u - (area_x & 7u);

	// if (area_w <= 8) num_start_chunk_bits -= area_w;

	// DEBUG(num_start_chunk_bits, d);

	/*
	const byte num_full_middle_chunks = area_w;
	DEBUG(num_full_middle_chunks, d);

	const byte num_end_chunk_bits = 8u - ((area_x + area_w) & 7u);
	DEBUG(num_end_chunk_bits, d);
	*/

	void print_statemap(const StateMap statemap);
	print_statemap(statemap);

	/*
	for (unsigned y = (unsigned) area.y; y < (unsigned) (area.y + area.h); y++) {
		byte* const chunk_start = statemap_byte(statemap, start_chunk_index, y);

		*chunk_start |= first_chunk;

		// for (unsigned x = 1u; x < num_fully_settable_chunks; x++) chunk_start[x] = all_bits_set;

		// memset(chunk_start + 1, all_bits_set, num_fully_set_chunks);
		// chunk_start[num_fully_set_chunks] |= last_chunk;
	}
	*/
	puts("After:");
	print_statemap(statemap);
	puts("---");
}

/////

	/*
	set_statemap_area(traversed_points,
		(SDL_Rect) {sector.origin[0], origin_y, sector.size[0], sector.size[1]}
		);
	*/

	static byte first = 1;
	if (first) {
		set_statemap_area(traversed_points, (SDL_Rect) {3, 2, 1, 4});
		first = 0;
	}

///// A bit of spike testing:

		const Uint32 b4 = SDL_GetTicks();
		SDL_GL_SwapWindow(screen -> window);
		const Uint32 diff = SDL_GetTicks() - b4;
		if (diff > 3) puts("Spike");

/////