///// Old demo 3 stuff:

#include "demo_2.c"
#define deinit_texture(t) glDeleteTextures(1, &t)

DemoVars demo_3_init(void) {
	DemoVars dv;

	const char* const vertex_shader =
		"#version 330 core\n"
		"layout(location = 0) in vec3 vertexPosition_modelspace\n"
		"layout(location = 1) in vec2 vertexUV\n"
		"out vec2 UV;\n"
		"uniform mat4 MVP;\n"
		"void main() {\n"
			"gl_Position =  MVP * vec4(vertexPosition_modelspace, 1);\n"
			"UV = vertexUV;\n"
		"}\n",

	*const fragment_shader =
		"#version 330 core\n"
		"in vec2 UV;\n"
		"out vec3 color;\n"
		"uniform sampler2D myTextureSampler;\n"
		"void main() {\n"
    		"color = texture(myTextureSampler, UV).rgb;\n"
		"}\n";
	
	dv.shader_program = init_shader_program(vertex_shader, fragment_shader);

	const GLfloat uv_buffer_data[] = {
    	0.000059f, 1.0f-0.000004f,
    	0.000103f, 1.0f-0.336048f,
    	0.335973f, 1.0f-0.335903f,
    	1.000023f, 1.0f-0.000013f,
    	0.667979f, 1.0f-0.335851f,
    	0.999958f, 1.0f-0.336064f,
    	0.667979f, 1.0f-0.335851f,
    	0.336024f, 1.0f-0.671877f,
    	0.667969f, 1.0f-0.671889f,
    	1.000023f, 1.0f-0.000013f,
    	0.668104f, 1.0f-0.000013f,
    	0.667979f, 1.0f-0.335851f,
    	0.000059f, 1.0f-0.000004f,
    	0.335973f, 1.0f-0.335903f,
    	0.336098f, 1.0f-0.000071f,
    	0.667979f, 1.0f-0.335851f,
    	0.335973f, 1.0f-0.335903f,
    	0.336024f, 1.0f-0.671877f,
    	1.000004f, 1.0f-0.671847f,
    	0.999958f, 1.0f-0.336064f,
    	0.667979f, 1.0f-0.335851f,
    	0.668104f, 1.0f-0.000013f,
    	0.335973f, 1.0f-0.335903f,
    	0.667979f, 1.0f-0.335851f,
    	0.335973f, 1.0f-0.335903f,
    	0.668104f, 1.0f-0.000013f,
    	0.336098f, 1.0f-0.000071f,
    	0.000103f, 1.0f-0.336048f,
    	0.000004f, 1.0f-0.671870f,
    	0.336024f, 1.0f-0.671877f,
    	0.000103f, 1.0f-0.336048f,
    	0.336024f, 1.0f-0.671877f,
    	0.335973f, 1.0f-0.335903f,
    	0.667969f, 1.0f-0.671889f,
    	1.000004f, 1.0f-0.671847f,
    	0.667979f, 1.0f-0.335851f
	};

	(void) uv_buffer_data;

	return dv;
}

GLuint init_texture(const char* const path) {
	SDL_Surface* const image = SDL_LoadBMP(path);
	if (image == NULL) fail("open image file", OpenImageFile);
	SDL_LockSurface(image);

	GLuint texture;

	glGenTextures(1, &texture);
	glBindTexture(GL_TEXTURE_2D, texture);

	glTexImage2D(GL_TEXTURE_2D, 0, GL_RGB, image -> w, image -> h, 0, GL_BGR, GL_UNSIGNED_BYTE, image -> pixels);

	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_LINEAR);
	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
	glGenerateMipmap(GL_TEXTURE_2D);

	SDL_UnlockSurface(image);
	SDL_FreeSurface(image);
	return texture;
}

void demo_3_drawer(const DemoVars dv) {
	/*
	GLuint foo = init_texture("assets/walls/mesa.bmp");
	deinit_texture(foo);
	*/

	demo_2_drawer(dv);
}

int main(void) {
	// load_texture("assets/walls/mesa.bmp");
	make_application(demo_3_drawer, demo_2_init, demo_1_deinit);
}

///// Lots of vertex testing:


	GLfloat texcoords[][2] = { {0.0,0.0},    {1.0,0.0}, {1.0,1.0}, {0.0,1.0},
                               {0.0,0.0}, {1.0,0.0}, {1.0,1.0}, {0.0,1.0},
                               {0.0,0.0}, {1.0,0.0}, {1.0,1.0}, {0.0,1.0},
                               {0.0,0.0}, {1.0,0.0}, {1.0,1.0}, {0.0,1.0}
                             };

	GLubyte indices[24] = {0,1,2,3, 4,5,6,7, 3,2,5,4, 7,6,1,0,
                                  8,9,10,11, 12,13,14,15};

	/*
	for (int i = 0; i < 24; i++) {
		GLfloat* uv = texcoords[indices[i]];
		printf("%lff, %lff,\n", uv[0], uv[1]);
	}

	GLfloat uv_data[num_uv_floats] = {
		0.0, 0.0,
		1.0, 0.0,
		1.0, 1.0,
		0.0, 1.0,
		
		0.0, 0.0,
		1.0, 0.0,
		1.0, 1.0,
		0.0, 1.0,

		0.0, 1.0,
	};
	*/

GLfloat uv_data[] = {
	0.000000f, 0.000000f,
1.000000f, 0.000000f,
1.000000f, 1.000000f,
0.000000f, 1.000000f,
0.000000f, 0.000000f,
1.000000f, 0.000000f,
1.000000f, 1.000000f,
0.000000f, 1.000000f,
0.000000f, 1.000000f,
1.000000f, 1.000000f,
1.000000f, 0.000000f,
0.000000f, 0.000000f,
0.000000f, 1.000000f,
1.000000f, 1.000000f,
1.000000f, 0.000000f,
0.000000f, 0.000000f,
0.000000f, 0.000000f,
1.000000f, 0.000000f,
1.000000f, 1.000000f,
0.000000f, 1.000000f,
0.000000f, 0.000000f,
1.000000f, 0.000000f,
1.000000f, 1.000000f,
0.000000f, 1.000000f,
};



	/*
	#define TOP_LEFT 0.0f, 0.0f
	#define BOTTOM_LEFT 1.0f, 0.0f
	#define TOP_RIGHT 0.0f, 1.0f

	#define TRI_SET TOP_RIGHT, BOTTOM_LEFT, TOP_LEFT
	#define REV_TRI_SET TOP_LEFT, BOTTOM_LEFT, TOP_RIGHT

	static const GLfloat uv_data[num_uv_floats] = {
		TRI_SET,
		REV_TRI_SET,
		TRI_SET,
		REV_TRI_SET,
		TRI_SET,
		REV_TRI_SET,
		TRI_SET,
		REV_TRI_SET,
		TRI_SET,
		REV_TRI_SET,
		TRI_SET,
		REV_TRI_SET
	};
	*/

	/*
	static const GLfloat uv_data[num_uv_floats] = {
		0.000059f, 1.0f-0.000004f,
		0.000103f, 1.0f-0.336048f,
		0.335973f, 1.0f-0.335903f,
		1.000023f, 1.0f-0.000013f,
		0.667979f, 1.0f-0.335851f,
		0.999958f, 1.0f-0.336064f,
		0.667979f, 1.0f-0.335851f,
		0.336024f, 1.0f-0.671877f,
		0.667969f, 1.0f-0.671889f,
		1.000023f, 1.0f-0.000013f,
		0.668104f, 1.0f-0.000013f,
		0.667979f, 1.0f-0.335851f,
		0.000059f, 1.0f-0.000004f,
		0.335973f, 1.0f-0.335903f,
		0.336098f, 1.0f-0.000071f,
		0.667979f, 1.0f-0.335851f,
		0.335973f, 1.0f-0.335903f,
		0.336024f, 1.0f-0.671877f,
		1.000004f, 1.0f-0.671847f,
		0.999958f, 1.0f-0.336064f,
		0.667979f, 1.0f-0.335851f,
		0.668104f, 1.0f-0.000013f,
		0.335973f, 1.0f-0.335903f,
		0.667979f, 1.0f-0.335851f,
		0.335973f, 1.0f-0.335903f,
		0.668104f, 1.0f-0.000013f,
		0.336098f, 1.0f-0.000071f,
		0.000103f, 1.0f-0.336048f,
		0.000004f, 1.0f-0.671870f,
		0.336024f, 1.0f-0.671877f,
		0.000103f, 1.0f-0.336048f,
		0.336024f, 1.0f-0.671877f,
		0.335973f, 1.0f-0.335903f,
		0.667969f, 1.0f-0.671889f,
		1.000004f, 1.0f-0.671847f,
		0.667979f, 1.0f-0.335851f
	};
	*/

///// Even more tries:


	static const GLfloat uv_data[num_uv_floats] = {
		/* Sorta worked:
		0.0f, 0.0f,
		1.0f, 0.0f,
		1.0f, 1.0f
		*/

		/* Flipped 90 degrees:
		0.0f, 1.0f,
		0.0f, 0.0f,
		1.0f, 0.0f,
		*/


		/* Almost:
		0.0f, 1.0f,
		0.0f, 0.0f,
		1.0f, 0.0f
		*/

		/*
		0.0f, 0.0f,
		0.5f, 0.5f,
		1.0f, 1.0f
		*/

  0.0f, 0.0f, 1.0f, 0.0f, 1.0f, 1.0f,
  0.0f, 0.0f, 1.0f, 1.0f, 0.0f, 1.0f,

  0.0f, 0.0f, 1.0f, 0.0f, 1.0f, 1.0f,
  0.0f, 0.0f, 1.0f, 1.0f, 0.0f, 1.0f,

  0.0f, 0.0f, 1.0f, 0.0f, 1.0f, 1.0f,
  0.0f, 0.0f, 1.0f, 1.0f, 0.0f, 1.0f,

  0.0f, 0.0f, 1.0f, 0.0f, 1.0f, 1.0f,
  0.0f, 0.0f, 1.0f, 1.0f, 0.0f, 1.0f,

  0.0f, 0.0f, 1.0f, 0.0f, 1.0f, 1.0f,
  0.0f, 0.0f, 1.0f, 1.0f, 0.0f, 1.0f,

  0.0f, 0.0f, 1.0f, 0.0f, 1.0f, 1.0f,
  0.0f, 0.0f, 1.0f, 1.0f, 0.0f, 1.0f
	};

///// A note on UV reversals:

	// rev
	#define FIRST_UV 0.0f, 1.0f, 1.0f, 1.0f, 1.0f, 0.0f,
	#define SECOND_UV 0.0f, 0.0f, 1.0f, 1.0f, 1.0f, 0.0f,

	// rev
	#define THIRD_UV 0.0f, 0.0f, 0.0f, 1.0f, 1.0f, 1.0f,
	#define FOURTH_UV 0.0f, 1.0f, 1.0f, 0.0f, 0.0f, 0.0f,

	// fifth and sixth are reversed
	#define FIFTH_UV 1.0f, 1.0f, 0.0f, 0.0f, 0.0f, 1.0f,
	#define SIXTH_UV 1.0f, 0.0f, 0.0f, 0.0f, 1.0f, 1.0f,

	// 1 2 2 3 4 3 3 2 5 1 4 6

///// An indexing test

// Possibilities
#define P1 1.0f, 1.0f, 1.0f,
#define P2 -1.0f, -1.0f, -1.0f,

#define P3 -1.0f, 1.0f, 1.0f,
#define P4 1.0f, -1.0f, 1.0f,
#define P5 1.0f, 1.0f, -1.0f,

#define P6 -1.0f, -1.0f, 1.0f,
#define P7 1.0f, -1.0f, -1.0f,

#define P8 -1.0f, 1.0f, -1.0f

/*
	P2 P6 P3

	P5 P2 P8
*/

///// Stuff with automatic index generation:


	int index_buf_len = 0;
	int index_buffer[cube_num_points];

	for (int i = 0; i < cube_num_points; i += 3) {
		const float x = demo_3_vertex_data[i], y = demo_3_vertex_data[i + 1], z = demo_3_vertex_data[i + 2];

		byte found_match = 0;
		for (int j = 0; j < i; j += 3) {
			const float cx = demo_3_vertex_data[j], cy = demo_3_vertex_data[j + 1], cz = demo_3_vertex_data[j + 2];
			if (x == cx && y == cy && z == cz) {
				index_buffer[index_buf_len++] = j / 3;
				found_match = 1;
				break;
			}
		}

		if (!found_match) {
			printf("%lf, %lf, %lf\n", (double) x, (double) y, (double) z);
			index_buffer[index_buf_len] = index_buf_len;
			index_buf_len++;
		}
	}

	for (int i = 0; i < index_buf_len + 1; i++) {
		printf("%d%s", index_buffer[i], (i == index_buf_len - 1) ? "" : ", ");
	}
	putchar('\n');

///// And more of that:

#define A -1.000000, -1.000000, -1.000000
#define B -1.000000, -1.000000, 1.000000
#define C -1.000000, 1.000000, 1.000000
#define D 1.000000, 1.000000, -1.000000
#define E -1.000000, 1.000000, -1.000000
#define F 1.000000, -1.000000, 1.000000
#define G 1.000000, -1.000000, -1.000000
#define H 1.000000, 1.000000, 1.000000
/* 0, 1, 2, 3, 0,
5, 6, 0, 8, 3, 8,
0, 0, 2, 5, 6, 1, 0, 2, 1, 6, 21, 8, 3, 8, 21, 6, 21, 3, 5, 21, 5, 2, 21, 2, 6
*/

const GLfloat demo_3_vertex_data[cube_num_points] = {
	// A B C D A

///// Old vertex data:

	/*
	-1.0f, -1.0f, -1.0f, // triangle 1: begin
	-1.0f, -1.0f, 1.0f,
	-1.0f, 1.0f, 1.0f, // triangle 1: end

	1.0f, 1.0f, -1.0f, // triangle 2: begin
	-1.0f, -1.0f, -1.0f,
	-1.0f, 1.0f, -1.0f, // triangle 2: end

	1.0f, -1.0f, 1.0f,
	-1.0f, -1.0f, -1.0f,
	1.0f, -1.0f, -1.0f,

	1.0f, 1.0f, -1.0f,
	1.0f, -1.0f, -1.0f,
	-1.0f, -1.0f, -1.0f,

	-1.0f, -1.0f, -1.0f,
	-1.0f, 1.0f, 1.0f,
	-1.0f, 1.0f, -1.0f,

	1.0f, -1.0f, 1.0f,
	-1.0f, -1.0f, 1.0f,
	-1.0f, -1.0f, -1.0f,

	-1.0f, 1.0f, 1.0f,
	-1.0f, -1.0f, 1.0f,
	1.0f, -1.0f, 1.0f,

	1.0f, 1.0f, 1.0f,
	1.0f, -1.0f, -1.0f,
	1.0f, 1.0f, -1.0f,

	1.0f, -1.0f, -1.0f,
	1.0f, 1.0f, 1.0f,
	1.0f, -1.0f, 1.0f,

	1.0f, 1.0f, 1.0f,
	1.0f, 1.0f, -1.0f,
	-1.0f, 1.0f, -1.0f,

	1.0f, 1.0f, 1.0f,
	-1.0f, 1.0f, -1.0f,
	-1.0f, 1.0f, 1.0f,

	1.0f, 1.0f, 1.0f,
	-1.0f, 1.0f, 1.0f,
	1.0f, -1.0f, 1.0f
	*/

/////


		/*
		top_left_x, 0.0f, z,
		top_left_x + width, 0.0f, z,
		top_left_x, -height, z,

		top_left_x, -height, z,
		top_left_x + width, -height, z,
		top_left_x + width, 0.0f, z
		*/

		/*
		0.0f, 0.0f, z,
		width, 0.0f, z,
		0.0f, -height, z,

		0.0f, -height, z,
		width, -height, z,
		width, 0.0f, z
		*/

		/*
		-s, s, 0.0f,
		s, s, 0.0f,
		-s, -s, 0.0f,

		-s, -s, 0.0f,
		s, -s, 0.0f,
		s, s, 0.0f
		*/

/////

		/*
		top_left_x, top_left_y, z,
		top_left_x + width, top_left_y, z,
		top_left_x, top_left_y - height, z,

		top_left_x, top_left_y - height, z,
		top_left_x + width, top_left_y - height, z,
		top_left_x + width, top_left_y, z
		*/
	
/////

	(void) top_left_corner;
	// const float half_width = width / 2.0f, half_height = height / 2.0f;

	/*
	1____0
	|  . |
	2____|


	0___1
	|   /
	|  /
	| /
	2/
	*/

	/*
	Top left corner at {0, 0}
	*/

/////

		/*
		0.0f, 0.0f, far,
		1.0f, 0.0f, far,
		0.0f, 0.0f, near
		*/

		/*
		-s, s, 0.0f,
		s, s, 0.0f,
		-s, -s, 0.0f,
		*/

		/*
		-1.0f, -1.0f, 0.0f,
		1.0f, -1.0f, 0.0f,
		0.0f, 1.0f, 0.0f
		*/

		/*
		0.0f, height, far,
		0.0f, height, near,
		1.0f, height, far
		*/

/////

	/*
	GLfloat
		*const plane_vertices = create_vert_plane(top_left_corner, size_hori, size_vert),
		*const uv_data = create_uv_for_plane(size_hori, size_vert);

	sgl.num_vertex_buffers = 2;
	sgl.vertex_buffers = init_vbos(sgl.num_vertex_buffers,
		plane_vertices, plane_vertex_bytes,
		uv_data, plane_uv_bytes);

	free(plane_vertices);
	free(uv_data);
	*/

/////

Functions to make:
- void create_cuboid(const vec3 origin, const vec3 size);
actually, instead of create_cuboid, make a make_planes fn (since sector meshes will not exactly be rectangles)
- GLfloat* join_plane_vertices(const GLfloat* const plane_1, const GLfloat* const plane_2);

/////

void draw_triangles(const int num_triangles) {
	glDrawArrays(GL_TRIANGLE_STRIP, 0, 4); // num_triangles * 3
	// glDrawArraysInstanced(GL_TRIANGLES, 0, num_triangles * 3, 1);
	// glDrawElements(GL_TRIANGLES, num_triangles * 3, GL_UNSIGNED_INT, NULL);
	// GL_ERR_CHECK;
}

/////

	/////
	glGenBuffers(sgl.num_vertex_buffers, &sgl.vertex_buffers);
	glBindBuffer(GL_ARRAY_BUFFER, sgl.vertex_buffers);
	glBufferData(GL_ARRAY_BUFFER, interleaved_plane_bytes, plane_data, GL_STATIC_DRAW);
	/////

/////

	/*
	.A B C
	C B D
	C D D - deg
	D D E - deg
	D E E - deg
	E E F - deg
	E F G
	G F H

	in as {A, B, C, D,
		D, E,
		E, F, G, H} to gpu

	plane_1 = {A, B, C, D}, plane_2 = {E, F, G, H};

	B--D    F--H
	|\ |    |\ |
	| \|    | \|
	A--C    E--G

	Whoops, theirs were like that
	Retrying
	*/

	/*
	New order:
	0 1 2
	1 2 3

	2 3 4
	3 4 5

	3 4 5
	4 5 6
	*/

/////

/*
Only join if next to each other:


0__1
|  /
| /
2/

    2
   /|
  / |
1/__3

2__4
|  /
| /
3/
*/

///// A programmatic plane creator (didn't work, but only discarding b/c hard to maintain):

	void (*const plane_creators[3])(PLANE_CREATOR_SIGNATURE) = {
		PLANE_CREATOR_NAME(vert_2), PLANE_CREATOR_NAME(hori), PLANE_CREATOR_NAME(vert_1)
	};

	int i = 0;
	for (byte varied_axis = 0; varied_axis < 3; varied_axis++) {
		const byte size_axis_x = (varied_axis == 0) * 2, size_axis_y = (varied_axis == 1) + 1;
		void (*const plane_creator)(PLANE_CREATOR_SIGNATURE) = plane_creators[varied_axis];

		plane_creator(origin, size[size_axis_x], size[size_axis_y], sector_mesh + i);
		i++;
		origin[varied_axis] += size[varied_axis];
		plane_creator(origin, size[size_axis_x], size[size_axis_y], sector_mesh + i);
		origin[varied_axis] -= size[varied_axis];
		i++;
	}

///// Old hori plane creation:

	PLANE_CREATOR_NAME(hori)(origin, size[0], size[2], sector_mesh + vars_per_plane * 2);
	origin[1] -= size[1];
	PLANE_CREATOR_NAME(hori)(origin, size[0], size[2], sector_mesh + vars_per_plane * 3);
	origin[1] += size[1];

/////

		/*
		0____1
		\   |
		 \  |
           2

		tri is

		0_1
		| /
		2/

		from other side

		b4: {0.0f, 0.0f}, {size_z, 0.0f}, {0.0f, size_y}
		after: {size_z, 0.0f}, {0.0f, 0.0f}, {0.0f, size_y}
		no
		*/

		/* orig flipped:
		far_x, top_y, near_z, 0.0f, 0.0f,
		far_x, top_y, far_z, size_z, 0.0f,
		far_x, bottom_y, near_z, 0.0f, size_y,
		*/

///// Vertices ordered by triangle pairs:

	const plane_type_t vertices[vars_per_mesh] = {
		// Top triangles aligned along Z axis (each pair in opposite winding order from each other)
		near_x, bottom_y, near_z, 0, size_y,
		near_x, top_y, far_z, size_z, 0,
		near_x, top_y, near_z, 0, 0,
		// gotten

		far_x, top_y, near_z, size_z, 0,
		far_x, top_y, far_z, 0, 0,
		far_x, bottom_y, near_z, size_z, size_y,

		// Bottom triangles aligned along Z axis
		near_x, bottom_y, near_z, 0, size_y,
		near_x, bottom_y, far_z, size_z, size_y,
		near_x, top_y, far_z, size_z, 0,
		// gotten

		far_x, top_y, far_z, 0, 0,
		far_x, bottom_y, far_z, 0, size_y,
		far_x, bottom_y, near_z, size_z, size_y,

		// Top triangles aligned along X axis
		near_x, top_y, near_z, size_x, 0,
		far_x, top_y, near_z, 0, 0,
		near_x, bottom_y, near_z, size_x, size_y,

		near_x, bottom_y, far_z, 0, size_y,
		far_x, top_y, far_z, size_x, 0,
		near_x, top_y, far_z, 0, 0,

		// Bottom triangles aligned along X axis
		far_x, top_y, near_z, 0, 0,
		far_x, bottom_y, near_z, 0, size_y,
		near_x, bottom_y, near_z, size_x, size_y,

		near_x, bottom_y, far_z, 0, size_y,
		far_x, bottom_y, far_z, size_x, size_y,
		far_x, top_y, far_z, size_x, 0,

		// Top triangle aligned along Y axis (flat)
		near_x, top_y, far_z, size_z, size_x,
		far_x, top_y, near_z, 0, 0,
		near_x, top_y, near_z, 0, size_x,

		// Bottom triangle aligned along Y axis (flat)
		near_x, top_y, far_z, size_z, size_x,
		far_x, top_y, far_z, size_z, 0,
		far_x, top_y, near_z, 0, 0

		// No matching degenerate bottom triangle under block here since not needed for sake of culling
	};

/////

void attempt_sector_fill_at(byte* const heightmap, const byte map_width,
	const byte map_height, const byte x, const byte y) {

	(void) heightmap;
	(void) map_width;
	(void) map_height;
	(void) x;
	(void) y;

	const byte height = *map_point(heightmap, x, y, map_width);
	// If the point is a potential corner
	const int top_left_corner_vals[3][2] = {
		{x - 1, y}, {x - 1, y - 1}, {x, y - 1}
	};

	byte corner_heights_not_eq_sum = 0;
	for (byte i = 0; i < 3; i++) {
		const int* const top_left_corner = top_left_corner_vals[i];
		const int x = top_left_corner[0], y = top_left_corner[1];

		if (x < 0 || x >= map_width || y < 0 || y >= map_height || *map_point(heightmap, x, y, map_width) != height)
		corner_heights_not_eq_sum++;
	}

	/*
	byte* const height_ref = map_point(heightmap, x, y, map_width);
	const byte height = *height_ref;
	if (height > 0) {
		SectorArea area = {.height = height};
	}
	*/
}

/////

	if (x < 0 || y < 0 || x >= map_width || y >= map_height) return;

/////

	// Not correct at the moment

	// Attempting expansions

	/*
	while (bottom_right[1] < map_height) {
		while (bottom_right[0] < map_width) {
			if (area_is_valid(&area, map, map_width)) bottom_right[0]++;
			else break;
		}
		if (area_is_valid(&area, map, map_width)) bottom_right[1]++;
	}

	for (byte y = area.origin[1]; y < bottom_right[1]; y++) {
		for (byte x = area.origin[0]; x < bottom_right[0]; x++)
			*map_point(map, x, y, map_width) = 0;
	}

	area.size[0] = bottom_right[0] - area.origin[0];
	area.size[1] = bottom_right[1] - area.origin[1];
	return area;
	*/

/////

// byte bottom_right[2] = {area.origin[0] + area.size[0], area.origin[1] + area.size[1]}; // Stored as {x, y}

///// Old sector code:

byte area_is_valid(const SectorArea* const area, byte* const map, const byte map_width) {
	const byte start_x = area -> origin[0], start_y = area -> origin[1];
	const byte end_x = start_x + area -> size[0], end_y = area -> size[1];

	for (byte y = start_y; y < end_y; y++) {
		for (byte x = start_x; x < end_x; x++) {
			if (*map_point(map, x, y, map_width) != area -> height) return 0;
		}
	}
	return 1;
}

// Corner is top left
SectorArea attempt_area_fill(SectorArea area, byte* const map, const byte map_width, const byte map_height) {
	// Not working correctly yet
	for (byte y = area.origin[1]; y < map_height; y++) {
		for (byte x = area.origin[0]; x < map_width; x++) {
			if (area_is_valid(&area, map, map_width)) area.size[0]++;
			else break;
		}
		if (area_is_valid(&area, map, map_width)) area.size[1]++;
		else break;
	}

	for (byte y = area.origin[1]; y < area.origin[1] + area.size[1]; y++) {
		for (byte x = area.origin[0]; x < area.origin[0] + area.size[0]; x++)
			*map_point(map, x, y, map_width) = 0;
	}

	return area;
}

///// Some 6-vertex vertices for a flat vert tomato:

	const plane_type_t triangle_vertices[30] = {
		near_x, bottom_y, near_z, 0, size_y,
		near_x, top_y, far_z, size_z, 0,
		near_x, top_y, near_z, 0, 0,

		near_x, bottom_y, near_z, 0, size_y,
		near_x, bottom_y, far_z, size_z, size_y,
		near_x, top_y, far_z, size_z, 0
	};

///// Stuff:

	const plane_type_t origin[3] = {0, 2, 0}, size[3] = {2, 1, 4};
	const plane_type_t near_x = origin[0], top_y = origin[1], near_z = origin[2], size_x = size[0], size_y = size[1], size_z = size[2];
	const plane_type_t far_x = near_x + size_x, bottom_y = top_y - size_y, far_z = near_z + size_z;

	// const plane_type_t width = 3, height = 2;
	// const plane_type_t width = size_y, height = size[0];
	// const plane_type_t width = size_z, height = size_y;

	const plane_type_t triangle_vertices[] = {
		

		/*
		near_x, top_y, near_z, 0, 0,
		far_x, top_y, near_z, 0, size_x,
		near_x, bottom_y, near_z, size_y, 0
		*/

		/*
		near_x, bottom_y, near_z, 0, size_y,
		near_x, top_y, far_z, size_z, 0,
		near_x, top_y, near_z, 0, 0,
		near_x, bottom_y, far_z, size_z, size_y
		*/

		/*
		near_x, top_y, far_z, 0.0f, 0.0f,
		near_x, top_y, near_z, width, 0.0f,

		near_x, bottom_y, far_z, 0.0f, height,
		near_x, bottom_y, near_z, width, height
		*/


		/*
		near_x, bottom_y, near_z, 0, size_y,
		near_x, top_y, far_z, size_z, 0,
		near_x, top_y, near_z, 0, 0,

		near_x, bottom_y, near_z, 0, size_y,
		near_x, bottom_y, far_z, size_z, size_y,
		near_x, top_y, far_z, size_z, 0
		*/
	};

////// The old vertices for the billboard:

	const billboard_type_t top_left_corner[3] = {2, 3, 1}, size[3] = {1, 2, 1};

	const billboard_type_t
		near_x = top_left_corner[0], top_y = top_left_corner[1], near_z = top_left_corner[2],
		size_y = size[1], size_z = size[2];

	const billboard_type_t bottom_y = top_y - size_y, far_z = near_z + size_z;

	const billboard_type_t vertices[20] = {
		near_x, top_y, near_z, 0, 0,
		near_x, top_y, far_z, size_z, 0,

		near_x, bottom_y, near_z, 0, size_y,
		near_x, bottom_y, far_z, size_z, size_y
	};

/////

	/*
	const billboard_type_t top_left_corner[3] = {0.5, 0.5, 0.0}, size[3] = {0.5, 0.5, 0.5};

	const billboard_type_t
		near_x = top_left_corner[0], top_y = top_left_corner[1], near_z = top_left_corner[2],
		size_y = size[1], size_z = size[2];

	const billboard_type_t bottom_y = top_y - size_y, far_z = near_z + size_z;

	const billboard_type_t vertices[] = {
		near_x, top_y, near_z,
		near_x, top_y, far_z,

		near_x, bottom_y, near_z,
		near_x, bottom_y, far_z
	};

	for (int i = 0; i < 12; i++) {
		printf("%f ", (double) vertices[i]);
		if (i == 2 || i == 5 || i == 8 || i == 11) printf("\n");
	}
	*/

/////

	#define PRINT_MAT(m)\
		for (int y = 0; y < 4; y++) {\
			for (int x = 0; x < 4; x++)\
				printf("%lf ", (double) m[y][x]);\
			putchar('\n');\
		} putchar('\n');

/////

/*
- Billboards
- Next step: set uniform vars
- http://www.opengl-tutorial.org/intermediate-tutorials/billboards-particles/billboards/#solution-3--the-fixed-size-3d-way
- https://github.com/opengl-tutorials/ogl/tree/master/tutorial18_billboards_and_particles
*/

/*
- Have 4 corners of sprite
- Can get right vec and up vec in shader

E = player vector
P = billboard vector
F = player-billboard-delta vector = P - E
R = right vector = global up vector crossed with F
U = up vector = F crossed with R

Top right corner = U + R
Top left corner = U - R
Bottom left corner = -U - R
Bottom right corner = R - U
*/

/////

		center[0] - half_size[0], center[1] - half_size[1],
		center[0] + half_size[0], center[1] - half_size[1],

		center[0] - half_size[0], center[1] + half_size[1],
		center[0] + half_size[0], center[1] + half_size[1]
		/*

///// Some manual frustum stuff:

	/*
	glm_vec3s_add((vec3) {1, 0, 0}, b, c);
	glm_vec3s_add(c, glms_vec3_cross(a, b, c), c);
	*/

	/*
	near.normal = pos + dir * near_clip
	far.normal = pos + dir * far_clip
	(left, right, top, bottom).normal = pos
	near.dist = 
	*/

	/*
	const GLfloat
		*const pos = camera -> pos, *const dir = camera -> dir,
		near_clip = camera -> clip_dists.near, far_clip = camera -> clip_dists.far;

	const GLfloat
		dir_times_far_clip[3] = {dir[0] * far_clip, dir[1] * far_clip, dir[2] * far_clip},
		half_far_clip_rect_height = far_clip * tanf(camera -> vert_fov * 0.5f);

	const GLfloat half_far_clip_rect_width = half_far_clip_rect_height * camera -> aspect_ratio;


	Frustum frustum = {
		.near = {{pos[0] + dir[0] * near_clip, pos[1] + dir[1] * near_clip, pos[2] + dir[2] * near_clip}, -1.0f},
		.far = {{pos[0] + dir_times_far_clip[0], pos[1] + dir_times_far_clip[1], pos[2] + dir_times_far_clip[2]}, -1.0f},

		.left = {{pos[0], pos[1], pos[2]}, -1.0f},
	};

/////

typedef struct {
	const GLfloat normal[3], dist; // Dist from origin to nearest point on plane
} Plane;

typedef struct {
	// const Plane near, far, left, right, top, bottom;

} Frustum;

///// An attempt at something branchless for movement:

	// const GLfloat* move_dir, speed;
	// const GLfloat* move_dirs[2] = {dir, camera -> right}, speeds[2] = {actual_speed, -actual_speed};


	const GLfloat* const move_dir =
		(keys[constants.movement_keys.forward] || keys[constants.movement_keys.backward]) ? dir : camera -> right,

	speed = (keys[constants.movement_keys.])


	// const GLfloat* const move_dir = ((GLfloat*[2]) {dir, camera -> right})[0];


	/*
	if (keys[constants.movement_keys.forward]) {
		move_dir =
	}

/////

	/* The vertex shader needs a dummy input here - the vertex ID
	could be gotten through gl_VertexID, but this only ranges from 0 to 3,
	which fits within the domain needed to access vertices_model_space */
	"layout(location = 0) in int vertex_id;"

/////

		/* Swizzle arrangements:
		flat: xz for demo 14, but actually something else not found
		vert 1:
		vert 2:

		tried: yz, xy, zy, yz */

/////

const char* const demo_15_vertex_shader =
    "#version 330 core\n"

    "layout(location = 0) in vec3 vertex_pos_model_space;\n"
    "out vec3 UV_3D;\n"
    "uniform mat4 M, MVP;\n" // model, model-view-projection

    "void main() {\n"
        "vec4 pos = MVP * vec4(vertex_pos_model_space, 1.0);\n"
        "gl_Position = pos.xyww;\n"

        // Perhaps just vertex_pos_model_space
        "UV_3D = vec3(model * vec4(vertex_pos_model_space, 1.0));\n"
    "}\n",

*const demo_15_fragment_shader =
    "#version 330 core\n"

    "in vec3 UV_3D;\n"
    "out vec4 color;\n"
    "uniform samplerCube skybox;\n"

    "void main() {\n"
        "color = texture(skybox, UV_3D);\n"
    "}\n";

/////

	/*
	for (int y = 0; y < 4; y++) {
		for (int x = 0; x < 4; x++) {
			printf("%lf ", (double) camera.view_projection[y][x]);
		}
		puts("|");
	}
	puts("---");

/////

// Skybox is a cubemap
GLuint init_skybox_texture(const char* const path) {
	// Start with same 6 faces

	/*
	const char* const paths[6] = {
		"assets/right.bmp",
		"assets/left.bmp",
		"assets/top.bmp",
		"assets/bottom.bmp",
		"assets/front.bmp",
		"assets/back.bmp"
	};
	*/

	GLuint skybox;
	glGenTextures(1, &skybox);
	glBindTexture(GL_TEXTURE_CUBE_MAP, skybox);

	glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_MAG_FILTER, OPENGL_TEX_MAG_FILTER);
	glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_MIN_FILTER, OPENGL_SKYBOX_TEX_MIN_FILTER);
	glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_WRAP_S, tex_nonrepeating);
	glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_WRAP_T, tex_nonrepeating);
	glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_WRAP_R, tex_nonrepeating);

	SDL_Surface* const surface = init_surface(path);
	const void* const pixels = surface -> pixels;
	const GLint surface_size[2] = {64, 64}; // surface -> w, surface -> h};
	GL_ERR_CHECK;

	// right, left, top, bottom, back, front

	const GLsizei cube_size = surface_size[0] >> 2;

	/*
	const GLint origin_1[2] = {0, cube_size};

	glTexImage2D(GL_TEXTURE_CUBE_MAP,
		0, OPENGL_INTERNAL_PIXEL_FORMAT, surface_size[0],
		surface_size[1], 0, OPENGL_INPUT_PIXEL_FORMAT,
		OPENGL_COLOR_CHANNEL_TYPE, pixels);
	*/
	
	for (byte i = 0; i < 6; i++) { // "../../../assets/walls/hieroglyph.bmp"
		/*
		glTexSubImage2D(GL_TEXTURE_CUBE_MAP_POSITIVE_X + i,
			0, origin_1[0], origin_1[1], cube_size, cube_size,

			OPENGL_INPUT_PIXEL_FORMAT, OPENGL_COLOR_CHANNEL_TYPE, pixels
		);
		*/

		glTexImage2D(GL_TEXTURE_CUBE_MAP_POSITIVE_X + i,
			0, OPENGL_INTERNAL_PIXEL_FORMAT,
			surface_size[0], surface_size[1], 0, OPENGL_INPUT_PIXEL_FORMAT,
			OPENGL_COLOR_CHANNEL_TYPE, surface -> pixels);
		
		GL_ERR_CHECK;
	}
	deinit_surface(surface);

	glGenerateMipmap(GL_TEXTURE_CUBE_MAP);

	return skybox;
}

/////

	/*
	const char* const paths[6] = {
		"assets/right.bmp",
		"assets/left.bmp",
		"assets/top.bmp",
		"assets/bottom.bmp",
		"assets/front.bmp",
		"assets/back.bmp"
	};

	(void) path;
	GLuint skybox;
	glGenTextures(1, &skybox);
	glBindTexture(GL_TEXTURE_CUBE_MAP, skybox);

	glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_MAG_FILTER, OPENGL_TEX_MAG_FILTER);
	glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_MIN_FILTER, OPENGL_SKYBOX_TEX_MIN_FILTER);
	glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_WRAP_S, tex_nonrepeating);
	glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_WRAP_T, tex_nonrepeating);
	glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_WRAP_R, tex_nonrepeating);

	for (byte i = 0; i < 6; i++) {
		SDL_Surface* const surface = init_surface(paths[i]);

		glTexImage2D(GL_TEXTURE_CUBE_MAP_POSITIVE_X + i,
			0, OPENGL_INTERNAL_PIXEL_FORMAT,
			surface -> w, surface -> h, 0, OPENGL_INPUT_PIXEL_FORMAT,
			OPENGL_COLOR_CHANNEL_TYPE, surface -> pixels);

		deinit_surface(surface);
	}

	glGenerateMipmap(GL_TEXTURE_CUBE_MAP);

	return skybox;
	*/

/////

			/*
			memset(face_pixels + y * pitch, 0xF0F8FF / (y + 1), row_bytes); // works
			memset(face_pixels + y * pitch, 0xF0F8FF, row_bytes); // works
			*/

			/*
			const void* dest = face_pixels + y * row_bytes;

			int src_start = y + cube_size;
			const void* src = skybox_pixels + src_start * row_bytes;

			memcpy(dest, src, row_bytes);
			*/

/////

		for (int y = 0; y < cube_size; y++) {
			// pitch = width * 4
			const int pitch = cube_size * 4;

			Uint32* dest = read_texture_row(face_pixels, pitch, y);
			Uint32* src = read_texture_row(skybox_pixels, pitch, y);		

			memcpy(dest + 1, src, row_bytes);

			/*
			Uint32* dest = read_texture_row(face_pixels, pitch, y);
			Uint32* src = read_texture_row(face_pixels, pitch, y + cube_size);
			*/

			/*
			void* const ndest = face_pixels + y * pitch, *nsrc = skybox_pixels + (y) * pitch;
			memcpy(ndest, nsrc, row_bytes);
			*/
		}

/////

/* right = GL_TEXTURE_CUBE_MAP_POSITIVE_X
left = GL_TEXTURE_CUBE_MAP_NEGATIVE_X

top = GL_TEXTURE_CUBE_MAP_POSITIVE_Y
bottom = GL_TEXTURE_CUBE_MAP_NEGATIVE_Y

back = GL_TEXTURE_CUBE_MAP_POSITIVE_Z
front = GL_TEXTURE_CUBE_MAP_NEGATIVE_Z */

/////

// This demo asserts that batching + culling work

#include "demo_11.c"
#include "../sector.c"
#include "../batch.c"
#include "../camera.c"

StateGL demo_17_init(void) {
	StateGL sgl = {.vertex_array = init_vao()};



	/*
	const plane_type_t origin[3] = {1, 2, 2}, size[3] = {1, 2, 3};
	plane_type_t* const cuboid_mesh = create_sector_mesh(origin, size);

	sgl.num_vertex_buffers = 1;
	sgl.vertex_buffers = init_vbos(sgl.num_vertex_buffers, cuboid_mesh, bytes_per_mesh);
	bind_interleaved_planes_to_vao();

	free(cuboid_mesh);

	sgl.shader_program = init_shader_program(demo_4_vertex_shader, demo_4_fragment_shader);
	sgl.num_textures = 1;
	sgl.textures = init_textures(sgl.num_textures, "../../../assets/walls/pyramid_bricks_3.bmp", tex_repeating);
	select_texture_for_use(sgl.textures[0], sgl.shader_program);

	enable_all_culling();
	*/

	return sgl;
}

void demo_17_drawer(const StateGL* const sgl) {
	(void) sgl;
	static Camera camera;
	static Camera camera;
	static Batch batch;
	static GLint model_view_projection_id;
	static byte first_call = 1;

	/*
	static Camera camera;
	static Batch batch;
	static GLint model_view_projection_id;
	static byte first_call = 1;

	if (first_call) {
		init_camera(&camera, (vec3) {0.0f, 0.0f, 0.0f});
		model_view_projection_id = glGetUniformLocation(sgl -> shader_program, "model_view_projection");
		first_call = 0;
	}
	update_camera(&camera);
	glUniformMatrix4fv(model_view_projection_id, 1, GL_FALSE, &camera.model_view_projection[0][0]);

	glClearColor(0.2f, 0.4f, 0.6f, 0.0f);
	draw_triangles(triangles_per_mesh);
	*/
}

#ifdef DEMO_17
int main(void) {
	make_application(demo_17_drawer, demo_17_init, deinit_demo_vars);
}
#endif

/////

#include "../utils.c"
#include "../sector.c"
#include "../batch.c"
#include "../camera.c"

/*
typedef struct {
	GLsizei num_textures;
	GLuint vao, *const textures, shader;
	Batch batch;
} StateDemo17;

void demo_17_drawer(const StateDemo17* const s) {
	static byte first_call = 1;
	static Camera camera;

	if (first_call) {
		init_camera(&camera, (vec3) {0.0f, 0.0f, 0.0f});
		first_call = 0;
	}

	glClearColor(0.8f, 0.8f, 0.5f, 0.0f);

	(void) s;
}

StateDemo17 init_state_demo_17(void) {
	StateDemo17 s;

	glGenVertexArrays(1, &s.vao);
	glBindVertexArray(s.vao);

	return s;
}

void deinit_state_demo_17(const StateDemo17* const s) {
	glDeleteTextures(s -> num_textures, rs -> textures);
	deinit_batch(&s -> batch);
	glDeleteVertexArrays(1, &s -> vao);
}

// #ifdef DEMO_17
int main(void) {
	Screen screen = init_screen("Culling Demo");

	const int max_delay = 1000 / constants.fps;
	(void) max_delay;

	SDL_Event event;
	keys = SDL_GetKeyboardState(NULL);
	byte running = 1;

	StateDemo17 s = init_state_demo_17();

	while (running) {
		const Uint32 before = SDL_GetTicks();

		while (SDL_PollEvent(&event)) {
			if (event.type == SDL_QUIT) running = 0;
		}

		glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
		demo_17_drawer(&s);
		SDL_GL_SwapWindow(screen.window);
		const int wait = max_delay - (SDL_GetTicks() - before);
		if (wait > 0) SDL_Delay(wait);
	}

	deinit_state_demo_17(&s);
	deinit_screen(&screen);
}
// #endif
*/

/////

	/*
	sgl.num_vertex_buffers = sectors.length;
	sgl.vertex_buffers = malloc(sgl.num_vertex_buffers * sizeof(GLuint));
	glGenBuffers(sgl.num_vertex_buffers, sgl.vertex_buffers);
	*/

	/*
	sgl.num_vertex_buffers = 0;

	for (int i = 0; i < sector_list.length; i++) {
		Sector* const sector = sector_list.sectors + i;

		// glGenBuffers(1, &sector -> vbo);
		// sector -> vbo = sgl.vertex_buffers[i];
		const plane_type_t origin[3] = {area.origin[0], area.height, area.origin[1]};

		plane_type_t* mesh;
		byte mesh_bytes;

		if (area.height == 0) { // Flat sector
			mesh = create_height_zero_mesh(origin, area.size);
			mesh_bytes = bytes_per_height_zero_mesh;
		}
		else {
			const plane_type_t size[3] = {area.size[0], area.height, area.size[1]};
			mesh = create_sector_mesh(origin, size);
			mesh_bytes = bytes_per_mesh;
		}

		glBindBuffer(GL_ARRAY_BUFFER, sector -> vbo);
		glBufferData(GL_ARRAY_BUFFER, mesh_bytes, mesh, GL_STATIC_DRAW);

		// free(mesh);
	}
	*/

/////

// printf("%d, %d, %d\n", (intO 0.89f / 1 * 255, 0.854f / 1 * 255, 0.788f / 1 * 255);

/////
		/*
		"float depth = gl_FragCoord.z / gl_FragCoord.w;\n"
		"float l = 1.0f / gl_ClipDistance;\n"
		"light_intensity;\n"
		*/

/////

		/*
		if (height_diff != 0) {
			Face face;

			if (height_diff > 0) {
				printf("Sector is over other sector by %d\n", height_diff);
			}
			else if (height_diff < 0) {
				printf("Sector is under other sector by %d; no face column\n", -height_diff);
			}
		}
		last_height_diff = height_diff;
		*/

/////

/*
void generic_init_vert_ew_faces(const Sector sector, byte* const heightmap, const byte map_width,
	const byte map_height, const byte is_bottom_side) {

	const byte start_x = sector.origin[0];
	byte start_y = sector.origin[1];

	if (is_bottom_side) {
		start_y += sector.size[1] - 1;

		DEBUG(sector.origin[1], d);
		DEBUG(sector.size[1], d);
		DEBUG(start_y, d);
		if (start_y == map_height - 1) return;
	}
	else if (start_y == 0) return;

	//////////

	const byte adjacent_y = start_y + (is_bottom_side ? 1 : -1);
	byte face_skippable = 0;

	int16_t last_height_diff = 0;
	Face curr_face = {Vert_EW, {start_x, start_y}, {1, 0}};

	for (byte x = start_x; x < start_x + sector.size[0]; x++) {
		const byte height = *map_point(heightmap, x, adjacent_y, map_width);
		const int16_t height_diff = sector.height - height;

		const byte not_skippable_before = !face_skippable;
		face_skippable = height_diff <= 0;

		if (not_skippable_before && face_skippable) {
			puts("Continuity error");
		}

		if (!face_skippable) {
			if (height_diff == last_height_diff) curr_face.size[0]++;
			else {
				if (last_height_diff != 0) {
					print_face(curr_face, "Face: ");
					curr_face.origin[0] = x;
					curr_face.size[0] = 1;
				}
				curr_face.size[1] = height_diff;
			}
		}
		last_height_diff = height_diff;
	}
	if (!face_skippable) print_face(curr_face, "End face: ");
}
*/

// Assumes that the faces are vertical
/*
void init_vert_ew_faces(const Sector sector, byte* const heightmap, const byte map_width) {
	// == edge
	if (sector.origin[1] == 0) return;

	// Side decr
	const byte y_above = sector.origin[1] - 1;

	byte face_skippable = 1;

	int16_t last_height_diff = 0;
	Face curr_face = {Vert_EW, {sector.origin[0], sector.origin[1]}, {1, 0}};

	for (byte x = sector.origin[0]; x < sector.origin[0] + sector.size[0]; x++) {
		const byte height = *map_point(heightmap, x, y_above, map_width);
		const int16_t height_diff = sector.height - height;

		const byte had_face_before = !face_skippable;
		face_skippable = height_diff <= 0;

		if (face_skippable && had_face_before) {
			puts("Catch it");
			print_face(curr_face, "Face: ");
			curr_face.origin[0] = x;
			curr_face.size[0] = 1; // top-down x
		}

		else if (!face_skippable) {
			if (height_diff == last_height_diff) curr_face.size[0]++;
			else {
				if (last_height_diff != 0) { // Add face to list here
					print_face(curr_face, "Face: ");
					curr_face.origin[0] = x;
					curr_face.size[0] = 1; // top-down x
				}
				curr_face.size[1] = height_diff; // top-down y
			}
		}
		last_height_diff = height_diff;
	}

	if (!face_skippable) print_face(curr_face, "End face: ");
}
*/

/////

	/*
	if (!is_top) next_face.origin[1] += sector.size[1];

	byte adjacent_y = next_face.origin[1];

	DEBUG(is_top, d);

	if (is_top && adjacent_y-- == 0) return;
	else if (adjacent_y == map_height) {
		// DEBUG(is_top, d);
		return;
	}
	*/

/////

/*
void create_flat_mesh(const mesh_type_t origin[2], const mesh_type_t size[2], mesh_type_t* const dest) {
	(void) origin;
	(void) size;
	(void) dest;
}

void create_vert_ns_mesh(const mesh_type_t origin[2], const mesh_type_t size[2], mesh_type_t* const dest) {
	(void) origin;
	(void) size;
	(void) dest;
}

void create_vert_ew_mesh(const mesh_type_t origin[2], const mesh_type_t size[2], mesh_type_t* const dest) {
	(void) origin;
	(void) size;
	(void) dest;
}
*/

/////

				/*
				1, 2, 3, 4, 5,
				6, 7, 8, 9, 10,
				11, 12, 13, 14, 15,

				16, 17, 18, 19, 20,
				21, 22, 23, 24, 25,
				26, 27, 28, 29, 30
				*/

/////

			/*
			For flat, origin[0] = x, sector.height = y, origin[1] = z
			_______
			|     |
			|     |
			|_____|

			origin size[0] top down, and size[1] depth
			*/

/////

			/*
			For flat, origin[0] = x, sector.height = y, origin[1] = z
			_____
			|   |
			|___|
			*/


			/*
			Note: x across top-down is also x across in 3D
			origin
			|

			For vert ns,
				origin[0] = x,
				sector.height = top_y,
				sector.height - size[1] = bottom_y,
				origin[1] = near_z (which is top z),
				origin[1] - size[0] = far_z
			*/

			/*
			origin -

			For vert ew,
				origin[0] = near_x,
				sector.height = top_y,
				sector.height - size[1] = bottom_y
				origin[1] = near_x (which is left x),
				origin[1] - size[0] = far_x (which is right_x)
			*/

///// Some UV stuff:

			/*
				near_x, sector_height, far_z, 1, 0,
				far_x, sector_height, near_z, 0, 1,
				near_x, sector_height, near_z, 1, 1,

				near_x, sector_height, far_z, 1, 0,
				far_x, sector_height, far_z, 0, 0,
				far_x, sector_height, near_z, 0, 1
				*/

				/*
				near_x, sector_height, far_z, size_z, size_x,
				far_x, sector_height, near_z, 0, 0,
				near_x, sector_height, near_z, 0, size_x,

				near_x, sector_height, far_z, size_z, size_x,
				far_x, sector_height, far_z, size_z, 0,
				far_x, sector_height, near_z, 0, 0
				*/

/////

	/*
	Visible face sides:

	Bottom = invisible
	Top = visible
	Right = invisible
	Left = visible

	Find alternate face orientations, and switch between, or programatically swizzle vars in it

	With normal vert NS: bottom = invisible, and top UV is correct.
	With alternative vert NS: bottom = visible + correct UVs, and top is invisible.
	*/

///// Heightmap modification based on perlin noise from the main project:

	for (int y = 0; y < terrain_height - 1; y++) {
		printf("\t{");
		for (int x = 0; x < terrain_width - 1; x++) {

			byte* val = map_point((byte*) terrain_map, x, y, terrain_width);
			int smaller = *val - 40;
			if (smaller < 0) smaller = 0;

			int v = fabs(tan(*val / 16.0) / 3.0) * *val;
			if (v > 255) v = 255;
			*val = v;

			printf("%d%s", *val, (x == terrain_width - 2) ? "" : ", ");
		}
		puts("},");
	}

/////

	/*
	const GLsizeiptr total_index_bytes = num_faces * indices_per_face * sizeof(index_type_t);
	GLuint* const cpu_index_buffer = malloc(total_index_bytes);
	for (size_t i = 0; i < num_faces; i++) {
		const int s = i * 4;

		const GLuint index_set_1[6] =
			// {s, s + 1, s + 2, s + 1, s + 3, s + 2};
			{s, s + 1, s + 2, s, s + 3, s + 1};

		for (int j = 0; j < 6; j++) printf("%d ", index_set_1[j]);
		putchar('\n');
	
		memcpy(cpu_index_buffer + i * 6, index_set_1, sizeof(index_set_1));
	}

	glGenBuffers(1, &sector_list -> ibo);
	glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, sector_list -> ibo);
	glBufferData(GL_ELEMENT_ARRAY_BUFFER, total_index_bytes, cpu_index_buffer, GL_STATIC_DRAW);

	free(cpu_index_buffer);
	*/

	/*
	const GLuint num_indices = 6 * face_mesh_list.length;
	// DEBUG(face_mesh_list.length, d);
	for (int i = 0; i < 3; i++) {
		GLuint index_set_1[6] = {i, i + 1, i + 2, i, i + 3, i + 1};

		for (int i = 0; i < 6; i++) {
			printf("%d ", index_set_1[i]);
		}
		putchar('\n');
	}
	*/

/////

	/*
	for (int i = 0; i < 6; i++) printf("%d, ", index_set[i]);
	putchar('\n');
	*/

	/*
	TODO: add to index list here

	const GLuint index_set_1[6] =
		// {s, s + 1, s + 2, s + 1, s + 3, s + 2};
		{s, s + 1, s + 2, s, s + 3, s + 1};

	flat || vert ns first || vert ew second -> 0, 1, 2, 0, 3, 1
	vert ns second || vert ew first -> 0, 1, 2, 1, 3, 2

	- If second variant, add 1 to entry[3] and entry[5]
	- How to find start of ibo indices here?
	*/

/////

	/*
	ibo entries:
		flat:
			0, 1, 2, 0, 3, 1
		vert ns, first side:
			0, 1, 2, 0, 3, 1
		vert ns, second side:
			0, 1, 2, 1, 3, 2
		vert ew, first side:
			0, 1, 2, 1, 3, 2
		vert ew, second side:
			0, 1, 2, 0, 3, 1
	*/

/////


	/*
	DEBUG(total_index_bytes, zu);
	DEBUG(index_list -> length, zu);
	DEBUG(index_list -> length * sizeof(index_type_t[indices_per_face]), zu);
	DEBUG(index_list -> max_alloc * index_list -> item_size, zu);

	puts("Looking in index list");

	index_type_t* data = index_list -> data;
	const GLsizeiptr num_elems = index_list -> length * indices_per_face;
	for (GLsizeiptr i = 0; i < num_elems; i++) {
		printf("i = %td, and other = %d\n", i, data[i]);
	}
	// exit(0);
	*/

///// An attempt at chunk copying of unculled sectors:

	/*
	size_t sector_index = 0, base_index = 0;

	while (sector_index < sectors.length) {
		const Sector* sector = ((Sector*) sectors.data) + sector_index;

		index_type_t start_ibo_index = sector -> ibo_range.start, range_ibo_index = 0;

		while (sector_index < sectors.length && sector_in_view_frustum(*sector, frustum_planes)) {
			range_ibo_index += sector -> ibo_range.length;
			base_index += sector -> ibo_range.length;

			sector_index++;
			sector++;
		}

		printf("%d -> %d\n", start_ibo_index, range_ibo_index);
		DEBUG(base_index, d);

		if (range_ibo_index != 0) {
			memcpy(ibo_ptr + base_index, indices + start_ibo_index,
				range_ibo_index * sizeof(index_type_t));
		}
		else sector_index++;
	}
	*/

///// Non-chunked copying:

		/*
		const Sector sector = ((Sector*) sectors.data)[i];
		if (sector_in_view_frustum(sector, frustum_planes)) {
			// printf("see from %d -> %d\n", sector.ibo_range.start, sector.ibo_range.length);
			secs++;

			memcpy(ibo_ptr + num_visible_indices, indices + sector.ibo_range.start,
				sector.ibo_range.length * sizeof(index_type_t));

			num_visible_indices += sector.ibo_range.length;
		}
		*/

///// Ptr increment copying - a bit too messy:

	const Sector* sector = (Sector*) sectors.data;
	const Sector* const final_sector = sector + sectors.length - 1;

	while (sector != final_sector) {
		index_type_t num_indices = 0;
		const index_type_t start_index_index = sector -> ibo_range.start;

		/*
		while (sector != final_sector && sector_in_view_frustum(*sector, frustum_planes)) {
			num_indices += sector++ -> ibo_range.length;
		}
		*/

		while (sector_in_view_frustum(*sector, frustum_planes)) {
			num_indices += sector -> ibo_range.length;
			if (++sector == final_sector) goto bob;
		}


		if (num_indices != 0) {
			memcpy(ibo_ptr + num_visible_indices, indices + start_index_index, num_indices * sizeof(index_type_t));
			num_visible_indices += num_indices;
		}

///// UV shit:

		// "if (face_info_bits == 5u) UV = vec2(0.0f);\n"
		// 4u -> nothing
		// 3u -> nothing
		// 2u -> bottom
		// 6u -> top
		// 1u -> right
		// 5u -> left
		// 0u -> flat

		/* no 5u:
		left rev, right good, top good, bottom rev
		5u:
		left good, right good, top good, bottom rev
		6u:
		// left rev, right _, top _, bottom _
		*/

		"if (face_info_bits == 5u || face_info_bits == 2u) {UV.x = 1.0f - UV.x;}\n"

		// top good, bottom bad, right good, left bad - with no side logic
		// `side` indicates top or left. current bad UVs: bottom and left.
		// num for left: Vert_EW and side = 0b110 = 6. num for bottom: Vert_NS and !side = 0b001 = 1.
		// Vert_NS == 1, and Vert_EW == 2.

		// "bool side = bool(face_info_bits & 4u);\n" // side = left or top

		// "if (side && ) UV = vec2(0.0f);\n"

		// "if (side || (!side && face_type == )) {\n"
			// "UV.x = 1.0f - UV.x;\n"
			// "UV = vec2(0, 0);\n"
		// "}\n"

		// "UV = rev_pos.xz;\n" // Bueno for flat face ([0], [2])
		// "UV = rev_pos.zy;\n" // Bueno for right vert NS face ([2], [1])
		// "UV = vec2(1.0f - rev_pos.z, rev_pos.y);\n"// Bueno for left vert NS face (1 - [2], [1])
		// "UV = rev_pos.xy;\n" // Bueno for top vert EW face ([0] [1])
		// "UV = vec2(1.0f - pos_reversed.x, pos_reversed.y);\n" // Bueno for bottom vert EW face (1 - [0], [1])

		// "UV = vec2(pos_reversed.x, pos_reversed.y);\n" // Bueno for bottom vert EW face (1 - [0], [1])
		// "UV.x = 1.0f - UV.x;\n"

/////

- Sectors contain their meshes
- To begin with, don't clip sector heights based on adjacent heights
- Sectors are rectangular

- Not perfect, but sectors + their meshes for clipping and rendering, and texmaps + heightmaps for game logic
- Ideal: BSPs, but not worth time
- To start, one vbo + texture ptr per sector

/////

	/*
	if (sector.height == 4)

	printf("bottom_left = {%d, %d, %d}, top_right = {%d, %d, %d}\n",
		(int) aabb_corners[0][0],
		(int) aabb_corners[0][1],
		(int) aabb_corners[0][2],
		(int) aabb_corners[1][0],
		(int) aabb_corners[1][1],
		(int) aabb_corners[1][2]
	);
	*/

///// A shared-vertex cube didn't work

	const GLbyte
		near_x = origin[0], bottom_y = origin[1], near_z = origin[2],
		size_x = size[0], size_y = size[1], size_z = size[2];

	const GLbyte far_x = near_x + size_x, top_y = bottom_y + size_y, far_z = near_z + size_z;

	// First face first

	const GLbyte vertices[members] = {
		near_x, bottom_y, near_z, // right of front face
		far_x, bottom_y, near_z,
		near_x, top_y, near_z,

		far_x, bottom_y, far_z,

		/*
		near_x, bottom_y, near_z, // Front face
		far_x, bottom_y, near_z,
		near_x, top_y, near_z,
		far_x, top_y, near_z,

		near_x, top_y, far_z, // Top face
		far_x, top_y, far_z,

		near_x, bottom_y, far_z, // Back face
		far_x, bottom_y, far_z,

		near_x, bottom_y, near_z, // Bottom face
		far_x, bottom_y, near_z,

		far_x, top_y, far_z,
		*/
	};

/////

	GLbyte* const cuboid = malloc(members * sizeof(GLbyte));

	const GLbyte top_x = top[0], top_y = top[1], top_z = top[2];
	const GLbyte bottom_x = top_x - size, bottom_y = top_y - size, bottom_z = top_z - size;

	const GLbyte vertices[members] = {
		0, 0, 0,
		1,1,1, -1,1,-1, 1,-1,-1,  -1,-1,1

		/*
		top_x, top_y, top_z,

		top_x, bottom_y, bottom_z,
		bottom_x, top_y, bottom_z,
		bottom_x, bottom_y, top_z
		*/
	};

/////

	DEBUG(sizeof(Sector), zu);
	DEBUG(sizeof(index_type_t), zu);

	DEBUG(sizeof(byte[2]) + sizeof(byte[2]) + sizeof(byte) + sizeof(byte) + 4 + 4, zu);

/////

	/*
	static float s = 0.0f;
	s += 0.05f;
	if (s > (float) M_PI * 2.0f) s = 0.0f;

	Event e = {
		.movement_bits = 0,
		cosf(s) * 50, sinf(s) * 30
	};
	*/

///// Even terrain generation for a heightmap:

	/*
	for (byte y = 0; y < terrain_height; y++) {
		for (byte x = 0; x < terrain_width; x++) {
			// *map_point((byte*) terrain_heightmap, x, y, terrain_width) = fabsf((cosf(x / 5.0f) + sinf(y / 5.0f))) * 5.0f;
			*map_point((byte*) terrain_heightmap, x, y, terrain_width) *= ((x + y) >> 1) / 50.0f;
		}
	}
	*/


/////


	/*
	const size_t billboard_bytes = num_billboards * sizeof(Billboard);
	Billboard* const cpu_billboard_data = malloc(billboard_bytes);

	va_list args;
	va_start(args, num_billboards);
	for (size_t i = 0; i < num_billboards; i++) cpu_billboard_data[i] = va_arg(args, Billboard);
	va_end(args);

	///////////

	glGenBuffers(1, &billboard_list.dbo);
	glBindBuffer(GL_UNIFORM_BUFFER, billboard_list.dbo);
	glBufferData(GL_UNIFORM_BUFFER, billboard_bytes, cpu_billboard_data, GL_STATIC_DRAW);
	free(cpu_billboard_data);

	const GLuint block_index = glGetUniformBlockIndex(billboard_list.shader, "BillboardInfo");
	glBindBufferBase(GL_UNIFORM_BUFFER, 0, billboard_list.dbo);

	GL_ERR_CHECK;

	return billboard_list;
	*/

/////

*const batched_billboard_vertex_shader =
	"#version 330 core\n"

	// Share every 4

	"uniform in BillboardInfo {\n"
		"vec3 pos;\n"
		"int texture_id;\n"
	"} bb_info;\n"

	"out vec2 UV;\n"

	"const vec2 vertices_model_space[4] = vec2[4](\n"
		"vec2(-0.5f, -0.5f), vec2(0.5f, -0.5f),\n"
		"vec2(-0.5f, 0.5f), vec2(0.5f, 0.5f)\n"
	");\n"

	"const vec3 cam_up_world_space = vec3(0.0f, 1.0f, 0.0f);\n"

	"void main() {\n"
		"UV = vec2(0.0f, 0.0f);\n"
	"}\n",

/////

// "struct Billboard {uint texture_id; vec2 billboard_size_world_space; vec3 billboard_center_world_space;};\n"

/////

glClearColor(0.89f, 0.355f, 0.288f, 0.0f); // Light tomato

/////
	
"if (bool(equaling_check)) side = int((face_info & 4) == 0); else side = (face_info & 251) << 2;\n // side = face_info & 251;\n"

/////


		/*
		(face_info & 4 == 0)
		4 = 0b100 = 3rd bit set
		bool side = (3rd bit not set)
		251 = 0b11111011 = 3rd bit not set

		get something where the result is 1 if 3rd bit zero
		*/

		// Top = 1.0f, top or left = 0.8f, bottom or right = 0.6f. `& 4` gets 3rd bit.
		// "bool side = (face_info & 4) == 0, flat_face = first_three_bits == 0;\n" // `side` means flat, top or left

		// For 251, all bits are set except for the third one. If the 3rd bit is 0 in `face_info`, `side` will be 
		// "int side = face_info & 251, flat_face = int(first_three_bits == 0);\n"

		// "int side = face_info & 251;\n"
		// "int side = int((face_info & 4) == 0);\n"

		// Do based on camera facing

		/*
		Need fn that gives 1 if 3rd bit is 0, and 0 if 3rd bit is 1

		Fn for 1 if 3rd bit is 1, and 0 if 3rd bit is 0: (first_three_bits >> 2)

		xor: if only 1 input is true
		*/

/////

	// glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
	// glBlendFunc(GL_SRC_ALPHA, GL_SRC_ALPHA);
	// glBlendFunc(GL_ONE, GL_SRC_ALPHA);
	// glBlendFunc(GL_ONE_MINUS_SRC_ALPHA, GL_ONE);
	glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
	// glBlendFunc(GL_SRC_ALPHA, GL_ONE);
	// Take only color of closest object

/////

// glClearColor(0.29f, 0.555f, 0.588f, 0.0f); // Boring blue

/////

	if (window_resized) {
		int w, h;

		// if ()
	}

	/*
	static int last_w = 0, last_h = 0;
	if (last_w == 0 && last_h == 0) {
		*/

		// puts("here");
		/*
		static SDL_DisplayMode display_mode;
		SDL_GetDesktopDisplayMode(0, &display_mode);
		last_w = display_mode.w;
		last_h = display_mode.h;
		*/

	/*
	static struct {int w, h;} last_win_size = {0, 0};
	if (last_win_size.w == 0 && last_win_size.h == 0) {

	}
	*/

/////

/*
static enum {
	FullScreen, Windowed, TransitionBetween
} window_state = Windowed;
byte holding_key = 0;
*/

/////

static void clear_alpha_for_surface(SDL_Surface* const surface) {
	return;

	/*
	const int w = surface -> w, h = surface -> h;
	const int num_pixels = w * h;

	SDL_SetColorKey(surface, SDL_TRUE, 255);
	// const Uint32 red = SDL_MapRGBA(surface -> format, 255, 0, 0, 255);
	Uint32* const pixels = surface -> pixels;

	for (int i = 0; i < num_pixels; i++) {
		// pixels[i] = red;
		Uint32* const pixel_ref = pixels + i;
		const Uint32 pixel = *pixel_ref;

		if (pixel == 0) {
			// *pixel_ref = SDL_MapRGBA(surface -> format, 255, 255, 255, 255);
			*pixel_ref = 20;
		}
	}


	SDL_SaveBMP(surface, "color.bmp");
	*/
}

/////

	/*
	float magnitude = sqrt(camera -> dir[0] * camera -> dir[0] + camera -> dir[1] * camera -> dir[1] + camera -> dir[2] * camera -> dir[2]);
	DEBUG(magnitude, lf);
	*/

/////

		bad:
		flat = 0
		vert ns, !side (bottom) = 1
		vert ns, side (top) = 5
		vert ew, !side (right) = 2
		vert ew, side (left) = 6

/////

			/*
			"case 1: return vec3(0.0f, 0.0f, 1.0f);\n"
			"case 5: return vec3(0.0f, 0.0f, -1.0f);\n"
			"case 2: return vec3(1.0f, 0.0f, 0.0f);\n"
			"case 6: return vec3(-1.0f, 0.0f, 0.0f);\n"
			"default: return vec3(0.0f, 0.0f, 0.0f);\n"
			*/

/////


	/*
	const byte face_combos[5] = {
		Flat,
		(0 << 2) | Vert_NS,
		(1 << 2) | Vert_NS,
		(0 << 2) | Vert_EW,
		(1 << 2) | Vert_EW
	};

	for (byte i = 0; i < 5; i++) {
		printf("%d ", face_combos[i]);
	}
	putchar('\n');
	*/

/////

	/*
	DEBUG(face_info & 7, d);
	DEBUG((side << 2) | face.type, d);
	puts("-");
	*/

/////

		/*
		good:
		flat = 0
		vert ns, !side (right) = 1
		vert ns, side (left) = 5
		vert ew, !side (bottom) = 2
		vert ew, side (top) = 6

		Side = top or left side
		going down on 2D map increases Z, and going to the right increases X
		*/

///// The old face color determination from the face side and type, and if it's flat:

	// `(x & 4) == 0` checks if the 3rd bit in `x` is set // 4 = 0b100, so if 3rd bit is cleared, face side is flat, top or left.
	// "light = darkest_light + (int((face_info & 4) == 0) + int(first_three_bits == 0)) * light_step;\n"

/////

byte normal_hasher(const byte face_info) {
	// return ceilf(face_info * 0.5f);
	// return face_info * ~face_info;
	/*
	const byte first_three_mask = 7; // 0b111
	return ~face_info & first_three_mask;
	*/

	// if (face_info >= 5) face_info -= 2;
	return face_info - ((face_info >= 5) << 1);
}

/////

	static byte first_call = 1;

	if (first_call) {
		DEBUG(normal_hasher(0), d);
		DEBUG(normal_hasher(1), d);
		DEBUG(normal_hasher(2), d);
		DEBUG(normal_hasher(5), d);
		DEBUG(normal_hasher(6), d);
		first_call = 0;
	}

/////

"return bool(branchy_normal) ? get_normal(face_id_bits) : face_normals[normal_id];\n"

/////

	/*
	Mapping first 3 bits to face normal:

	flat, 0, 0b000: [1] = 1
	right, 1, 0b001: [0] = 1
	left, 5, 0b101: [0] = -1
	bottom, 2, 0b010: [2] = 1
	top, 6, 0b110: [2] = -1
	
	ordered in bit size:
		flat, 0, 0b000: [1] = 1
		right, 1, 0b001: [0] = 1
		bottom, 2, 0b010: [2] = 1
		left, 5, 0b101: [0] = -1
		top, 6, 0b110: [2] = -1

	If 5 or 6, negative mask
	- Find similarities betwen bit patterns and bits set
	- Zeroth bit set:
		Set 0th component to 1 if (last bit == 0), else -1
	- No bits set:
	*/

	"vec3 get_normal(int first_three_bits) {\n"
		"switch (first_three_bits) {\n"
			"case 0: return vec3(0.0f, 1.0f, 0.0f);\n"
			"case 1: return vec3(1.0f, 0.0f, 0.0f);\n"
			"case 2: return vec3(0.0f, 0.0f, 1.0f);\n"
			"case 5: return vec3(-1.0f, 0.0f, 0.0f);\n"
			"case 6: return vec3(0.0f, 0.0f, -1.0f);\n"
			"default: return vec3(0.0f, 0.0f, 0.0f);\n"
		"}\n"
	"}\n"

/////

	"#define darkest_light 0.6f\n"
	"#define light_step 0.2f\n" // From the darkest side, this is the step amount

/////

		// vertex = center + (right.xyz * pos.x * size.x + up.xyz * pos.y * size.y)
		// a = pos * size
		// b = 

		// a.x * b.x + a.y * b.y
		// c = a * b = {a.x * b.x, a.y * b.y}
		// d = c[0] * right + c[1] * size

		/*
		"vec3 bob[2] = vec3[2](vec3(1, 2, 3), vec3(4, 5, 6));\n"
		"vec3 foo[2] = bob;\n"
		"foo *= bob;\n"
		*/

		"vec2 corner_world_space = vertex_model_space * billboard_size_world_space;\n" // In world space
		"vec3 world_space_offset = corner_world_space.x * vec3(right_xz_world_space, 0.0f).xzy + corner_world_space.y * up_world_space;\n"
		"vec3 vertex_world_space = world_space_offset + billboard_center_world_space;\n"
		/*
		"vec3 vertex_world_space = billboard_center_world_space\n"
			"+ vec3(cam_right_xz_world_space, 0.0f).xzy * vertex_model_space.x * billboard_size_world_space.x\n"
			"+ cam_up_world_space * vertex_model_space.y * billboard_size_world_space.y;\n"
		*/

/////

/*
Show this on the info bar:
- Map name (store in EditorState, or in some Map struct)
- Editing height
- Editing texture id
- Editing mode (texture or height)
- Idle, draw, or erase
- The current tile pos index (maybe)

- Map size, keybindings, and corresponding texture ids in map file

- And some background texture
- Keep track of state through a LastEditorState struct
*/

/////

	// const char* const format_without_chars = " |  |,  | |";

	/*
	static char dest[50];
	dest[49] = '\0';

	const char* const format = "%s | %d, %d | %s %d | %s"
	sprintf(dest, format,
		map_name, )
	*/

/////

	// %d, %d -> 255 lim each
	// const char* const info_bar_format = "%s | %.3d, %.3d | %.6s %.3d | %.5s";

	/*
	printf("'%s | %d, %d | %s %d | %s'\n",
		map_name,
		12, 9,
		"height", 25,
		"e");
	*/

	/*
	size_t needed = snprintf(NULL, 0, "%s: %s (%d)", msg, strerror(errno), errno) + 1;
    char  *buffer = malloc(needed);
    sprintf(buffer, "%s: %s (%d)", msg, strerror(errno), errno);
    return buffer;
	*/

/////

- Some background texture
- Keep track of state through a LastEditorState struct, to determine if need to change ui

Format of info bar: name | tile pos | editing mode + editing val | idle, draw, or erase

Examples:
palace | pos 3, 15 | height 8 | idle
fleckenstein | 4, 20 | tex 19 | erase

- name = constant throughout
- tile pos = max 6 chars
- edit mode = max 5 chars
- edit mode val = max 3 chars
- edit state = max 5 chars

/////

byte get_padding_for_six_digits(int16_t n1, int16_t n2) {
	byte digits_set = 2;

	while (n1 /= 10) digits_set++;
	while (n2 /= 10) digits_set++;

	return digits_set;
}

/////

	"float attenuation(vec3 pos_delta) {\n"
		// 1.0/(c1 + c2*d + c3*d^2)

		"float dist_squared = dot(pos_delta, pos_delta);\n"

		"float c1 = 1.0f, c2 = 0.2f, c3 = 0.3f;\n"

		"return 1.0f / (c1 + c2 * sqrt(dist_squared) + c3 * dist_squared);\n"
	"}\n"

	"void main() {\n"
		"vec3 pos_delta = light_pos_world_space - fragment_pos_world_space;\n"
		"float light = /* diffuse(pos_delta) + */ attenuation(pos_delta);\n"
		"face_normal;\n"

		// "light *= 10.0f / length(pos_delta);\n"

		"color = texture(texture_sampler, UV).rgb * light;\n"

/////

		// "return 1.0f / (d2 * 0.1f);"

		// 1.0 / (1.0 + a*dist + b*dist*dist))
		/*
		"float a = 0.3f, b = 0.6f;\n"
		"float atten = 1.0f / (1.0f + a * sqrt(frag_dist_squared) + b * frag_dist_squared);\n"
		*/

		/*
		"float frag_dist_squared = dot(pos_delta_world_space, pos_delta_world_space);\n"
		"float a = 0.3f, b = 0.6f;\n"
		"float atten = 1.0f / (1.0f + a * sqrt(frag_dist_squared) + b * frag_dist_squared);\n"
		*/

		// "float atten = 1.0f / (sqrt(frag_dist_squared));\n"

		/*
		"float radius = 4;\n"
		"float frag_dist_squared = dot(pos_delta_world_space, pos_delta_world_space);\n"
		"float atten = clamp(1.0 -frag_dist_squared/(radius*radius), 0.2, 1.0);\n"
		"return atten;\n"
		*/

/////

- Figure out if diffuse should depend on where player is - or ambient occlusion + simple dynamic lights

///// So much code:

	// Since TexNonrepeating is necessary for billboards, billboards and walls will have to be stored in different places

	billboard_list.texture_set = init_multi_textures(2, 2, 64, 64,
		"../../../../assets/walls/cross_blue.bmp",
		"../../../../assets/walls/desert_snake.bmp",

		"../../../../assets/spritesheets/flying_carpet.bmp", 5, 10, 46,
		"../../../../assets/spritesheets/flying_carpet.bmp", 5, 10, 3
		);

	/*
	billboard_list.texture_set = init_multi_textures(4, 64, 64,
		"../../../../assets/spritesheets/flying_carpet.bmp", 1, 5, 10, 46,
		"../../../../assets/walls/cross_blue.bmp", 0,
		"../../../../assets/walls/desert_snake.bmp", 0,
		"../../../../assets/spritesheets/torch_2.bmp", 1, 2, 3, 5
	);


static GLsizei get_num_subtextures_for_multi_texture(va_list args,
	const GLsizei num_plain_subtextures, const GLsizei num_animated_subtextures) {

	GLsizei total_num_subtextures = num_plain_subtextures;

	va_list args_copy;
	va_copy(args_copy, args);
	for (GLsizei i = 0; i < num_plain_subtextures; i++, va_arg(args_copy, char*));

	// From here, can get 
	for (GLsizei i = 0; i < num_animated_subtextures; i++) {
		va_arg(args_copy, char*); // Discard path, frames across, frames down
		va_arg(args_copy, GLsizei);
		va_arg(args_copy, GLsizei);
		total_num_subtextures += va_arg(args_copy, GLsizei); // Adding arg total_frames
	}

	if (total_num_subtextures > GL_MAX_ARRAY_TEXTURE_LAYERS)
		fail("put textures in a texture set because it exceeds the max array texture layers",
			TextureSetIsTooLarge);

	va_end(args_copy);

	return total_num_subtextures;
}

// Path. If animated: frames across, frames down, total_frames
GLuint init_multi_textures(const GLsizei num_plain_subtextures,
	const GLsizei num_animated_sutextures, const GLsizei rescale_w, const GLsizei rescale_h, ...) {

	va_list args;
	va_start(args, rescale_h);

	const GLuint total_num_subtextures = get_num_subtextures_for_multi_texture(args, num_plain_subtextures, num_animated_sutextures);
	DEBUG(total_num_subtextures, d);

	const GLuint texture = preinit_texture(TexSet, TexRepeating);

	glTexImage3D(TexSet, 0, OPENGL_INTERNAL_PIXEL_FORMAT,
		rescale_w, rescale_h, num_subtextures_in_set, 0,
		OPENGL_INPUT_PIXEL_FORMAT, OPENGL_COLOR_CHANNEL_TYPE, NULL);


	va_end(args);

	//////////

	/*
	va_list args;
	va_start(args, rescale_h);

	const GLsizei num_subtextures_in_set = get_num_subtextures_for_multi_texture(args, num_multi_textures);
	const GLuint texture = preinit_texture(TexSet, TexNonRepeating);

	glTexImage3D(TexSet, 0, OPENGL_INTERNAL_PIXEL_FORMAT,
		rescale_w, rescale_h, num_subtextures_in_set, 0,
		OPENGL_INPUT_PIXEL_FORMAT, OPENGL_COLOR_CHANNEL_TYPE, NULL);

	SDL_Surface* const rescaled_surface = init_blank_surface(rescale_w, rescale_h);
	// If blending enabled, consecutive blits to `frame_surface` will mix with previous blits if alpha channel used
	SDL_SetSurfaceBlendMode(rescaled_surface, SDL_BLENDMODE_NONE);

	for (GLsizei frame_index = 0; frame_index < num_subtextures_in_set;) {
		SDL_Surface* const surface = init_surface(va_arg(args, char*));
		const byte is_animated = va_arg(args, unsigned);

		// This is a lot of code, but bear through it

		if (is_animated) { // TODO: animation part of init_multi_textures
			const GLsizei
				frames_across = va_arg(args, GLsizei),
				frames_down = va_arg(args, GLsizei),
				total_frames = va_arg(args, GLsizei);

			init_animation_from_surface(surface, rescaled_surface,
				frames_across, frames_down, frame_index, frame_index + total_frames);

			frame_index += total_frames;
		}
		else {
			SDL_Surface* cpu_src;

			if (surface -> w != rescale_w || surface -> h != rescale_h) {
				SDL_SoftStretchLinear(surface, NULL, rescaled_surface, NULL);
				cpu_src = rescaled_surface;
			}
			else cpu_src = surface;

			SDL_LockSurface(cpu_src);

			glTexSubImage3D(TexSet, 0, 0, 0, frame_index,
				rescale_w, rescale_h, 1, OPENGL_INPUT_PIXEL_FORMAT,
				OPENGL_COLOR_CHANNEL_TYPE, cpu_src -> pixels);
			
			SDL_UnlockSurface(cpu_src);

			frame_index++;
		}

		deinit_surface(surface);
	}

	glGenerateMipmap(TexSet);
	deinit_surface(rescaled_surface);
	va_end(args);

	return texture;
	*/
}

// TODO: inline
static void init_animation_from_surface(SDL_Surface* const spritesheet_surface, SDL_Surface* const rescaled_surface,
	const GLsizei frames_across, const GLsizei frames_down, const GLsizei start_index, const GLsizei end_index) {

	SDL_Rect spritesheet_copy_area = {.w = spritesheet_surface -> w / frames_across, .h = spritesheet_surface -> h / frames_down};

	for (GLsizei frame_index = start_index; frame_index < end_index; frame_index++) {
		const GLsizei spritesheet_frame_index = frame_index - start_index;
		// Frame index x = frame_index % frames_across, and y = frame_index / frames_across
		spritesheet_copy_area.x = (spritesheet_frame_index % frames_across) * spritesheet_copy_area.w;
		spritesheet_copy_area.y = (spritesheet_frame_index / frames_across) * spritesheet_copy_area.h;

		// Copying to rescaled surface, b/c that's the only good copying way
		SDL_SoftStretchLinear(spritesheet_surface, &spritesheet_copy_area, rescaled_surface, NULL);

		SDL_LockSurface(rescaled_surface); // For pixel access

		glTexSubImage3D(TexSet, 0, 0, 0, frame_index,
			spritesheet_copy_area.w, spritesheet_copy_area.h,
			1, OPENGL_INPUT_PIXEL_FORMAT, OPENGL_COLOR_CHANNEL_TYPE, rescaled_surface -> pixels);

		SDL_UnlockSurface(rescaled_surface);
	}
}

/////


// TODO: remove
GLuint init_animation(const char* const path, const GLsizei frames_across,
	const GLsizei frames_down, const GLsizei total_frames) {

	SDL_Surface* const spritesheet_surface = init_surface(path);
	SDL_SetSurfaceBlendMode(spritesheet_surface, SDL_BLENDMODE_NONE); // If blending, future blits will mix w prev ones

	SDL_Rect spritesheet_copy_area = {.w = spritesheet_surface -> w / frames_across, .h = spritesheet_surface -> h / frames_down};
	SDL_Rect frame_copy_area = {.x = 0, .y = 0, .w = spritesheet_copy_area.w, .h = spritesheet_copy_area.h};

	/* Needed b/c glTexSubImage3D can't copy pixels from the main surface; otherwise, layout
	of pixels in `spritesheet_surface` will result in other frames being partially copied */
	SDL_Surface* const frame_surface = init_blank_surface(spritesheet_copy_area.w, spritesheet_copy_area.h);
	Uint32* const frame_pixels = frame_surface -> pixels;

	const GLuint texture = preinit_texture(TexSet, TexNonRepeating);

	glTexImage3D(TexSet, 0, OPENGL_INTERNAL_PIXEL_FORMAT,
		spritesheet_copy_area.w, spritesheet_copy_area.h, total_frames,
		0, OPENGL_INPUT_PIXEL_FORMAT, OPENGL_COLOR_CHANNEL_TYPE, NULL);

	for (GLsizei frame_index = 0; frame_index < total_frames; frame_index++) {
		// Frame index x = frame_index % frames_across, and y = frame_index / frames_across
		spritesheet_copy_area.x = (frame_index % frames_across) * spritesheet_copy_area.w;
		spritesheet_copy_area.y = (frame_index / frames_across) * spritesheet_copy_area.h;

		SDL_LowerBlit(spritesheet_surface, &spritesheet_copy_area, frame_surface, &frame_copy_area);

		SDL_LockSurface(frame_surface);

		glTexSubImage3D(TexSet, 0, 0, 0, frame_index,
			spritesheet_copy_area.w, spritesheet_copy_area.h,
			1, OPENGL_INPUT_PIXEL_FORMAT, OPENGL_COLOR_CHANNEL_TYPE, frame_pixels);

		SDL_UnlockSurface(frame_surface);
	}

	deinit_surface(frame_surface);
	deinit_surface(spritesheet_surface);
	glGenerateMipmap(TexSet);
	return texture;
}

/////


/* Path, frames across, frames down, total_frames. Animations are not stored in the same
texture set as wall textures because wall textures need UV wrapping, but that's not the case for animations. TODO: remove. */
GLuint init_animation_set(const GLsizei num_animations, const GLsizei rescale_w, const GLsizei rescale_h, ...) {
	va_list args, args_copy;
	va_start(args, rescale_h);
	va_copy(args_copy, args);

	////////// This part computes how many frames will be needed in the animation set

	GLsizei num_animation_frames = 0;
	for (GLsizei i = 0; i < num_animations; i++) {
		va_arg(args_copy, char*); // Discarding path, frames across, and frames down args
		va_arg(args_copy, GLsizei);
		va_arg(args_copy, GLsizei);
		num_animation_frames += va_arg(args_copy, GLsizei); // Adding total_frames
	}

	////////// This part loads the frames of each animation into an OpenGL texture

	SDL_Surface* const rescaling_surface = init_blank_surface(rescale_w, rescale_h);
	Uint32* const rescaling_surface_pixels = rescaling_surface -> pixels;
	const GLuint texture = preinit_texture(TexSet, TexNonRepeating);

	glTexImage3D(TexSet, 0, OPENGL_INTERNAL_PIXEL_FORMAT,
		rescale_w, rescale_h, num_animation_frames,
		0, OPENGL_INPUT_PIXEL_FORMAT, OPENGL_COLOR_CHANNEL_TYPE, NULL);

	for (GLsizei set_frame_index = 0; set_frame_index < num_animation_frames;) {
		SDL_Surface* const spritesheet_surface = init_surface(va_arg(args, char*));
		SDL_SetSurfaceBlendMode(spritesheet_surface, SDL_BLENDMODE_NONE);

		const GLsizei
			frames_across = va_arg(args, GLsizei),
			frames_down = va_arg(args, GLsizei),
			total_frames = va_arg(args, GLsizei);

		SDL_Rect spritesheet_frame_area = {
			.w = spritesheet_surface -> w / frames_across,
			.h = spritesheet_surface -> h / frames_down
		};

		for (GLsizei frame_index = 0; frame_index < total_frames; frame_index++, set_frame_index++) {
			spritesheet_frame_area.x = (frame_index % frames_across) * spritesheet_frame_area.w;
			spritesheet_frame_area.y = (frame_index / frames_across) * spritesheet_frame_area.h;

			SDL_BlitScaled(spritesheet_surface, &spritesheet_frame_area, rescaling_surface, NULL);
			SDL_LockSurface(rescaling_surface); // For pixel access

			glTexSubImage3D(TexSet, 0, 0, 0, set_frame_index,
				rescale_w, rescale_h, 1, OPENGL_INPUT_PIXEL_FORMAT,
				OPENGL_COLOR_CHANNEL_TYPE, rescaling_surface_pixels);

			SDL_UnlockSurface(rescaling_surface);
		}
		deinit_surface(spritesheet_surface);
	}

	glGenerateMipmap(TexSet);
	deinit_surface(rescaling_surface);
	va_end(args);

	return texture;
}

/////


/*
// Param: Texture path. TODO: remove this fn
GLuint init_texture_set(const TextureWrapMode wrap_mode,
	const GLsizei subtex_width, const GLsizei subtex_height, const GLsizei num_textures, ...) {

	const GLuint ts = preinit_texture(TexSet, wrap_mode);

	glTexImage3D(TexSet, 0, OPENGL_INTERNAL_PIXEL_FORMAT,
		subtex_width, subtex_height, num_textures,
		0, OPENGL_INPUT_PIXEL_FORMAT, OPENGL_COLOR_CHANNEL_TYPE, NULL);
	
	SDL_Surface* const rescaled_surface = init_blank_surface(subtex_width, subtex_height);

	va_list args;
	va_start(args, num_textures);
	for (GLsizei i = 0; i < num_textures; i++) {
		const char* const path = va_arg(args, char*);
		SDL_Surface* const surface = init_surface(path);
		SDL_Surface* src_surface;

		if (surface -> w != subtex_width || surface -> h != subtex_height) {
			SDL_SoftStretchLinear(surface, NULL, rescaled_surface, NULL);
			src_surface = rescaled_surface;
		}
		else src_surface = surface;

		SDL_LockSurface(src_surface);

		glTexSubImage3D(TexSet, 0, 0, 0, i, subtex_width, subtex_height, 1,
			OPENGL_INPUT_PIXEL_FORMAT, OPENGL_COLOR_CHANNEL_TYPE, src_surface -> pixels);

		SDL_UnlockSurface(src_surface);

		deinit_surface(surface);
	}

	deinit_surface(rescaled_surface);
	glGenerateMipmap(TexSet);
	va_end(args);

	return ts;
}
*/

/////

	/* TODO: find a way to move billboards + change their animation indices
	And for billboards, associate a texture index with it that can dynamically change */

	/* Since TexNonrepeating is necessary for billboards, billboards and walls will have to be stored in different places.
	Damn - will have to store otherwise static billboards in same spritesheet - those are not walls But get the animation set
	thing working first. So don't worry about this: `First, arrange billboards in the beginning, and then non-billboards after`.
	Also, since animation frame indices will already have to account for some offset calculation,
	it should be okay with the textures at the beginning. */

/////

		/*
		"vec3 reflection_dir = reflect(-light_dir, face_normal);\n"
		// "float s = pow(max(dot(viewDir, reflectDir), 0.0), 32);\n"
		"float s = dot(normalize(1/view_dir), reflection_dir);\n"
		"s = max(s, 0.0f);\n"
		"s = pow(s, 256);\n"
		*/

///// Old shading stuff:


	"float specular(void) {\n" // Shininess
		"return 0.0f;\n"

		/*
		"vec3 view_dir = normalize(pos_delta_world_space);\n"
		"vec3 reflect_dir = reflect(-lightDir, norm);\b"
		"return 0.0f;\n"
		*/
	"}\n"

	"float attenuation(void) {\n" // Distance-based lighting
		"float dist_squared = dot(pos_delta_world_space, pos_delta_world_space);\n"
		// "float dist = sqrt(dist_squared);\n"
		"atten_vars;\n"
		"return 1.0f / (0.9f + 0.005000f * dist_squared);\n"

		// "float c1 = atten_vars[0], c2 = atten_vars[1], c3 = atten_vars[2];\n"
		// "return 1.0f / (c1 + c3 * dist_squared);\n"

		// "return 1.0f / (8.0f + 4.0f * dist_squared + 3.0f * sqrt(dist_squared));\n"
		// "return 150.0f / dist_squared;\n"
		// "return clamp(100.0f / dist_squared, 0.4f, 1.0f);\n"
	"}\n"

/////

	static GLfloat c1 = 1.0f, c2 = 0.01f, c3 = 0.02f;
	const GLfloat step = 0.001f;

	// vals = {0.909001, 0.022000, 0.005000}

	byte change = 0;

	if (keys[SDL_SCANCODE_Z]) c1 += step, change = 1;
	if (keys[SDL_SCANCODE_X]) c1 -= step, change = 1;
	if (keys[SDL_SCANCODE_C]) c2 += step, change = 1;
	if (keys[SDL_SCANCODE_V]) c2 -= step, change = 1;
	if (keys[SDL_SCANCODE_B]) c3 += step, change = 1;
	if (keys[SDL_SCANCODE_N]) c3 -= step, change = 1;

	if (change) printf("vals = {%lf, %lf, %lf}\n", (double) c1, (double) c2, (double) c3);

	// glUniform3f(atten_vars_id, c1, c2, c3);
	// glUniform3f(atten_vars_id, 0.909001f, 0.022000f, 0.005000f);
	// glUniform3f(atten_vars_id, 0.909001f, 0.022000f, 0.005000f);

/////

	/*
	static float a = 0.1f;
	glm_rotate_zr
	(view, a, view);
	a += 0.01f;
	*/

	/*
	for (byte y = 0; y < 4; y++) {
		for (byte x = 0; x < 4; x++) {
			printf("%lf ", (double) view[y][x]);
		}
		putchar('\n');
	}
	puts("---");
	*/

	/*
	static float a = 0.0f;
	a += 0.01f;
	glm_rotate(view, a, (vec3) {1.0f, 0.0f, 0.0f});
	*/

/////

	/*
	mat4 roll_matrix = GLM_MAT4_IDENTITY_INIT;
	glm_rotate(roll_matrix, tilt, dir);
	*/

	// vec3 looking_at = {dir[0] * cos(hori_angle_minus_half_pi)}
	// lookAtVector = Normalize3dVector(viewDir * cos(angle) + UpVector * sin(angle));
	// right[1] = 1.0f;

/////

	/*
	// right[2] += tanf(tilt);
	right[0] += tanf(tilt);
	// right[1] = tanf(tilt);
	print_vec(right);
	glm_vec3_normalize(right);
	*/

	// vec3 roll = {0.0f, tilt, 0.0f};
	// yaw = side to side, pitch = up and down

/////


	// glm_mul(roll, view, view);

	/*
	static GLfloat a = 0.0f;
	a += 0.01f;
	mat4 rot;
	glm_rotate_z((mat4) GLM_MAT4_IDENTITY_INIT, a, rot);
	glm_add
	*/

	/*
	static float d = 0.0f;
	DEBUG((int) d, d);
	DEBUG(d, lf);
	d += keys[SDL_SCANCODE_C] * 0.01f;
	if ((int) d == 16) d = 0;
	((float*) view)[(int) d] = 3.9f;
	*/

	//
	/*
	for (byte y = 0; y < 4; y++) {
		for (byte x = 0; x < 4; x++)
			printf("%lf ", (double) view[x][y]);
		putchar('\n');
	}
	puts("---");
	*/
	//

/////

	//////////
	/*
	mat4 roll = GLM_MAT4_IDENTITY_INIT;
	glm_rotate(roll, tilt, dir);
	*/

	// lookDir = glm::normalize( vec3(sinf(yaw) * cos(tilt), sin(tilt), cosf(yaw) * cos(tilt)) );
	// up *= mat3(roll);
	// The wrong angle turns the view up

	/*
	for (byte y = 0; y < 4; y++) {
		for (byte x = 0; x < 4; x++)
			printf("%lf ", (double) roll[x][y]);
		putchar('\n');
	}
	puts("---");
	*/

/////

	/*
	vec3 test = {0.0f, 1.0f, 0.0f};
	const GLfloat angle = 90.0f;
	const GLfloat rads = angle * (GLfloat) M_PI / 180.0f;

	DEBUG(rads, lf);
	print_vec(test);
	vec3_rot_z(test, rads);
	print_vec(test);
	puts("---");
	*/

	/*
	right[1] += tanf(tilt);
	right[0] += sinf(tilt);
	right[2] += sinf(tilt);

	glm_vec3_normalize(right);
	print_vec(right);
	*/

/////


void vec3_rot_z(vec3 v, const GLfloat angle) {
	const GLfloat cos_theta = cosf(angle), sin_theta = sinf(angle);

	const GLfloat x_prime = v[0] * cos_theta - v[1] * sin_theta;
	const GLfloat z_prime = v[0] * sin_theta + v[1] * cos_theta;

	v[0] = x_prime;
	v[1] = z_prime;

	/* This was around y
	const GLfloat cos_theta = cosf(angle), sin_theta = sinf(angle);

	const GLfloat x_prime = v[0] * cos_theta + v[2] * sin_theta;
	const GLfloat z_prime = -v[0] * sin_theta + v[2] * cos_theta;

	DEBUG(x_prime, d);

	v[0] = x_prime;
	v[2] = z_prime;
	*/
}

/////

- Finding if planes are intersecting:

Planes are infinite

Equation: Ax + By + Cz + D = 0

To define a plane, you need a point on the plane, and a surface normal

Two vectors: PQ and PR
PQ x PR = N = normal
A = normal.x, B = normal.y, C = normal.z
And can use P, Q, or R for the plane's point
Use P, since it's the shared point

With that, the equation is Ax + By + Cz + P (?)
And A(X - P.x) + B(Y - P.y) + C(Z - P.z) = 0
Then, plug in P values, and put something on the other side of the equation after that

cglm, plane 1 with plane 2:

p1 = plane 1, p2 = plane 2
cglm does not extract planes for an aabb

New idea:

n1 = plane 1 normal, n2 = plane 2 normal
Direction of line of intersection = n1 x n2

line1dir = n1  n3
line2dir = n2  n3
Whatever, this is very complicated
Bounding spheres!

///// Some not anymore used functions for sectors:

/*
static void print_sector_list(const SectorList* const sector_list) {
	const List sectors = sector_list -> sectors;

	puts("sector_list = [");
	for (size_t i = 0; i < sectors.length; i++) {
		const Sector sector = ((Sector*) sectors.data)[i];
		printf("\t.texture_id = %d, {.origin = {%d, %d}, .size = {%d, %d}, "
			".visible_heights = {.min = %d, .max = %d}, "
			"ibo_range = {.start = %u, .range = %u}}%s\n",

			sector.texture_id, sector.origin[0], sector.origin[1], sector.size[0],
			sector.size[1], sector.visible_heights.min, sector.visible_heights.max,
			sector.ibo_range.start, sector.ibo_range.length, (i == sectors.length - 1) ? "" : ", "
		);
	}
	puts("]");
}
*/

/*
static void print_map(const char* const name, const byte* const map, const byte map_width, const byte map_height) {
	printf("%s = {\n", name);

	for (byte y = 0; y < map_height; y++) {
		printf("\t{");
		const byte* const row = map + y * map_width;
		for (byte x = 0; x < map_width; x++) {

			const char* end;

			if (x == map_width - 1)
				end = (y == map_height - 1) ? "}\n" : "},\n";
			else end = ", ";

			printf("%d%s", row[x], end);
		}
	}
	puts("}");
}
*/

/////

	printf("aabb_corners = {{%lf, %lf, %lf}, {%lf, %lf, %lf}}\n",
		aabb_corners[0][0], aabb_corners[0][1], aabb_corners[0][2],
		aabb_corners[1][0], aabb_corners[1][1], aabb_corners[1][2]);

/////

	//////////

	/*
	const Billboard hot_dog = ((Billboard*) (scene_state -> billboard_draw_context.object_buffers.cpu.data))[0];
	vec4 frustum_planes[6];
	glm_frustum_planes((vec4*) camera.view_projection, frustum_planes);
	DEBUG(billboard_in_view_frustum(hot_dog, frustum_planes), d);
	*/

/////

		/*
		const GLfloat max_delay = 1000.0f / constants.fps;
		DEBUG(max_delay, lf);
		DEBUG(1.0f / (1000.0f / constants.fps), lf);
		// DEBUG(delta_time, lf);
		const GLfloat p = 1.0f / (1000.0f / constants.fps);
		*/

		/*
		GLfloat a = log2f(xz_speed_heuristic * 2.0f + 1.0f);
		// GLfloat a = xz_speed_heuristic / (xz_v_max * 0.0666666);
		// if (a > 1.0f) a = 1.0f;
		pos[1] += sinf(curr_time * THREE_PI) * 0.15f * a;
		*/

/////

		/*
		// const GLfloat avg_pos_xz = (pos[0] + pos[1]) * 0.5f;
		GLfloat avg_speed_xz = (fabsf(physics_obj -> speeds[0]) + fabsf(physics_obj -> speeds[2])) * 0.5f;
		DEBUG((double) sinf(avg_speed_xz), lf);
		pos[1] += sinf(avg_speed_xz);
		*/

		/*
		GLfloat avg_speed_xz = (fabsf(physics_obj -> speeds[0]) + fabsf(physics_obj -> speeds[2])) * 0.5f;
		// if (avg_speed_xz > 1.5f) avg_speed_xz = 2.0f;
		const GLfloat avg_speed_xz_per_sec = avg_speed_xz / delta_time;
		DEBUG((double) avg_speed_xz_per_sec, lf);
		*/

		// const GLfloat a = fabsf(physics_obj -> speeds[0] / delta_time);

		/*
		const GLfloat max_bob_height = 0.2f;
		static GLfloat x = 0.0f;
		const GLfloat dy = max_bob_height * 0.5f * sinf(PI * (x - 0.5f)) + max_bob_height;
		pos[1] += dy;

		const GLfloat forward_backward_speed = fabsf(physics_obj -> speeds[0]), strafe_speed = fabsf(physics_obj -> speeds[2]);
		const GLfloat greatest_speed = (forward_backward_speed > strafe_speed) ? forward_backward_speed : strafe_speed;
		x += greatest_speed;
		*/

/////

		/*
		const GLfloat avg_speed = (fabsf(physics_obj -> speeds[0]) + fabsf(physics_obj -> speeds[2])) * 0.5f;
		DEBUG(avg_speed, lf);
		const GLfloat avg_speed_per_second = avg_speed / delta_time;
		DEBUG(avg_speed_per_second, lf);
		*/

		/*
		const GLfloat max_bob_height = 0.2f;
		static GLfloat x = 0.0f;
		const GLfloat dy = max_bob_height * 0.5f * sinf(PI * (x - 0.5f)) + max_bob_height;
		pos[1] += dy;

		const GLfloat forward_backward_speed = fabsf(physics_obj -> speeds[0]), strafe_speed = fabsf(physics_obj -> speeds[2]);
		const GLfloat greatest_speed = (forward_backward_speed > strafe_speed) ? forward_backward_speed : strafe_speed;
		x += greatest_speed;
		*/

/////

	// bob_delta = speed_xz_percent * sinf(3.75f * PI * camera -> bob_bounce_input) * 0.1f + 0.1f * speed_xz_percent;

/////

	/*
	puts("{");
	for (int y = 0; y < terrain_height; y++) {
		printf("\t{");
		for (int x = 0; x < terrain_width; x++) {
			const int val = (x & 1) ^ (y & 1);
			printf("%d", val);
			if (x == terrain_width - 1) puts("},");
			else printf(", ");
			*map_point((byte*) texture_id_map, x, y, terrain_width) = val;
		}
	}
	puts("}");
	*/

/////

	SDL_GL_SetAttribute(SDL_GL_RED_SIZE, 8);
	SDL_GL_SetAttribute(SDL_GL_GREEN_SIZE, 8);
	SDL_GL_SetAttribute(SDL_GL_BLUE_SIZE, 8);

/////



	/*
	char curr_char = 1;

	do {
		curr_char = *file_contents;

		switch (curr_char) {
			case COMMENT_START:
				puts("Start of comment");
				while (*file_contents != '\0' && *file_contents != '\n') file_contents++;
				puts("Now at end of line");
				break;
			case SECTION_TAG_START:
				puts("Start of section");
				break;
		}

		file_contents++;
	} while (curr_char != '\0');
	*/

	/*
	char curr_char = *file_contents;

	while (curr_char != '\0') { // While not reached a null terminator
		// const char curr_char = *file_contents;
		printf("curr_char = '%c'\n", curr_char);
		switch (curr_char) {
			case '\n': break;

			case COMMENT_START:
				puts("Start of comment");
				while (*file_contents != '\0' && *file_contents != '\n') file_contents++;
				puts("Now at end of line");
				break;
			case SECTION_TAG_START:
				puts("Start of section");
				break;
		}

		// curr_char = *++file_contents;
		file_contents++;
		curr_char = *file_contents;
	}
	*/

/////

	// if (num_bytes == 0l) FAIL(OpenFile, "attemped to read file with the path of '%s', but it was empty.", filename);

/////

	/*
	for (long rel_char_index = *char_index + 1; rel_char_index < file_contents.num_bytes; rel_char_index++) {
		// const char curr_char = file_contents.data[rel_char_index];
		// DEBUG(curr_char, c);

		for (byte i = 0; i < num_section_tag_types; i++) {
			const SectionTag tag = section_tags[i];
			const size_t tag_length = strlen(tag.name);
			if (strncmp(tag.name, ))
		}
	}
	*/

/////

		// if (tag_ref -> flags & TAG_IS_ONE_LINE_BIT) puts("Check for space after tag name");

			// Each tag needs a whitespace character, whether that be a space, a newline character, or something else

			// const char after = *(tag_start + tag_length);
			const char after = tag_start[tag_length];
			// const byte needs_an_one_line_argument = tag_ref -> flags & (TAG_IS_ONE_LINE_BIT | TAG_HAS_ARGUMENT_BIT);
			// DEBUG(needs_an_one_line_argument, d);

			if (/* (needs_an_one_line_argument && after == '\0') */ isspace(after)) {
				matching_tag = tag_ref;
				break;
			}
			// printf("tag_name = '%s', and after = '%c', and is whitespace = %d\n", tag_name, after, isspace(after));

			/*
			if ((tag_ref -> flags & TAG_HAS_ARGUMENT_BIT)) {
				DEBUG(*tag_start, c);
				const char after = (*tag_start + tag_length + 1);
				DEBUG(after, c);
				if (!isspace(after)) puts("Need space after");
			}

			matching_tag = tag_ref;
			break;
			*/

/////

			// printf("Ladies and gentlemen, something should have parsed this character: '%c'\n", curr_char);

///// The old DDL parser, mixed with a bit of the new one:

#include "ddl_parser.h"

// The pointer in the file contents returned by this function should be freed by the caller
static FileContents read_file_contents(const char* const file_name) {
	FILE* const file = fopen(file_name, "r");
	if (file == NULL) FAIL(OpenFile, "could not open a file with the path of '%s'.", file_name);

	fseek(file, 0l, SEEK_END); // Set file position to end
	const long num_bytes = ftell(file);
	fseek(file, 0l, SEEK_SET); // Rewind file position

	char* const data = malloc(num_bytes + 1l);
	fread(data, num_bytes, 1, file); // Read file bytes
	data[num_bytes] = '\0';

	fclose(file);
	return (FileContents) {file_name, data, num_bytes};
}

static void progress_char_index_to_tag_argument(long* const char_index_ref,
	const SectionTag* const tag, const FileContents* const file_contents) {

	long char_index = *char_index_ref + strlen(tag -> name) + 1;
	const long orig_char_index = char_index;

	const char* const data = file_contents -> data;

	while ((char_index < file_contents -> num_bytes) && isspace(data[char_index])) char_index++;

	if ((char_index == orig_char_index) || (data[char_index] == SECTION_TAG_START))
		FAIL(ParseLevelFile, "a level tag in '%s' needs an argument.", file_contents -> file_name);

	*char_index_ref = char_index - 1;
}

static const SectionTag* get_section_tag(const long char_index, const FileContents* const file_contents) {
	/* While not reached space or newline, collect tag name
	Curr tag types: name, heightmap, texture_id_map, wall_textures 
	Also, a variant of one-line tags
	Goal is to get correct section tag out, by comparing the string up until a newline (do the multiline variant first)
	Need whitespace after a one-line tag */

	// No need to worry about overflow here since strncmp accounts for a possible null terminator
	const char* const tag_start = file_contents -> data + char_index + 1;
	const SectionTag* matching_tag = NULL;

	for (byte i = 0; i < num_section_tag_types; i++) {
		const SectionTag* const tag_ref = section_tags + i;
		const char* const tag_name = tag_ref -> name;

		const size_t tag_length = strlen(tag_name);

		// If the tag matches, and there's a whitespace character after it
		if (strncmp(tag_name, tag_start, tag_length) == 0 && isspace(tag_start[tag_length])) {
			matching_tag = tag_ref;
			break;
		}
	}

	if (matching_tag == NULL)
		FAIL(ParseLevelFile, "did not recognize a level tag for '%s'.", file_contents -> file_name);

	// else printf("Found a tag match: '%s'\n", matching_tag -> name);
	return matching_tag;
}

SECTION_PARSER_DEF(name) {
	(void) start_char_index;
	(void) end_char_index;
	(void) file_contents;
	(void) eds;
	puts("Name parser");

	// strtok?

	/*
	const size_t name_length = end_char_index - start_char_index + 1;
	DEBUG(name_length, zu);
	*/

	/*
	file_contents -> data[end_char_index + 1] = '\0';
	printf("Name: '%s'\n", file_contents -> data + start_char_index);
	*/
}

SECTION_PARSER_DEF(map_size) {
	(void) start_char_index;
	(void) end_char_index;
	(void) file_contents;
	(void) eds;
	puts("Map size parser");
}

SECTION_PARSER_DEF(heightmap) {
	(void) start_char_index;
	(void) end_char_index;
	(void) file_contents;
	(void) eds;
	puts("Heightmap parser");
}

SECTION_PARSER_DEF(texture_id_map) {
	(void) start_char_index;
	(void) end_char_index;
	(void) file_contents;
	(void) eds;
	puts("Texture id map parser");
}

SECTION_PARSER_DEF(wall_texture) {
	(void) start_char_index;
	(void) end_char_index;
	(void) file_contents;
	(void) eds;
	puts("Wall texture parser");
}

// The beginning of a section is marked by an ampersand an an identifier, and then an argument
static void parse_section(long* const char_index_ref, const FileContents* const file_contents,
	const SectionTag* const tag, const EditorState* const eds) {

	const char* const data = file_contents -> data;

	long char_index = *char_index_ref + 1;
	const long arg_start_index = char_index;

	// Find start of next argument, at its ampersand; and after that, backtrack, ignoring all whitespace characters
	while ((char_index < file_contents -> num_bytes) && (data[char_index] != SECTION_TAG_START)) char_index++;
	while (isspace(data[--char_index]));

	*char_index_ref = char_index; // Here, char_index equals arg_end_index
	tag -> section_parser(arg_start_index, char_index, file_contents, eds);
	
	// printf("Start char is '%c', and end char is '%c'\n|\n", data[arg_start_index], data[char_index]);
	/* data[char_index + 1] = '\0';
	printf("Arg: '%s'\n", data + arg_start_index); */
}

static void parse_ddl_file(EditorState* const eds, FileContents* const file_contents) {
	char* const data = file_contents -> data;
	const long num_bytes = file_contents -> num_bytes;

	// This erases all comments and replaces them with whitespace
	for (long i = 0; i < num_bytes; i++) {
		if (data[i] == COMMENT_START) {
			while (i < num_bytes && data[i] != '\n') data[i++] = ' ';
		}
	}

	/*
	const char* const delimiters = " \n\t\v\f\r";

	const char* token = strtok(data, delimiters);
	while (token != NULL) {
		if (token[0] == SECTION_TAG_START) {
			puts("Parse section");
			const char* const tag_name = token + 1;
			DEBUG(tag_name, s);

			const SectionTag* matching_tag = NULL;
			for (byte i = 0; i < num_section_tag_types; i++) {
				const SectionTag* const cmp_tag = section_tags + i;
				const char* const cmp_tag_name = cmp_tag -> name;
				if (strncmp(cmp_tag -> name, tag_name, strlen(cmp_tag_name)) == 0) {
					matching_tag = cmp_tag;
					break;
				}
			}
			if (matching_tag == NULL)
				FAIL(ParseLevelFile, "did not recognize a level tag for '%s'.", file_contents -> file_name);
			else puts("Found a tag!");
		}

		printf("token = '%s'\n", token);
		token = strtok(NULL, delimiters);
	}
	*/

	for (long i = 0; i < num_bytes; i++) {
		const char curr_char = data[i];
		if (curr_char == SECTION_TAG_START) {
			const SectionTag* const tag = get_section_tag(i, file_contents);
			progress_char_index_to_tag_argument(&i, tag, file_contents);
			parse_section(&i, file_contents, tag, eds);
		}
		else if (!isspace(curr_char))
			FAIL(ParseLevelFile, "Lone character '%c' for level '%s'.", curr_char, file_contents -> file_name);
	}
}

void init_editor_state_from_ddl_file(EditorState* const eds, const char* const filename) {
	FileContents file_contents = read_file_contents(filename);
	parse_ddl_file(eds, &file_contents);
	free(file_contents.data);
}

///// Variant 1:

	/*
	while (*data != '\0') {
		if (*data == COMMENT_START) { // If found a comment, add spaces until the end of the line or file
			while ((*data != '\0') && (*data != '\n')) *(data++) = ' ';
		}
		if (*data != '\0') data++;
	}
	*/

///// Variant 2:

	char c = *data;
	long char_index = 0;

	while (c != '\0') {
		if (c == COMMENT_START) {
			while ((c != '\0') && (c != '\n')) {
				data[char_index++] = ' ';
				c = data[char_index];
			}
		}
		c = data[char_index++];
	}

/////

void add_face_mesh_to_list(const Face face, const byte sector_max_visible_height,
	const byte side, const byte texture_id, List* const face_mesh_list) {

	/* Face info bits, layout:
		Bits 0-1, two bits -> face type
		Bit 2, one bit -> face side (top or left side of top-down sector)
		Bits 3-7, five bits -> texture id

	So, 00 -> flat, 01 -> vert NW, and 10 -> vert EW */

	const byte
		face_info = (texture_id << 3) | (side << 2) | face.type,
		near_x = face.origin[0], near_z = face.origin[1],
		top_y = sector_max_visible_height;

	const mesh_component_t* face_mesh;

	/*
	buffer_index_t index_set[indices_per_face] = {s, s + 1, s + 2, s, s + 3, s + 1};

	if ((face.type == Vert_NS && !side) || (face.type == Vert_EW && side)) {
		index_set[3]++;
		index_set[5]++;
	}
	*/

	// 0, 1, 2, 0, 3, 1; or 0, 1, 2, 1, 3, 2

	switch (face.type) {
		case Flat: {
			const byte size_x = face.size[0], size_z = face.size[1];
			const byte far_x = near_x + size_x, far_z = near_z + size_z;

			face_mesh = (mesh_component_t[vars_per_face]) {
				/*
				near_x, top_y, far_z, face_info,
				far_x, top_y, near_z, face_info,
				near_x, top_y, near_z, face_info,
				far_x, top_y, far_z, face_info
				*/

				near_x, top_y, far_z, face_info, // 0
				far_x, top_y, near_z, face_info, // 1
				near_x, top_y, near_z, face_info, // 2

				near_x, top_y, far_z, face_info, // 0
				far_x, top_y, far_z, face_info, // 3
				far_x, top_y, near_z, face_info // 1
			};
			break;
		}
		case Vert_NS: {
			const byte size_z = face.size[0], size_y = face.size[1];
			const byte far_z = near_z + size_z, bottom_y = top_y - size_y;

			face_mesh = side
				? (mesh_component_t[vars_per_face]) {
					/*
					near_x, bottom_y, near_z, face_info,
					near_x, top_y, far_z, face_info,
					near_x, top_y, near_z, face_info,
					near_x, bottom_y, far_z, face_info
					*/

					// Vert_NS && side -> 0, 1, 2, 0, 3, 1

					near_x, bottom_y, near_z, face_info, // 0
					near_x, top_y, far_z, face_info, // 1
					near_x, top_y, near_z, face_info, // 2

					near_x, bottom_y, near_z, face_info, // 0
					near_x, bottom_y, far_z, face_info, // 3
					near_x, top_y, far_z, face_info // 1
				}
				: (mesh_component_t[vars_per_face]) {
					/*
					near_x, top_y, near_z, face_info,
					near_x, top_y, far_z, face_info,
					near_x, bottom_y, near_z, face_info,
					near_x, bottom_y, far_z, face_info
					*/

					// Vert_NS && !side -> 0, 1, 2, 1, 3, 2

					near_x, top_y, near_z, face_info, // 0
					near_x, top_y, far_z, face_info, // 1
					near_x, bottom_y, near_z, face_info, // 2				

					near_x, top_y, far_z, face_info, // 1
					near_x, bottom_y, far_z, face_info, // 3
					near_x, bottom_y, near_z, face_info // 2
				};
			break;
		}
		case Vert_EW: {
			const byte size_x = face.size[0], size_y = face.size[1];
			const byte far_x = near_x + size_x, bottom_y = top_y - size_y;

			face_mesh = side
				? (mesh_component_t[vars_per_face]) {
					/*
					near_x, top_y, near_z, face_info,
					far_x, top_y, near_z, face_info,
					near_x, bottom_y, near_z, face_info,
					far_x, bottom_y, near_z, face_info
					*/

					// Vert_EW && side -> 0, 1, 2, 1, 3, 2

					near_x, top_y, near_z, face_info, // 0
					far_x, top_y, near_z, face_info, // 1
					near_x, bottom_y, near_z, face_info, // 2

					far_x, top_y, near_z, face_info, // 1
					far_x, bottom_y, near_z, face_info, // 3
					near_x, bottom_y, near_z, face_info // 2
				}
				: (mesh_component_t[vars_per_face]) {
					/*
					near_x, bottom_y, near_z, face_info,
					far_x, top_y, near_z, face_info,
					near_x, top_y, near_z, face_info,
					far_x, bottom_y, near_z, face_info
					*/

					// Vert_EW && !side -> 0, 1, 2, 0, 3, 1

					near_x, bottom_y, near_z, face_info, // 0
					far_x, top_y, near_z, face_info, // 1
					near_x, top_y, near_z, face_info, // 2

					near_x, bottom_y, near_z, face_info, // 0
					far_x, bottom_y, near_z, face_info, // 3
					far_x, top_y, near_z, face_info // 1

				};
			break;
		}
	}

	push_ptr_to_list(face_mesh_list, face_mesh);

	//////////

	/*
	const buffer_index_t s = index_list -> length * vertices_per_face; // s = index set start
	buffer_index_t index_set[indices_per_face] = {s, s + 1, s + 2, s, s + 3, s + 1};

	if ((face.type == Vert_NS && !side) || (face.type == Vert_EW && side)) {
		index_set[3]++;
		index_set[5]++;
	}

	push_ptr_to_list(index_list, index_set);
	*/
}

/////

	// TODO: don't keep track of `i`
	const size_t total_bytes = sector_face_meshes -> length * bytes_per_face;
	memset(face_meshes_gpu, 0, total_bytes);
	DEBUG(total_bytes, d);

/////

	/*
	DEBUG_BITS(last_chunk_upper_x_bits_set);
	byte first_chunk = 0b10101010;
	byte num_lower_bits_set_in_first_chunk = area_w % 8u;
	DEBUG(num_lower_bits_set_in_first_chunk, d);

	const byte a = (all_bits_set >> (area_x & area_w));
	DEBUG_BITS(a);

	const byte fully_set_chunks = (area_w >> 3u) - 1u;
	DEBUG(fully_set_chunks, d);

	const byte bits_for_lower_chunk = 
	*/

/////


// A 'chunk' is a byte, or a group of 8 bits
inlinable void set_statemap_area(const StateMap statemap, const SDL_Rect area) {
	puts("Area setting time");
	printf("Setting area {%d, %d, %d, %d}\n", area.x, area.y, area.w, area.h);

	const byte all_bits_set = 255u;

	const unsigned area_x = area.x, area_w = area.w;
	const unsigned start_chunk_index = area_x >> 3u;
	// const unsigned num_fully_settable_chunks = area_w >> 3u;

	/*
	const byte lower_cleared_bits_for_last_chunk = (area_w & 7u); // `x & 7 == x % 8`.
	// In the last chunk, a certain number of upper bits are set. `255 >> x` = upper `x` bits are cleared.
	const byte last_chunk = ~(all_bits_set >> lower_cleared_bits_for_last_chunk);
	*/

	//////////
	// Setting middle and last chunks at the moment; set first chunk too
	const byte num_fully_set_chunks = start_chunk_index - 1u;

	// DEBUG(num_fully_set_chunks, d);

	// const byte bits_for_first_chunk = 8 - (area_x & 7);
	const byte bits_cleared_for_first_chunk_start = area_x & 7;
	// DEBUG(bits_for_first_chunk, d);
	// const byte first_chunk = ~(all_bits_set >> (8 - bits_cleared_for_first_chunk)) >> bits_cleared_for_first_chunk;
	// DEBUG(bits_cleared_for_first_chunk, d);
	const byte first_chunk = all_bits_set >> bits_cleared_for_first_chunk_start;

	const byte bits_cleared_for_first_chunk_end = 3; // ???

	DEBUG_BITS(first_chunk);

	// first needs 6

	// const unsigned bit_sum = bits_for_first_chunk + (8 - lower_cleared_bits_for_last_chunk) + num_fully_set_chunks * 8;
	// DEBUG(bit_sum, d);

	//////////

	DEBUG(num_fully_set_chunks, d);
	void print_statemap(const StateMap statemap);
	puts("Before:");
	print_statemap(statemap);

	for (unsigned y = (unsigned) area.y; y < (unsigned) (area.y + area.h); y++) {
		byte* const chunk_start = statemap_byte(statemap, start_chunk_index, y);

		*chunk_start |= first_chunk;

		// for (unsigned x = 1u; x < num_fully_settable_chunks; x++) chunk_start[x] = all_bits_set;

		// memset(chunk_start + 1, all_bits_set, num_fully_set_chunks);
		// chunk_start[num_fully_set_chunks] |= last_chunk;
	}
	puts("After:");
	print_statemap(statemap);
	puts("---");
}

///// God damn this is so hard

inlinable byte bits_set_in_domain(const byte start, const byte end) {
	const byte x_bits_set = ~(255u << (end - start));
	return x_bits_set << start;
}

// A 'chunk' is a byte, or a group of 8 bits
inlinable void set_statemap_area(const StateMap statemap, const SDL_Rect area) {
	puts("Area setting time");
	printf("Setting area {%d, %d, %d, %d}\nBefore:\n", area.x, area.y, area.w, area.h);

	const byte test = bits_set_in_domain(2, 7);
	DEBUG_BITS(test);

	const unsigned area_x = area.x, area_w = area.w;

	typedef struct {
		byte left, right;
	} BitRange;

	BitRange start_chunk = {.left = 8u - (area_x & 7u)};
	DEBUG(start_chunk.left, d);
	start_chunk.right = (area.w >= start_chunk.left ? 0 : (8u - start_chunk.left));

	// byte num_start_chunk_bits = 8u - (area_x & 7u);

	// if (area_w <= 8) num_start_chunk_bits -= area_w;

	// DEBUG(num_start_chunk_bits, d);

	/*
	const byte num_full_middle_chunks = area_w;
	DEBUG(num_full_middle_chunks, d);

	const byte num_end_chunk_bits = 8u - ((area_x + area_w) & 7u);
	DEBUG(num_end_chunk_bits, d);
	*/

	void print_statemap(const StateMap statemap);
	print_statemap(statemap);

	/*
	for (unsigned y = (unsigned) area.y; y < (unsigned) (area.y + area.h); y++) {
		byte* const chunk_start = statemap_byte(statemap, start_chunk_index, y);

		*chunk_start |= first_chunk;

		// for (unsigned x = 1u; x < num_fully_settable_chunks; x++) chunk_start[x] = all_bits_set;

		// memset(chunk_start + 1, all_bits_set, num_fully_set_chunks);
		// chunk_start[num_fully_set_chunks] |= last_chunk;
	}
	*/
	puts("After:");
	print_statemap(statemap);
	puts("---");
}

/////

	/*
	set_statemap_area(traversed_points,
		(SDL_Rect) {sector.origin[0], origin_y, sector.size[0], sector.size[1]}
		);
	*/

	static byte first = 1;
	if (first) {
		set_statemap_area(traversed_points, (SDL_Rect) {3, 2, 1, 4});
		first = 0;
	}

///// A bit of spike testing:

		const Uint32 b4 = SDL_GetTicks();
		SDL_GL_SwapWindow(screen -> window);
		const Uint32 diff = SDL_GetTicks() - b4;
		if (diff > 3) puts("Spike");

/////

	/*
	(byte*) palace_heightmap, (byte*) palace_texture_id_map, palace_width, palace_height
	(byte*) pyramid_heightmap, (byte*) pyramid_texture_id_map, pyramid_width, pyramid_height
	(byte*) tpt_heightmap, (byte*) tpt_texture_id_map, tpt_width, tpt_height
	(byte*) new_heightmap, (byte*) texture_id_map, new_width, new_height
	(byte*) terrain_heightmap, (byte*) texture_id_map, terrain_width, terrain_height
	(byte*) tiny_heightmap, (byte*) tiny_heightmap, tiny_width, tiny_height
	(byte*) level_one_heightmap, (byte*) level_one_texture_id_map, level_one_width, level_one_height
	(byte*) checker_heightmap, (byte*) texture_id_map, checker_width, checker_height
	*/

/////

		/*
		7,
		(Billboard) {2, {1.0f, 1.0f}, {4.5f, 0.5f, 6.5f}},
		(Billboard) {2, {1.0f, 1.0f}, {2.5f, 0.5f, 6.5f}},
		(Billboard) {2, {1.0f, 1.0f}, {3.0f, 3.5f, 11.5f}},
		(Billboard) {0, {1.0f, 1.0f}, {8.5f, 0.5f, 25.5f}},
		(Billboard) {1, {1.0f, 1.0f}, {5.0f, 0.5f, 22.5f}}, // 0.28f
		(Billboard) {0, {1.0f, 1.0f}, {12.5f, 0.5f, 38.5f}},
		(Billboard) {28, {1.0f, 1.0f}, {21.5f, 0.5f, 24.5f}} // 40
		*/

/////

		/*
		TexNonRepeating, 2, 2, 64, 64,
		"../../../../assets/objects/teleporter.bmp",
		"../../../../assets/objects/health_kit.bmp",
		"../../../../assets/spritesheets/bogo.bmp", 2, 3, 6,
		"../../../../assets/spritesheets/trooper.bmp", 33, 1, 33
		*/

/////

		"vec3 v = pos_delta_world_space;\n"
		"float noise = 0; // noise1(v.x) * noise1(fract(v.y)) / noise1(v.z);\n"
		"noise = abs(noise);\n"
		"if (noise > 1.0f) noise = 1.0f;\n"
		"noise = 0;\n"
		// "noise = abs(noise / 10.0f);\n"

		"float light = (ambient_strength + diffuse() + noise) * attenuation();\n"
		// "float n = abs(noise1(light));\n"
		"color = texture(texture_sampler, UV).rgb * min(light, 1.0f);\n"
	"}\n",

///// Old perlin stuff:

*const perlin_fragment_shader =
	"#version 330 core\n"

	"out vec3 color;\n"

	"uniform float scale, rand_factor;\n"
	"uniform vec2 screen_size;\n"

	/*
	"float rand_2D(vec2 v) {\n"
		"return fract(sin(dot(v, vec2(12.9898f, 78.233f))) * 43758.5453123f);\n"
	"}\n"
	*/

	"float smooth_lerp(float a0, float a1, float w) {\n"
		// "return (a1 - a0) * ((w * (w * 6.0 - 15.0) + 10.0) * w * w * w) + a0;\n"
		"return (a1 - a0) * w + a0;\n"
	"}\n"

	// a and b to uvec2
	"float gradient_at(int a, int b, vec2 pos) {\n"
		"int w = 32;\n"
		"int s = w / 2;\n"
		"a *= 3284157443;\n"
		"b ^= a << s | a >> w - s;\n"
		"b *= 1911520717;\n"
		"a ^= b << s | b >> w-s;\n"
		"a *= 2048419325;\n"
		"float rand = a * (3.14159265 / ~(~0 >> 1));\n"
		"vec2 rand_gradient = vec2(sin(rand), cos(rand));\n"
		"return dot(pos - rand_gradient, rand_gradient);\n"
	"}\n"

	//  // From 0.0f to 1.0f this time, or some non-integer scale (pos from 0 to 1, and then screen space)
	"float smooth_noise_2D(vec2 pos) {\n"
		"int x0 = int(pos.x), x1 = int(pos.x) + 1, y0 = int(pos.y), y1 = int(pos.y) + 1;\n"
		"vec2 weights = fract(pos);\n"

		"float ix0 = smooth_lerp(gradient_at(x0, y0, pos), gradient_at(x1, y0, pos), weights.x);\n"
		"float ix1 = smooth_lerp(gradient_at(x0, y1, pos), gradient_at(x1, y1, pos), weights.x);\n"
		"return smooth_lerp(ix0, ix1, weights.y);\n"
	"}\n"

	/*
	"float noise_2D(vec2 v) {\n"
		"vec2 top_left_pos = floor(v), delta = fract(v);\n"

		"float\n" // These are random values for each corner
			"top_left = rand_2D(top_left_pos),\n"
			"top_right = rand_2D(top_left_pos + vec2(1.0f, 0.0f)),\n"
			"bottom_left = rand_2D(top_left_pos + vec2(0.0f, 1.0f)),\n"
			"bottom_right = rand_2D(top_left_pos + vec2(1.0f, 1.0f));\n"
		
		"vec2 weight = delta * delta * (3.0f - 2.0f * delta);\n" // Cubic hermite spline

		"return\n"
			"mix(top_left, top_right, weight.x) +\n"
			"(bottom_left - top_left) * weight.y * (1.0f - weight.x) +\n"
			"(bottom_right - top_right) * weight.x * weight.y;\n"
	"}\n"
	*/

	"void main(void) {\n"
		// "vec2 a = gl_FragCoord.xy * vec2(0.5f, -0.5f) + 0.5f;"
		// "float noise = smooth_noise_2D(ivec2(a / screen_size));\n"
		"float noise = smooth_noise_2D(vec2(3.2f, 1.4f));\n"
		"color = vec3(noise);\n"

		/*
		"vec2 pixel_pos = gl_FragCoord.xy / screen_size;\n"
		"float noise = noise_2D(pixel_pos * scale);\n"
		"color = vec3(noise);\n"
		*/
	"}\n";

///// The old perlin lerper:

	"float cos_lerp(float a, float b, float weight) {\n"
		"float r = weight * 3.1415926536f;\n"
		"float f = (1.0f - cos(r)) * 0.5f;\n"
		"return a * (1.0 - f) + b * f;\n"
	"}\n"

/////

		/*
		"float\n"
			"center = noise(ix, iy), top_right = noise(ix + 1, iy),\n"
			"bottom_left = noise(ix, iy + 1), bottom_right = noise(ix + 1, iy + 1);\n"
		*/

		/*
		"float\n"
			"a = noise(ix - 1, iy - 1), b = noise(ix, iy - 1), c = noise(ix, iy + 1),  d = noise(ix, iy + 2),\n"
			"e = noise(ix - 1, iy),     f = noise(ix, iy),     g = noise(ix + 1, iy),  h = noise(ix + 1, iy),\n"
			"i = noise(ix - 1, iy + 1), j = noise(ix, iy + 1), k = noise(ix + 1, iy + 1), l = noise(ix + 1, iy + 2);\n"
		
		"float tl = (a + b + d + e) / 4.0f, tr = (b + c + e + f) / 4.0f, bl = (d + e + g + h) / 4.0f, br = (e + f + h + i) / 4.0f;\n"

		"float top = mix(tl, tr, fractions.x), bottom = mix(bl, br, fractions.x);\n"
		"return mix(top, bottom, fractions.y);\n"
		*/

/////

		/*
		tl = smooth_noise(ix, iy)
		tl = noise(ix, iy) / 4.0f
			+ (noise(ix + 1, iy) + noise(ix - 1, iy) + noise(ix, iy + 1) + noise(ix, iy - 1)) / 8.0f
			+ (noise(ix + 1, iy + 1) + noise(ix + 1, iy - 1) + noise(x - 1, iy + 1) + noise(ix - 1, iy - 1)) / 16.0f

		tr = smooth_noise(ix + 1, iy)
		tr = noise(ix + 1, iy) / 4.0f
			+ (noise(ix + 1 + 1, iy) + noise(ix + 1 - 1, iy) + noise(ix + 1, iy + 1) + noise(ix + 1, iy - 1)) / 8.0f
			+ (noise(ix + 1 + 1, iy + 1) + noise(ix + 1 + 1, iy - 1) + noise(ix - 1 + 1, iy + 1) + noise(ix - 1 + 1, iy + 1)) / 16.0f
		*/

/////

		/*
		also need

		tr:
		- noise(ix + 2, iy)
		- noise(ix + 2, iy + 1)
		- noise(ix + 2, iy - 1)

		bl:
		- noise(ix, iy + 2)
		- noise(ix + 1, iy + 2)
		- noise(ix - 1, iy + 2)

		br:
		- noise(ix + 2, iy + 1)
		- noise(ix + 1, iy + 2)
		- noise(ix + 2, iy + 2)
		- noise(ix + 2, iy) (already)
		- noise(ix, iy + 2)
		*/

/////

		// Into some sort of matrix operation, perhaps

		/*
		"float\n"
			"a = noise(ix - 1, iy - 1), b = noise(ix, iy - 1), c = noise(ix + 1, iy - 1), d = noise(ix + 2, iy - 1),\n"
			"e = noise(ix - 1, iy),     f = noise(ix, iy),     g = noise(ix + 1, iy),     h = noise(ix + 2, iy),\n"
			"i = noise(ix - 1, iy + 1), j = noise(ix, iy + 1), k = noise(ix + 1, iy + 1), l = noise(ix + 2, iy + 1),\n"
			"m = noise(ix - 1, iy + 2), n = noise(ix, iy + 2), o = noise(ix + 1, iy + 2), p = noise(ix + 2, iy + 2);\n"
		*/

		// Take in a center

		/*
		"mat4 samples = mat4(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16);\n"
		*/

/////

		"float bl = noise(ix, iy + 1) / 4.0f\n" // smooth_noise(ix, iy + 1)
			"+ (noise(ix + 1, iy + 1) + noise(ix - 1, iy + 1) + noise(ix, iy + 1 + 1) + noise(ix, iy - 1 + 1)) / 8.0f\n"
			"+ (noise(ix + 1, iy + 1 + 1) + noise(ix + 1, iy - 1 + 1) + noise(ix - 1, iy + 1 + 1) + noise(ix - 1, iy - 1 + 1)) / 16.0f;\n"

/////


	for (int y = 0; y < size[1]; y++) {
		float ry = -((y * rescale_vals[1]) - 0.5f);
		// DEBUG(ry, lf);
		for (int x = 0; x < size[0]; x++) {

			float rx = 0.5f - (x * rescale_vals[0]);

			float val = perlin_2D((vec2) {rx, ry});
			// float val = perlin_2D((vec2) {x * rescale_vals[0] + 0.5f, y * rescale_vals[1] - 0.5f});
			// if (val < 0.0f) printf("Bad");
			// const float val = perlin_2D(x * rescale_vals[0], y * ) + result_addend;
			const Uint8 color = val * 255;

/////

	SDL_Color palette[256];
	for (Uint8 i = 0; i < 255; i++) palette[i] = (SDL_Color) {i, i, i, 255};
	int a = SDL_SetPaletteColors(perlin_map -> format -> palette, palette, 0, 256);
	DEBUG(a, d);

	const int index = ((Uint8*) perlin_map -> pixels)[2];
	const SDL_Color c = perlin_map -> format -> palette -> colors[index];
	printf("c = {%d, %d, %d, %d}\n", c.r, c.g, c.b, c.a);

/////

/*
- Get an 8-bit pixel format - done
- This should take command line arguments later
- 2D first, 3D later
- Compile this with the map code once done
- Map widths 1, 2, 3, 5, 6, 7, ... get weird artifacts - done
*/

/////
			/*
			float n = noise(x, y);
			if (n < 0.0f) n = 0.0f;
			else if (n > 1.0f) n = 1.0f;

			row[x] = n * 255;
			*/
/////

#include <SDL2/SDL.h>

#define PIXEL_FORMAT SDL_PIXELFORMAT_INDEX8
#define DEBUG(var, format) printf(#var " = %" #format "\n", var)

typedef float vec2[2];
typedef float mat4[4][4];

typedef float noise_type_t;

typedef struct {
	noise_type_t* const data;
	const int size[2];
} NoiseMap;

//////////

const int first_octave = 3, octaves = 10;

const float
	inner_rand_multiplier = 1.43f, outer_rand_multiplier = 1.0f, rand_subtrahend = 0.0f,
	persistence = 0.65f, scale = 1.0f, result_addend = 0.4f;

//////////

float dot(const vec2 a, const vec2 b) {
	return a[0] * b[0] + a[1] * b[1];
}

float fract(const float a) {
	return a - floorf(a);
}

float noise(const int x, const int y) {
	return outer_rand_multiplier
		* fract(sinf(inner_rand_multiplier * dot((vec2) {x, y}, (vec2) {12.9898f, 78.233f})) * 43758.5453f)
		- rand_subtrahend;
}

float lerp(const float a, const float b, const float weight) {
	return a * (1.0f - weight) + b * weight;
}

float noise_from_samples(const int cx, const int cy, const mat4 samples) {
	return samples[cy][cx] * 0.25f
		+ (samples[cy - 1][cx] + samples[cy + 1][cx] + samples[cy][cx - 1] + samples[cy][cx + 1]) * 0.125f
		+ (samples[cy - 1][cx - 1] + samples[cy - 1][cx + 1] + samples[cy + 1][cx - 1] + samples[cy + 1][cx + 1]) * 0.0625f;
}

float lerp_noise(const vec2 pos, const NoiseMap noise_map) {
	const int ix = pos[0], iy = pos[1];

	/*
	const mat4 samples = {
		{noise(ix - 1, iy - 1), noise(ix, iy - 1), noise(ix + 1, iy - 1), noise(ix + 2, iy - 1)},
		{noise(ix - 1, iy),     noise(ix, iy),     noise(ix + 1, iy),     noise(ix + 2, iy)},
		{noise(ix - 1, iy + 1), noise(ix, iy + 1), noise(ix + 1, iy + 1), noise(ix + 2, iy + 1)},
		{noise(ix - 1, iy + 2), noise(ix, iy + 2), noise(ix + 1, iy + 2), noise(ix + 2, iy + 2)}
	};
	*/

	printf("ix = %d, iy = %d\n", ix, iy);

	const float fract_x = fract(pos[0]);

	float val_from_noise_map(const NoiseMap noise_map, const int x, const int y);

	const float
		tl = val_from_noise_map(noise_map, ix + 1, iy + 1), tr = val_from_noise_map(noise_map, ix + 2, iy + 1),
		bl = val_from_noise_map(noise_map, ix + 1, iy + 2), br = val_from_noise_map(noise_map, ix + 2, iy + 2);

	const float
		noise_top = lerp(tl, tr, fract_x),
		noise_bottom = lerp(bl, br, fract_x);
		// noise_top = lerp(noise_from_samples(1, 1, noise_map), noise_from_samples(2, 1, noise_map), fract_x),
		// noise_bottom = lerp(noise_from_samples(1, 2, noise_map), noise_from_samples(2, 2, noise_map), fract_x);

	return lerp(noise_top, noise_bottom, fract(pos[1]));
}

float perlin_2D(const vec2 pos, const NoiseMap noise_map) {
	float noise = result_addend, amplitude = powf(persistence, first_octave);
	int frequency = 2 << (first_octave - 1);

	// Fractal brownian motion
	for (int i = first_octave; i < octaves + first_octave; i++, frequency <<= 1, amplitude *= persistence)
		noise += lerp_noise((vec2) {pos[0] * frequency, pos[1] * frequency}, noise_map) * amplitude;

	if (noise > 1.0f) return 1.0f;
	return (noise < 0.0f) ? 0.0f : noise;
}

////////// An attempt at cacheing noise values (hard to do with frequencies):

float val_from_noise_map(const NoiseMap noise_map, int x, int y) {
	// if (x < 0 || y < 0) return 1.0f;
	// else if (x >= noise_map.size[0] || y >= noise_map.size[1]) return 1.0f;

	printf("x = %d, y = %d\n", x, y);
	// return noise_map.data[(y + 1) * (noise_map.size[0] + 3) + x + 1];
	y++;
	x++;
	return noise_map.data[y * noise_map.size[0] + x];
}

NoiseMap make_noise_map(const int size[2]) {
	/*
	1 more on the top, 1 more on the left, 
	*/

	/*
	const struct {
		const int top, left, bottom, right;
	} extra = {1, 1, 2, 2};
	*/

	const NoiseMap noise_map = {
		.data = malloc((size[0] + 3) * (size[1] + 3) * sizeof(noise_type_t)),
		.size = {size[0], size[1]}
	};

	for (int y = 0; y < size[1] + 3; y++) {
		noise_type_t* const row = noise_map.data + y * size[0];
		for (int x = 0; x < size[0] + 3; x++) row[x] = noise(x - 1, y - 1);
	}

	return noise_map;
}

SDL_Surface* make_perlin_map(const int size[2]) {
	SDL_Surface* const perlin_map = SDL_CreateRGBSurfaceWithFormat(0,
		size[0], size[1], SDL_BITSPERPIXEL(PIXEL_FORMAT), PIXEL_FORMAT);

	SDL_LockSurface(perlin_map);

	//////////

	enum {num_colors = 256};
	SDL_Color palette[num_colors];
	for (int i = 0; i < num_colors; i++) palette[i] = (SDL_Color) {i, i, i, 255};
	SDL_SetPaletteColors(perlin_map -> format -> palette, palette, 0, num_colors);

	//////////

	const vec2 downscale_vals = {1.0f / size[0] * scale, 1.0f / size[1] * scale};
	const int bytes_per_row = perlin_map -> pitch;
	Uint8* index_row = perlin_map -> pixels;
	const NoiseMap noise_map = make_noise_map(size);

	DEBUG((double) val_from_noise_map(noise_map, 2, 3), lf);

	for (int y = 0; y < size[1] + 3; y++) {
		putchar('{');

		for (int x = 0; x < size[0] + 3; x++)
			printf("%.8f, ", (double) noise_map.data[y * size[0] + x]);

		printf("%f}%s\n", (double) noise_map.data[y * size[0] + size[0] - 1], (y == size[1] - 1) ? "" : ",");
	}
	// exit(0);

	//////////

	for (int y = 0; y < size[1]; y++, index_row += bytes_per_row) {
		const float downscaled_y = y * downscale_vals[1];
		for (int x = 0; x < size[0]; x++)
			index_row[x] = perlin_2D((vec2) {x * downscale_vals[0], downscaled_y}, noise_map) * num_colors;
	}

	free(noise_map.data);

	SDL_UnlockSurface(perlin_map);
	return perlin_map;
}

/*
- Floats in noise map first, and then bytes later
- This should take command line arguments later
- 2D first, 3D later
- Compile this with the map code once done
*/

int main(void) {
	if (SDL_Init(SDL_INIT_VIDEO) < 0) {
		fprintf(stderr, "Could not launch SDL: '%s'\n", SDL_GetError());
		return 1;
	}

	SDL_Surface* const perlin_map = make_perlin_map((int[2]) {4, 4});
	SDL_SaveBMP(perlin_map, "out.bmp");
	SDL_FreeSurface(perlin_map);

	SDL_Quit();
}

/////

	/*
	if (!is_delim(*buffer, delims)) {
		puts("Not a delim");
		const char* const start = buffer;
		while (!is_delim(*buffer, delims)) buffer++;
		*buffer = '\0';
		buffer++;

		printf("start = '%s'\n", start);
		return start;
	}
	else {
		puts("A delim");

		while (is_delim(*buffer, delims)) {
			*buffer = '\0';
			buffer++;
		}
		return buffer;
	}
	*/

/////

	/*
	for (long i = 0; i < file_contents.num_bytes; i++) {
		const char c = file_contents.data[i];
		if (isspace(c)) continue;

		else if (c == token_defs.string_single_quote || c == token_defs.string_double_quote) {
			const long i_start = i + 1;
			while (file_contents.data[++i] != c) {
				if (i == file_contents.num_bytes || file_contents.data[i] == token_defs.newline)
					PARSE_FAIL(file_contents, "unterminated string", i_start - 1, i);
			}
			printf("A string: '%.*s'\n", (int) (i - i_start), file_contents.data + i_start);
		}
	}
	*/

/////

tokenize

/////

static void update_bob(Camera* const camera, GLfloat* const pos_y, vec3 speeds, const Uint64 curr_time, const GLfloat delta_time) {
	GLfloat bob_delta = 0.0f;

	// Remember to init the new var

	if (speeds[1] == 0.0f) {

		/*
		const GLfloat
			speed_forward_back = fabsf(speeds[0]),
			speed_strafe = fabsf(speeds[2]);

		const GLfloat largest_speed_xz = (speed_forward_back > speed_strafe) ? speed_forward_back : speed_strafe;
		const GLfloat speed_xz_percent = (largest_speed_xz / delta_time) / constants.speeds.xz_max;

		const GLfloat dt = (GLfloat) (curr_time - camera -> last_jump_time) / SDL_GetPerformanceFrequency();

		// Found through messing around with Desmos. With this, y will never go above the eye height.
		bob_delta = speed_xz_percent
			* sinf(3.75f * PI * (dt - 0.1333333333333333f))
			* 0.1f + 0.1f * speed_xz_percent;
		*/

		// *pos_y += bob_delta;
	}
	else camera -> last_jump_time = curr_time;
	// else camera -> bob_input = 0.0f;

	camera -> last_bob_delta = bob_delta; // TODO: set to bob delta, if possible
}

/////

physics_obj -> dv = sqrtf(speed_forward_back * speed_forward_back + speed_strafe * speed_strafe);

/////

	static vec3 last_pos;

	if (last_pos[0] == camera -> pos[0] && last_pos[1] == camera -> pos[1] && last_pos[2] == camera -> pos[2]) {
		puts("No change");
	}
	else puts("A change");

	memcpy(last_pos, camera -> pos, sizeof(vec3));

/////

		// const GLfloat delta = (sinf(4.0f * x) + 1.0f) / 8.0f; // Amplitude of 2

		// const GLfloat delta = (sinf(PI * x) + 1.0f) / 2.0f;

		// const GLfloat delta = (sinf(PI * (x - 1.0f)) / 4.0f) + 0.25f;

/////

	const GLfloat d = sqrtf(speed_forward_back * speed_forward_back + speed_strafe * speed_strafe);
	DEBUG(d / delta_time / constants.speeds.xz_max, lf);


/////

	static GLfloat last_x = 0.0f;
	if (camera -> pos[0] == last_x) puts("Bad");
	else puts("Good");
	last_x = camera -> pos[0];

/////

	// 0.38f and 0.4f for xz acceleration before

/////


	// memset(face_meshes_gpu, 0, _ * bytes_per_face);
	size_t all_bytes = 0;
	for (long i = 0; i < sectors -> length; i++) {
		all_bytes += ((Sector*) sector_data) -> face_range.length * bytes_per_face;
	}
	memset(face_meshes_gpu, 0, all_bytes);

/////

	static GLfloat last_x;
	if (last_x == new_x) puts("No movement");
	else puts("Something happened");
	last_x = new_x;

/////

	SDL_DisplayMode display_mode;
	SDL_GetDisplayMode(0, 0, &display_mode);
	*((int16_t*) &constants.fps) = display_mode.refresh_rate; // Evil cast! But has to be done.


/////

		// camera -> time_accum_not_jumping = SDL_GetTicks() / 1000.0f;
		// camera -> time_accum_not_jumping = 5;

/////

	/* Make it so that a certain height has to be reached

	y = y0 + v0t + 0.5at^2

	g = (2*jumpHeight)/(timeToApex^2)
	initJumpVelocity = math.sqrt(2*g*jumpHeight)
	timeToApex = initJumpVelocity/g */

/////


	/*
	const GLfloat l = pos[1];
	pos[1] = foot_height + constants.camera.eye_height;
	if (l > pos[1]) printf("Decr from %lf\n", (double) l);
	else puts("---");
	*/

/////

	static GLfloat ly;
	pos[1] = foot_height + constants.camera.eye_height;
	if (ly > pos[1]) printf("Decr: %lf\n", (double) new_y);
	else puts("---");
	ly = pos[1];

///// Vectorized XZ physics:

// TODO: to excluded
static void update_pos_xz_via_physics(const byte movement_bits,
	const byte map_size[2], const byte* const heightmap,
	PhysicsObject* const physics_obj, const GLfloat delta_time,
	const GLfloat foot_height, const vec2 dir_xz, vec2 pos_xz) {

	const GLfloat max_speed_xz = constants.speeds.xz_max * delta_time; // `* delta_time` gives a per-tick value

	vec2 speeds_xz = {physics_obj -> speeds[0] * delta_time, physics_obj -> speeds[2] * delta_time};
	const vec2 accel_xz = {constants.accel.forward_back * delta_time, constants.accel.strafe * delta_time};

	speeds_xz[0] = apply_movement_in_xz_direction(speeds_xz[0], accel_xz[0],
		max_speed_xz, movement_bits & BIT_MOVE_FORWARD, movement_bits & BIT_MOVE_BACKWARD);

	speeds_xz[1] = apply_movement_in_xz_direction(speeds_xz[1], accel_xz[1],
		max_speed_xz, movement_bits & BIT_STRAFE_LEFT, movement_bits & BIT_STRAFE_RIGHT);

	const byte
		*const map_size = physics_obj -> map_size,
		*const heightmap = physics_obj -> heightmap;

	pos_xz[0] = apply_collision_on_xz_axis(
		heightmap, map_size, 0, pos_xz, foot_height,
		pos_xz[0] + speeds_xz[0] * dir_xz[0] - speeds_xz[1] * -dir_xz[1]);
	
	pos_xz[1] = apply_collision_on_xz_axis(
		heightmap, map_size, 1, pos_xz, foot_height,
		pos_xz[2] + speeds_xz[0] * dir_xz[1] - speeds_xz[1] * dir_xz[0]);
	
	physics_obj -> speeds[0] /= delta_time;
	physics_obj -> speeds[1] /= delta_time;
}

/////

	if ((movement_bits & BIT_TILT_LEFT) && ((tilt += tilt_speed) > constants.camera.lims.tilt)) // Left
		tilt = constants.camera.lims.tilt - 0.01f;

	if ((movement_bits & BIT_TILT_RIGHT) && ((tilt -= tilt_speed) < -constants.camera.lims.tilt)) // Right
		tilt = -constants.camera.lims.tilt + 0.01f;

/////

	const size_t num_bytes = num_visible_faces * bytes_per_face;
	const double num_kilobytes = num_bytes / 1024.0;
	DEBUG(num_kilobytes, lf);

/////

		/*
		else if (c == token_defs.string_single_quote || c == token_defs.string_double_quote) {
			printf("Tokenizing string, starting with char '%c'\n", c);
			for (char c = *buffer; c != '\0' && c != first; c = *(buffer++));
			break;
		}
		*/

		else if (char_in_set(c, "{}[]:,")) {
			puts("Stop early");
			break;
		}

/////

	/*
	if (first == token_defs.string_single_quote || first == token_defs.string_double_quote) {
		puts("Capture the whole string");
		for (char c = *buffer; c != '\0' && c != first; c = *(buffer++));
		*(buffer++) = '\0';
		return start;
	}
	*/

	/*
	else if (char_in_set(first, "{}[]:,")) {
		printf("Special char: '%c'\n", first);

		// 1 is lost probably

		// char after = *(++buffer);
		// DEBUG(after, c);

		*(++buffer) = '\0';
		buffer++;
		return start;
	}
	*/

/////

		// glm_aabb_aabb;

		// if (!point_exists_at(foot_height, params, heightmap, map_size[0])) return new_pos_component;

		// params[varying_axis] -= 0.4f;
		// if (!point_exists_at(foot_height, params, heightmap, map_size[0])) return new_pos_component;

/////

// TODO: to excluded
static byte point_exists_at(const GLfloat foot_height, const vec2 pos, const byte* const heightmap, const byte map_width) {
	const byte height_value = *map_point((byte*) heightmap, pos[0], pos[1], map_width);
	return !(foot_height - height_value > -0.001f);
}

/////

	if (event -> movement_bits & BIT_SPEED_UP) {
		const GLfloat time_for_full_speedup = 0.8f;
		GLfloat time_ratio = camera -> time_spent_speeding_up / time_for_full_speedup;
		if (time_ratio > 1.0f) time_ratio = 1.0f;

		DEBUG((double) time_ratio, lf);
		camera -> time_spent_speeding_up += delta_time;

		camera -> angles.fov = constants.camera.init.fov + fov_addition;

		/*
		const GLfloat time_for_full_speedup = 0.8f;
		GLfloat time_ratio = camera -> time_spent_speeding_up / time_for_full_speedup;
		if (time_ratio > 1.0f) time_ratio = 1.0f;
		DEBUG((double) time_ratio, lf);

		const GLfloat fov_addition = 0.15f * camera -> speed_xz_percent * time_ratio;
		camera -> angles.fov = constants.camera.init.fov + fov_addition;

		camera -> time_spent_speeding_up += delta_time;
		*/
	}
	else camera -> time_spent_speeding_up = 0.0f;

	/*
	const GLfloat speed_xz_percent = camera -> speed_xz_percent;
	const GLfloat fov_addition = 0.15f * speed_xz_percent;
	DEBUG(fov_addition, lf);
	camera -> angles.fov = constants.camera.init.fov + fov_addition;
	*/

/////

	// printf("speeds_xz = {%lf, %lf}\n", (double) speeds_xz[0], (double) speeds_xz[1]);
	// vec3 normalized;
	// glm_vec3_normalize_to(speeds, normalized);
	// printf("normalized = {%lf, %lf, %lf}\n", (double) normalized[0], (double) normalized[1], (double) normalized[2]);

	/*
	const GLfloat length = glm_vec2_norm(speeds_xz);
	DEBUG((double) length, lf);
	*/

	// DEBUG((double) speed_x, lf);
	//////////
	// Left or right shift

	// const GLfloat forward_backward_speed_percent =
	
	// camera -> speed_xz_percent;
	// camera -> angles.fov = constants.camera.init.fov + 0.1f * fastness;

	/*
	if (event -> movement_bits & BIT_SPEED_UP) {
		camera -> i += delta_time;
	}
	else camera -> i -= delta_time;

	DEBUG((double) camera -> i, lf);
	*/

	/*
	const GLfloat speed_xz_percent = camera -> speed_xz_percent;
	const GLfloat fov_addition = 0.15f * speed_xz_percent;
	DEBUG(fov_addition, lf);
	camera -> angles.fov = constants.camera.init.fov + fov_addition;
	*/

/////

	/*
	Solve for time for max speed

	x = x0 + v0t + 0.5at^2

	dx = v0t + 0.5at^2

	- A is known
	v0 = 0

	dx = 0.5at^2

	dx / 0.5a = t^2
	t = sqrt(dx / 0.5a)

	dx = max_v * 0.5f * t

	_____
	v = v0 + at
	v = at
	v / a = t
	*/

/////

Definitions;
- shadow-casting object = an object that casts a shadow, so a face

Constructing one shadow volume for a face:
1. Connect light source to vertex in the shadow-casting object
2. That volume shows everything which will be lit
3. Light source is point light

Constructing one shadow volume:
1. Project a ray from light source through each vertex (corner) in the shadow-casting object
2. Those rays together form a shadow volume
3. Anything inside the volume is a shadow, and everything else is lit
3.5. Perhaps generate a joined volume per sector; many joined face volumes

project a ray from the light source through each vertex in the shadow
casting object to some point (generally at infinity).
These projections will together form a volume;
any point inside that volume is in shadow, everything outside is lit by the light.

/////

- Telling if pixel is inside shadow volume?

- For one fragment: num back - num front
- If behind object shadow, can't see it (on other side of sector, on the light source side)
- For first pass, if depth fails, shadow behind object
- Fir second pass, if depth passes, decr
- If in front of object shadow,

- Number counts the number of shadows in front of object

/////

		/*
		Ray from light to vertex
		Pos and dir

		Pos is light
		Dir is _
		Not normalized
		*/

		/*
		vec3 direction;
		glm_vec3_sub((GLfloat*) light_source_pos, (GLfloat*) vertex_pos, direction);
		*/

/////


		/*
		GLfloat v;
		byte found_v = 0;
		for (byte i = 0; i < 3; i++) {
			// if (i == 0) i = 2;
			// else if (i == 2) i = 0;
			v = (20 - vertex_pos[i]) / direction[i];
			if (v < 0.0f) {
				printf("Found %c solution\n", 'x' + i);
				found_v = 1;
				break;
			}
		}

		if (!found_v) {
			for (byte i = 0; i < 3; i++) {
				v = -vertex_pos[i] / direction[i];
				if (v < 0.0f) {
					found_v = 1;
					break;
				}
			}
		}
		*/

/////

	DEBUG_VEC3(vertex_pos);

		vec3 direction;
		glm_vec3_sub((GLfloat*) vertex_pos, (GLfloat*) light_source_pos, direction);
		// glm_vec3_normalize(direction);

		DEBUG_VEC3(direction);

		/*
		- Intersecting plane will be flat
		- And for this plane, y = 0

		Ray:
		p = p0 + dir * v
		Solve for v when p.y == 0

		p.xyz = p0.xyz + dir.xyz * v

		p.y = p0.y + dir.y * v
		0 = p0.y + dir.y * v
		-p0.y = dir.y * v
		-p0.y / dir.y = v

		p.x = p0.x + dir.x * v
		20 = p0.x + dir.x * v
		20 - p0.x = dir.x * v
		(20 - p0.x) / dir.x) = v

		p.z = p0.z + dir.z * v
		*/

		/*
		if (direction[0] < 0.0f) {
			puts("X is negative dir");
		}
		else {
			puts("X is positive dir");
		}
		*/

		GLfloat v_for_plane_solutions[3];
		for (byte i = 0; i < 3; i++) {
			GLfloat dividend = vertex_pos[i];
			// if (i >= 3) dividend += 10.0f;
			if (direction[i] > 0.0f) dividend += 10.0f;
			v_for_plane_solutions[i] = dividend / direction[i];

			DEBUG((double) v_for_plane_solutions[i], lf);
		}

		GLfloat smallest = min(v_for_plane_solutions, 3);
		DEBUG(smallest, lf);

		vec3 plane_endpoint;
		glm_vec3_copy((GLfloat*) vertex_pos, plane_endpoint);
		glm_vec3_muladds(direction, -smallest, plane_endpoint);

		/*
		for (byte i = 0; i < 3; i++) {
			const GLfloat component = plane_endpoint[i];
			if (component < 0.0f) plane_endpoint[i] = 0.0f;
			else if (component > 20.0f) plane_endpoint[i] = 20.0f;
		}
		*/

		// If v > 0, light source extends to infinity
		DEBUG_VEC3(plane_endpoint);
		puts("---");

/////


			GLfloat pos_y = vertex_pos[i] + dir_y * v[i];
			DEBUG(pos_y, lf);

			vec3 plane_endpoint;
			glm_vec3_copy((GLfloat*) vertex_pos, plane_endpoint);
			glm_vec3_muladd(direction, v, plane_endpoint);
			const GLfloat dist_to_endpoint = glm_vec3_norm(plane_endpoint);
			DEBUG((double) dist_to_endpoint, lf);

			// Find the most optimal result for each 

			// What is I for then?

			/*
			GLfloat result = 0.5f;
			for (byte axis = 0; axis < 3; axis++) {
				GLfloat dividend = -vertex_pos[axis];
				const GLfloat dir_component = direction[axis];
				if (dir_component > 0.0f) dividend += flat_plane_size;
				const GLfloat v_component = dividend / dir_component;

				vec3 plane_endpoint;
				glm_vec3_copy((GLfloat*) vertex_pos, plane_endpoint);
				glm_vec3_muladd(direction, v, plane_endpoint);
				const GLfloat dist_to_endpoint = glm_vec3_norm(plane_endpoint);

				DEBUG((double) dist_to_endpoint, lf);
				DEBUG(axis, d);
				puts("---");
			}
			v[i] = result;
			*/

/////

			GLfloat dividend = -vertex_pos[1];
			const GLfloat dir_y = direction[1];
			if (dir_y > 0.0f) dividend += 10.0f;
			v[i] = dividend / dir_y;

			GLfloat pos_y = vertex_pos[i] + dir_y * v[i];
			DEBUG(pos_y, lf);

			vec3 plane_endpoint;
			glm_vec3_copy((GLfloat*) vertex_pos, plane_endpoint);
			glm_vec3_muladd(direction, v, plane_endpoint);
			const GLfloat dist_to_endpoint = glm_vec3_norm(plane_endpoint);
			DEBUG((double) dist_to_endpoint, lf);

/////

		{2.262186, 3.362316, 7.743492});
		*/

		/*
		GLfloat v_for_plane_solutions[6];
		for (byte i = 0; i < 3; i++) {
			GLfloat dividend = vertex_pos[i];
			// if (direction[half_i] > 0.0f) dividend += 10.0f;
			// if (i >= 3) dividend += 10.0f;
			v_for_plane_solutions[i] = dividend / direction[i];

			DEBUG((double) v_for_plane_solutions[i], lf);
		}

		const GLfloat smallest_neg_v = min(v_for_plane_solutions, 6);
		DEBUG(smallest_neg_v, lf);
		*/

/////

GLfloat min(const GLfloat* const array, const byte length) {
	GLfloat smallest = FLT_MAX;
	for (byte i = 0; i < length; i++) {
		const GLfloat val = array[i];
		if (val > 0.0f) continue;
		else if (fabsf(val) < fabsf(smallest)) smallest = val;
	}
	return smallest;
}

///// Good to know:

		/* - Intersecting plane will be flat
		- And for this plane, y = 0

		Ray:
		p = p0 + dir * v
		Solve for v when p._ == 0 or 20

		p = p0 + dir * v (all vectors except for v)

		p.y = p0.y + dir.y * v
		0 = p0.y + dir.y * v
		-p0.y = dir.y * v
		-p0.y / dir.y = v

		20 = p0.y + dir.y * v
		20 - p0.y = dir.y * v
		(20 - p0.y) / dir.y = v

		- Find closest plane intersection for all 3 vertices; smallest resulting distance for component
		- And for non-intersecting planes, detect if any intersection happens at all
		- Note: for the X plane test, the current triangle failed b/c it could never intersect with an X plane
		*/

/////

			/*
			typedef struct {
				char axis;
				GLfloat dist_to_plane, plane_endpoint_component;
			} RayFromVertex;

			RayFromVertex ray_plane_collisions[3]; // Collisions on different plane axes
			
			// Finding the closest axis
			for (byte testing_axis = 0; testing_axis < 3; testing_axis++) {
				GLfloat dividend = -vertex_pos[testing_axis];
				const GLfloat ray_direction_component = ray_direction[testing_axis];
				if (ray_direction_component > 0.0f) dividend += flat_plane_size;

				const GLfloat v = dividend / ray_direction_component;

				const GLfloat ray_length = ray_direction_component * v;
				GLfloat plane_endpoint_component = vertex_pos[testing_axis] + ray_length;
				ray_plane_collisions[testing_axis] = (RayFromVertex) {'x' + testing_axis, ray_length, plane_endpoint_component};
			}

			printf("ray_plane_collisions = ");

			RayFromVertex closest_ray = {'a', FLT_MAX, -1.0f};
			for (byte axis = 0; axis < 3; axis++) {
				const RayFromVertex ray = ray_plane_collisions[axis];
				printf("{%c, %lf, %lf} ", ray.axis, (double) ray.dist_to_plane, (double) ray.plane_endpoint_component);
				if (ray.dist_to_plane < closest_ray.dist_to_plane)
					closest_ray = ray;
			}

			printf("\nclosest_ray = {.dist_to_plane = %lf, .plane_endpoint_component = %lf}\n",
				(double) closest_ray.dist_to_plane, (double) closest_ray.plane_endpoint_component);

			ray_params[component_index] = closest_ray.plane_endpoint_component;
			puts("---");
		}
		*/

/////


			/*
			for (byte test_axis = 0; test_axis < 3; test_axis++) {
				GLfloat dividend = -vertex_pos[1];
				const GLfloat dir_component = ray_dir[1];
				if (dir_component > 0.0f) dividend += flat_plane_size;
				ray_v[test_axis] = dividend / dir_component;
			}
			*/

/////

		vec3 plane_endpoint;
		plane_endpoint[0] = vertex_pos[0] + ray_dir[0] * ray_v_for_closest_intersection[0];
		plane_endpoint[1] = vertex_pos[1] + ray_dir[1] * ray_v_for_closest_intersection[1];
		plane_endpoint[2] = vertex_pos[2] + ray_dir[2] * ray_v_for_closest_intersection[2];

/////

	/*
		vec3 ray_v;

		for (byte v_component_ind = 0; v_component_ind < 3; v_component_ind++) {
			// printf("For ray to plane, testing ray component %c\n", 'x' + component_ind);

			// For each ray component, find the shortest optimal intersecting axis

			GLfloat dividend_x = -vertex_pos[0];
			const GLfloat dir_x = ray_dir[0];
			if (dir_x > 0.0f) dividend_x += flat_plane_size;
			const GLfloat ray_v_for_x_intersection = dividend_x / dir_x;

			GLfloat dividend_y = -vertex_pos[1];
			const GLfloat dir_y = ray_dir[1];
			if (dir_y > 0.0f) dividend_y += flat_plane_size;
			const GLfloat ray_v_for_y_intersection = dividend_y / dir_y;

			GLfloat dividend_z = -vertex_pos[2];
			const GLfloat dir_z = ray_dir[2];
			if (dir_z > 0.0f) dividend_z += flat_plane_size;
			const GLfloat ray_v_for_z_intersection = dividend_z / dir_z;

			for (byte _ = 0; _ < 3; _++) ray_v[_] = ray_v_for_y_intersection;

			vec3 plane_endpoint;
			glm_vec3_copy((GLfloat*) vertex_pos, plane_endpoint);
			glm_vec3_muladd(ray_dir, ray_v, plane_endpoint);
			push_ptr_to_list(&cone_vertices, plane_endpoint);

			if (i == 0) printf("solution = {%lf, %lf, %lf}\n", (double) ray_v[0], (double) ray_v[1], (double) ray_v[2]);

			// Find the shortest distance to a plane with this direction, given a vertes
		}
		*/

/////

		// Can only get an intersection after all components have been gathered
		// Every intersection, at some level, will technically be the same; it's just that they ___
		// If the volume is out of bounds, perhaps change V for continual axes until a refined volume is reached

		// DEBUG(ray_dir[1], lf);

		/*
		const byte axis = keys[SDL_SCANCODE_C] + keys[SDL_SCANCODE_V];
		const GLfloat v = get_v_for_ray_to_plane(axis, flat_plane_size, vertex_pos, ray_dir);
		// const GLfloat v = 50.0f;

		for (byte v_axis = 0; v_axis < 3; v_axis++)
			ray_v_for_closest_intersection[v_axis] = v;

		vec3 plane_hit;
		glm_vec3_copy((GLfloat*) vertex_pos, plane_hit);
		glm_vec3_muladd(ray_dir, ray_v_for_closest_intersection, plane_hit);

		for (byte hit_axis = 0; hit_axis < 3; hit_axis++) {
			const GLfloat hit_component = plane_hit[hit_axis];
			// if (hit_component < 0.0f || hit_component > 5.0f)
				// printf("Problemo: {%.15lf, %.15lf, %.15lf}\n", plane_hit[0], plane_hit[1], plane_hit[2]);
			if (hit_component < 0.0f) {
				printf("Clip %c on the bottom side: %lf\n", 'x' + hit_axis, (double) hit_component);
				plane_hit[hit_axis] = 0.0f;
			}
			// if (hit_component > 5.0f) plane_hit[hit_axis] = 5.0f;
		}
		puts("---");
		*/

/////

	/* To begin with, form a cone between the camera and the vertices

	For each vertex, form a connection
	Store those in a list
	Then, build triangles out of the connections

	Later on, reverse it

	And at some point, discard forward-facing vertices

	All vertices must actually not share the same plane; they can, but it's optional

	The axis result may actually work in most cases now!
	If that's the case, I now just need to occupy the rest of the scene with another volume,
	and use primitive restart to make another triangle fan
	But test this rigorously to see that that's true
	*/

/////

byte value_in_list(List* const list, const void* const value, byte (*const values_eq) (const void*, const void*)) {

	for (buffer_size_t i = 0; i < list -> length; i++) {
		if (values_eq(value, list -> data + i)) {
			
		}
	}
}

///// Some vbo and ibo printing:

	/*
	puts("");
	for (buffer_size_t i = 0; i < volume_vertices.length; i++) {
		const GLfloat* const vertex = ((GLfloat*) volume_vertices.data) + i * 3;
		DEBUG_VEC3(vertex);
	}
	puts("---");

	// Also print indices
	for (buffer_size_t i = 0; i < volume_indices.length; i++) {
		const buffer_size_t index = ((buffer_size_t*) volume_indices.data)[i];
		DEBUG(index, d);
	}
	*/


/////

Or better way:
	- Get vertices to make all other shapes touch the map edge
	- For each such vertex v,
		new direction d
		colliding axis's direction set for that vertex
		other 

	For origin that should collide with a face,

	- Get another verte

Or no no
- For each vertex that hit a plane,
	m = the one that extended the farthest

Or,

/////

- For building an ending bounding cap:
	- Construct a new vector, with the working axes in the right component indices
	- For each failed collision axis, put the minimum or maximum value for that axis in its index

/////

/*
Generating shadow volumes
- On a per-sector basis
- For each face in sector, find if facing towards or away from light
- Take away-facing faces
- The vertices that connect the forward-facing to away-facing faces form a silhouette
- Take those vertices, and form a volume outline
- Light source -> outline is not part of the shadow volume
- Shadow volume starts at silhouette vertices

- Forming a cone
For each vertex in the silhouette,
	- Get the vector between the light and the vertex
	- Extend that vector until it reaches a map boundary (or to another sector cube?)

- Make two caps on each end, as some triangles
- Make a shadow volume as triangles for the volume sides as well

Rendering shadow volumes

Depth pass:
- Disable writes to the depth and color buffers

- Set the stencil operation to increment on depth pass (only count shadows in front of the object/sector)
- Use backface culling, and render the shadow volumes (only front faces rendered, and only objs in front counted)

- Set the stencil operation to decrement on depth pass
- Use front face culling, and render the shadow volumes (only back faces rendered, and only objects behind counted)

- After this is accomplished, all lit surfaces will correspond to a 0 in the stencil buffer,
	where the numbers of front and back surfaces of all shadow volumes between the eye and that surface are equal.

- After this, all lit surfaces will have a 0 value in the stencil buffer,
	where the number of front and back surfaces of shadow volumes between eye and surface are equal
- 0 values in stencil buffer are lit then, and >= 1 values are darkened

- If stencil buf val is postiive, in shadow (more front facing than back facing)
- Zero, no shadow (since if you look through a shadow and just see another shadow through it, no shadow seen,
	since shadows are only defined by the objects that they hit)

Depth fail:
- Disable writes to the depth and color buffers
- Frontface culling, incr on depth fail (count shadows behind obj), and render
- Backface culling, decr on depth fail (decr for shadows in front of obj (i.e., visible)), and render (front faces rendered)
- Then, stencil buffer vals that equal 0 are lit

Optimiz

/////


/*
- To begin with, just draw all in one big unbatched buffer
- Batching after
- Only using instancing for glVertexAttribDivisor
*/

/////

	// buffer_size_t index = 5;

	/*
	const buffer_size_t num_unique_vertices_before = volume_vertices -> length;
	DEBUG(num_unique_vertices_before, d);

	push_ptr_to_list(volume_indices, &shadow_volume_prim_restart_index);

	buffer_size_t index = 5;
	push_ptr_to_list(volume_indices, &index);
	index++;

	push_ptr_to_list(volume_vertices, ((vec3) {0.0f, 0.0f, 5.0f}));
	push_ptr_to_list(volume_vertices, ((vec3) {0.334837f, 0.0f, 5.0f}));
	push_ptr_to_list(volume_vertices, ((vec3) {1.186644f, 0.0f, 5.0f}));
	push_ptr_to_list(volume_vertices, ((vec3) {0.892137f, 0.861584f, 5.0f}));

	push_ptr_to_list(volume_indices, &index);
	index++;
	push_ptr_to_list(volume_indices, &index);
	index++;
	push_ptr_to_list(volume_indices, &index);
	*/

/////

void init_shadow_volume_buffer_end_cap(const GLfloat flat_plane_size,
	List* const volume_vertices, List* const volume_indices) {
	
	/*
	push_ptr_to_list(volume_indices, &shadow_volume_prim_restart_index);

	buffer_size_t index = volume_vertices -> length;

	push_ptr_to_list(volume_vertices, ((vec3) {0.063558, 0.0f, 4.041692}));
	push_ptr_to_list(volume_indices, &index);
	index++;

	push_ptr_to_list(volume_vertices, ((vec3) {0.990571f, 0.070705f, 3.021517f}));
	push_ptr_to_list(volume_indices, &index);
	index++;

	push_ptr_to_list(volume_vertices, ((vec3) {2.387257f, 0.098781f, 3.123181f}));
	push_ptr_to_list(volume_indices, &index);
	index++;
	*/

	/*
	for (buffer_size_t i = 0; i < volume_indices -> length; i++) {
		const buffer_size_t volume_index = value_at_list_index(volume_indices, i, buffer_size_t);
		const GLfloat* const volume_vertex = ptr_to_list_index(volume_vertices, volume_index);

		DEBUG(volume_index, d);
		DEBUG_VEC3(volume_vertex);
		puts("---");
	}
	*/

	// Start by making bottom plane of end cap

	puts("Forming shadow volume buffer end cap");

	(void) flat_plane_size;
	(void) volume_vertices;
	(void) volume_indices;
}

/////

	init_shadow_volume_buffer_end_cap(flat_plane_size, &volume_vertices, &volume_indices);
/////

	// GL_TRIANGLE_FAN is not the best idea

	/*
	Middle:

	src = 1, 2, 3

	
	*/

///// Older important code:

// (p = p0 + dir * v) => (p - p0 = dir * v) => ((p - p0) / dir = v)
GLfloat get_v_for_ray_to_plane(const Axis axis, const GLfloat flat_plane_size, const vec3 origin_vertex, const vec3 ray_dir) {
	GLfloat dividend = -origin_vertex[axis];
	const GLfloat dir_component = ray_dir[axis];
	if (dir_component > 0.0f) dividend += flat_plane_size;
	return dividend / dir_component;
}

GLfloat floats_eq(const GLfloat a, const GLfloat b) {
	return fabsf(b - a) < constants.almost_zero;
}

GLfloat vec3_eq(const vec3 a, const vec3 b) {
	// return floats_eq(a[0], b[0]) && floats_eq(a[1], b[1]) && floats_eq(a[2], b[2]);
	return a[X] == b[X] && a[Y] == b[Y] && a[Z] == b[Z];
}

// If the plane hit failed, returns the failing axis; otherwise, returns -1. Modifies plane_hit.
Axis get_plane_hit_for_axis(const Axis axis, const GLfloat flat_plane_size,
	const vec3 origin_vertex, const vec3 ray_dir, vec3 plane_hit) {

	const GLfloat v = get_v_for_ray_to_plane(axis, flat_plane_size, origin_vertex, ray_dir);

	glm_vec3_copy((GLfloat*) origin_vertex, plane_hit);
	glm_vec3_muladds((GLfloat*) ray_dir, v, plane_hit);

	for (Axis hit_axis = X; hit_axis <= Z; hit_axis++) {
		GLfloat hit_component = plane_hit[hit_axis];

		/* Sometimes, due to precision errors, values can be slightly less than 0, leading
		to a component being incorrectly recognized as out of bounds; so this adjusts that */
		if (floats_eq(hit_component, 0.0f)) hit_component = 0.0f;
		else if (floats_eq(hit_component, flat_plane_size)) hit_component = flat_plane_size;
		else if (hit_component < 0.0f || hit_component > flat_plane_size) return hit_axis;

		plane_hit[hit_axis] = hit_component;
	}
	return NoAxis;
}

/////

	// DEBUG(volume_indices.length, d);
	// const 

	for (buffer_size_t i = 0; i < volume_vertices.length; i++) {
		const GLfloat* const front_cap_vertex = ptr_to_list_index(&volume_vertices, i);

		vec3 ray_dir;
		glm_vec3_sub((GLfloat*) front_cap_vertex, (GLfloat*) light_source_pos, ray_dir);

		buffer_size_t index = volume_indices.length + i;
		push_ptr_to_list(&volume_indices, &index);
		index++;
		push_ptr_to_list(&volume_indices, &index);

		// 2 indices per edge
		index = 200;
		push_ptr_to_list(&volume_indices, 200);

		DEBUG_VEC3(ray_dir);

		/*
		Extending ray to infinity:
		equation for point on ray is `p = p0 + dir * v`
		Since `p` should be at infinity, this is how I solve for `v`:
		`(p - p0) = dir * v`, so `(p - p0) / dir` = v`, where `p` equals infinity
		*/
	}

/////

	/*
	DEBUG(volume_vertices.length, d);
	const buffer_size_t end_index = volume_indices.length;
	push_ptr_to_list(&volume_vertices, ((vec3) {1.460835, 2.720556, 5.499548}));

	for (buffer_size_t corner_index = 0; corner_index < num_vertices_per_occluder_mesh; corner_index++) {
		const buffer_size_t neighbor_corner_index = (corner_index + 1) % num_vertices_per_occluder_mesh;

		push_ptr_to_list(&volume_indices, &corner_index);
		push_ptr_to_list(&volume_indices, &neighbor_corner_index);

		push_ptr_to_list(&volume_indices, &end_index);

		DEBUG(neighbor_corner_index, d);
	}
	*/


/////


	/*
	Positions:
	{5.0f, 0.486f, 0.0f} and {2.5f, 2.5f, 5.0f} are on one one plane
	{2.3f, 0.486f, 2.6f} and {2.425301f, 0.111759f, 2.026766f} are on three planes
	{5.0f, 3.05f, 0.0f}) is on two planes
	*/

/////


Other notes:
- Volume edges should maybe be at infinity
- And point light should perhaps solely be directional, not positional
- Is there a necessary reason for the volume taking up infinite space?
- Also, for constructing another shadow volume, primitive restart will be needed, which also requires indexing
- Construct other meshes within the same vbo for the shadow volume; one for the start cap, and one for the end

- Note: an occluder mesh with more than just 1 triangle does not work yet
- Also, find size for this and below (below size is probably num_vertices_per_mesh + 1)

For each vertex v that hit a plane,
	e = endpoint
	get collision point of plane to e
	that will be out of bounds
	so, define e'
	e'.(colliding axis of v) = v.dir
	preserve the other axis values

/////

/*
void init_shadow_volume_buffers(ShadowVolumeContext* const context, const GLfloat flat_plane_size,
	const vec3 light_source_pos, const buffer_size_t num_components_per_whole_vertex,
	const buffer_size_t num_vertices_per_occluder_mesh, const GLfloat* const vertex_start) {

	List volume_vertices = init_list(1, vec3), volume_indices = init_list(1, buffer_size_t);

	push_ptr_to_list(&volume_vertices, light_source_pos);

	const buffer_size_t zero = 0;
	push_ptr_to_list(&volume_indices, &zero); // Pushing index of start of triangle fan

	for (buffer_size_t vertex_index = 0; vertex_index < num_vertices_per_occluder_mesh; vertex_index++) {
		const GLfloat* const origin_vertex = vertex_start + vertex_index * num_components_per_whole_vertex;

		vec3 ray_dir, plane_hit;
		glm_vec3_sub((GLfloat*) origin_vertex, (GLfloat*) light_source_pos, ray_dir);

		////////// This part finds the intersection between the silhouette ray and the closest plane within bounds

		Axis colliding_axis = NoAxis;
		for (Axis test_axis = X; test_axis <= Z; test_axis++) {
			const Axis failing_axis = get_plane_hit_for_axis(test_axis, flat_plane_size, origin_vertex, ray_dir, plane_hit);
			if (failing_axis == NoAxis) {
				colliding_axis = test_axis;
				break;
			}
		}

		if (colliding_axis == NoAxis) // This should never happen
			fail("create mesh: unable to clip shadow volume mesh inside bounding area", CreateMesh);

		////////// This part finds if the colliding vertex was a repeat; and if so, adds the old index to the index buffer

		byte repeated_colliding_vertex = 0; // If the vertex was already present in the vertex list
		for (buffer_size_t prev_colliding_index = 0; prev_colliding_index < volume_vertices.length; prev_colliding_index++) {
			const GLfloat* const prev_colliding_vertex = (GLfloat*) volume_vertices.data + prev_colliding_index * 3;
			if (vec3_eq(prev_colliding_vertex, plane_hit)) {
				push_ptr_to_list(&volume_indices, &prev_colliding_index);
				repeated_colliding_vertex = 1;
				break;
			}
		}

		//////////

		if (!repeated_colliding_vertex) {
			push_ptr_to_list(&volume_vertices, plane_hit);
			const buffer_size_t incr_vertex_index = vertex_index + 1; // b/c first index value is the light position
			push_ptr_to_list(&volume_indices, &incr_vertex_index);
		}
	}

	context -> shadow_volume.num_indices = volume_indices.length;

	glGenBuffers(1, &context -> shadow_volume.vertex_buffer);
	glBindBuffer(GL_ARRAY_BUFFER, context -> shadow_volume.vertex_buffer);
	glBufferData(GL_ARRAY_BUFFER, sizeof(vec3[volume_vertices.length]), volume_vertices.data, GL_STATIC_DRAW);

	glGenBuffers(1, &context -> shadow_volume.index_buffer);
	glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, context -> shadow_volume.index_buffer);
	glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(buffer_size_t[volume_indices.length]), volume_indices.data, GL_STATIC_DRAW);

	deinit_list(volume_indices);
	deinit_list(volume_vertices);
}
*/

/////

	/*
	front cap: 0, 1, 2
	end cap: 3, 4, 5

	side 1:
	0, 3, 4; 0, 1, 4

	i, i + 3, i + 4, i, i + 1, i + 4
	*/

/////

	for (buffer_size_t i = 0; i < volume_indices.length; i++) {
		const buffer_size_t index = value_at_list_index(&volume_indices, i, buffer_size_t);
		DEBUG(index, u);
	}

/////

	/*
	for (buffer_size_t i = 0; i < volume_vertices.length; i++) {
		buffer_size_t tris[6] = {i, i + 3, i + 4, i, i + 1, i + 4};
		for (byte i = 0; i < 6; i++) {
			tris[i] = tris[i] % 6;
		}


		printf("pushing vals = {%u, %u, %u, %u, %u, %u}\n", tris[0], tris[1], tris[2], tris[3], tris[4], tris[5]);
		push_array_to_list(&volume_indices, tris, 6);
		// break;
	}
	*/

/////

// `~` sets all bits in 0 here, making it the max number for a buffer_size_t
// const buffer_size_t shadow_volume_prim_restart_index = ~((buffer_size_t) 0u);

/////

	// push_ptr_to_list(&volume_indices, &shadow_volume_prim_restart_index); // For edges after that; for later

/////

	/*
	glEnable(GL_PRIMITIVE_RESTART);
	glPrimitiveRestartIndex(shadow_volume_prim_restart_index);
	*/

/////

	////////// Debugging

	for (buffer_size_t i = 0; i < volume_vertices.length; i++) {
		const GLfloat* const vertex = ptr_to_list_index(&volume_vertices, i);
		DEBUG_VEC3(vertex);
	}


/////

/*
byte face_is_facing_light_source(const Face face, const byte height_origin, const vec3 light_pos) {
	switch (face.type) {
		case Flat: // Top face
			return light_pos[1] >= height_origin;
		case Vert_NS:
			if (face.

			break;
		case Vert_EW:
			break;
	}
	return 0;
}
*/

/////


	/*
	struct {
		byte flat, left_vert_ns, top_vert_eq, right_vert_ns, bottom_vert_ew;
	} visible = {
		.flat = 
	}

	DEBUG(sizeof(visible), zu);
	*/

	/*
	if (light_pos[1] > sector -> visible_heights.max) {
		puts("Flat face visible");
	}

	if (light_pos[0] < start_x) {
		puts("Left vert NS face visible");
	}
	else if (light_pos[0] > end_x) {
		puts("Right vert NS face visible");
	}

	if (light_pos[2] < start_y) {
		puts("Top vert EW face visible");
	}
	else if (light_pos[2] > end_y) {
		puts("Bottom vert EW face visible");
	}
	*/

/////

		/*
		const vec2 map_tile_center = {(byte) new_pos_w_old[0] + 0.5f, (byte) new_pos_w_old[0] + 0.5f};
		DEBUG_VEC2(map_tile_center);
		*/

/////

// TODO: to excluded
static byte point_inside_box(const vec3 point, const vec3 box_origin) {

	/*
	// [0] is x pos, [1] is 
	return
		point[0] >= box_origin[0] && point[0] <= (box_origin[0] + 1.0f)
		&&
		point[1] >= 	
		&&
		point[2] >= box_origin[2] && point[2] <= (box_origin[2] + 1.0f);
	*/
}

/////

	/*
	(void) heightmap;
	(void) map_size;
	(void) varying_axis;
	(void) old_pos;
	(void) foot_height;
	(void) new_pos_component;

	vec2 new_pos_w_old;
	new_pos_w_old[varying_axis] = new_pos_component;
	new_pos_w_old[!varying_axis] = old_pos[!varying_axis];

	const GLfloat border_size = 0.2f;
	const int8_t sign_of_dir = ((new_pos_component - old_pos[varying_axis]) > 0.0f) ? 1 : -1;
	new_pos_w_old[varying_axis] += border_size * sign_of_dir;

	// const GLfloat border_size = 0.2f;

	const byte floor_height = *map_point((byte*) heightmap, new_pos_w_old[0], new_pos_w_old[1], map_size[0]);

	if (floor_height > )

	DEBUG(floor_height, d);

	const vec2 map_point_box[2] = { // [0] is top left, and [1] is bottom right
		{(byte) new_pos_w_old[0] - border_size, (byte) new_pos_w_old[1] - border_size},
		{(byte) new_pos_w_old[0] + 1 + border_size, (byte) new_pos_w_old[1] + 1 + border_size}
	};

	printf("map box point goes from {%lf, %lf} to {%lf, %lf}\n",
		(double) map_point_box[0][0], (double) map_point_box[0][1],
		(double) map_point_box[1][0], (double) map_point_box[1][1]);

	if (new_pos_w_old[0] >= map_point_box[0][0] || new_pos_w_old[1] >= map_point_box[0][1] ||
		new_pos_w_old[0] <= map_point_box[1][0] || new_pos_w_old[1] <= map_point_box[1][1]) {

		if (foot_height - floor_height > -constants.almost_zero) return new_pos_component;
	}

	return new_pos_component;
	*/

/////

byte aabbs_are_colliding(const aabb box_1, const aabb box_2) {
	return
		(box_1.top_left[0] <= box_2.bottom_right[0] && box_1.bottom_right[0] >= box_2.bottom_right[0]) &&
		(box_1.top_left[1] <= box_2.bottom_right[1] && box_1.bottom_right[1] >= box_2.bottom_right[1]);
}

/////


	/*
	if (up ^ down) {
	}
	*/

	/*
	if (keys[SDL_SCANCODE_LEFT]) pos[0] -= step;
	if (keys[SDL_SCANCODE_RIGHT]) pos[0] += step;
	if (keys[SDL_SCANCODE_UP]) pos[1] -= step;
	if (keys[SDL_SCANCODE_DOWN]) pos[1] += step;

	if (pos[0] < 0.0f) pos[0] = 0.0f;
	else if (pos[0] >= map_width) pos[0] = map_width - almost_zero;
	if (pos[1] < 0.0f) pos[1] = 0.0f;
	else if (pos[1] >= map_height) pos[1] = map_height - almost_zero;

	const vec2 half_border = {border_size[0] * 0.5f, border_size[1] * 0.5f};

	// Check after each pos move

	const byte
		from_tl = has_point_at(pos[0] - half_border[0], pos[1] - half_border[1]),
		from_br = has_point_at(pos[0] + half_border[0], pos[1] + half_border[1]);

	printf("from_tl = %d, from_br = %d\n", from_tl, from_br);
	*/

	/*
	const byte floor_height = heightmap[(byte) pos[1]][(byte) pos[0]];
	if (floor_height == 0) return;

	const aabb pos_box = {
		.top_left = {pos[0] - border_size[0] * 0.5f, pos[1] - border_size[1] * 0.5f},
		.bottom_right = {border_size[0], border_size[1]}
	},
	tile_box = {
		.top_left = {(byte) pos[0], (byte) pos[1]},
		.bottom_right = {(byte) pos[0] + 1.0f, (byte) pos[1] + 1.0f}
	};

	if (aabbs_are_colliding(pos_box, tile_box)) {
		puts("Collision");
	}
	else {
		puts("No collision");
	}
	*/

/////

	const byte
		a = point_exists_at(pos_xz[0] - half_border[0], pos_xz[1] - half_border[1], heightmap, map_size),
		b = point_exists_at(pos_xz[0] + half_border[0], pos_xz[1] + half_border[1], heightmap, map_size),
		c = point_exists_at(pos_xz[0] - half_border[0], pos_xz[1] + half_border[1], heightmap, map_size),
		d = point_exists_at(pos_xz[0] + half_border[0], pos_xz[1] - half_border[1], heightmap, map_size);
	
	DEBUG(a, d);
	DEBUG(b, d);
	DEBUG(c, d);
	DEBUG(d, d);
	
	return a || b || c || d;

/////

// TODO: from excluded
static GLfloat apply_collision_on_xz_axis(const byte* const heightmap,
	const byte map_size[2], const byte varying_axis, const vec2 old_pos,
	const GLfloat foot_height, const GLfloat new_pos_component) {

	const GLfloat border_size = 0.25f;
	const int8_t sign_of_dir = ((new_pos_component - old_pos[varying_axis]) > 0.0f) ? 1 : -1;
	const GLfloat new_pos_w_border = new_pos_component + border_size * sign_of_dir;

	if (new_pos_w_border < 0.0f || new_pos_w_border >= map_size[varying_axis])
		return old_pos[varying_axis];


	//////////

	vec2 new_pos_w_old;
	new_pos_w_old[varying_axis] = new_pos_w_border;
	new_pos_w_old[!varying_axis] = old_pos[!varying_axis];

	const byte height_value = *map_point((byte*) heightmap, new_pos_w_old[0], new_pos_w_old[1], map_size[0]);
	/* `foot_height - height_value > -0.001f` is done instead of `foot_height >= height_value`
	because the foot height may be slightly under the height value (like 2.999999 compared to 3.0,
	due to floating-point precision errors). If `>=` is used, the new position is sometimes not returned. */
	if (foot_height - height_value > -constants.almost_zero) return new_pos_component;
	return old_pos[varying_axis];
}

/////
